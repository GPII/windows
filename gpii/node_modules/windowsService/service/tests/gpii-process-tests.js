/* Tests for gpii-process.js
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var jqUnit = require("node-jqunit"),
    path = require("path"),
    child_process = require("child_process"),
    Promise = require("bluebird"),
    gpiiProcess = require("../src/gpii-process.js"),
    windows = require("../src/windows.js"),
    winapi = require("../src/winapi.js");

var gpiiProcessTests = {
    testData: {}
};
var teardowns = [];

jqUnit.module("GPII pipe tests", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpiiProcessTests.testData.startChildProcess = [
    // Shouldn't restart if stopChildProcess is used.
    {
        input: {
            childProcess: {
                key: "norestart-stop-test",
                command: "test-command",
                ipc: null,
                autoRestart: false
            },
            stopChildProcess: false
        },
        expect: {
            restart: false
        }
    },
    {
        input: {
            childProcess: {
                key: "restart-stop-test",
                command: "test-command",
                ipc: null,
                autoRestart: true
            },
            stopChildProcess: true
        },
        expect: {
            restart: false
        }
    },
    {
        input: {
            childProcess: {
                key: "norestart-ipc-stop-test",
                command: "test-command",
                ipc: "norestart",
                autoRestart: false
            },
            stopChildProcess: true
        },
        expect: {
            restart: false
        }
    },
    {
        input: {
            childProcess: {
                key: "restart-ipc-stop-test",
                command: "test-command",
                ipc: "restart",
                autoRestart: true
            },
            stopChildProcess: true
        },
        expect: {
            restart: false
        }
    },
    // Should restart if killed, and autoRestart is set
    {
        input: {
            childProcess: {
                key: "norestart-kill-test",
                command: "test-command",
                ipc: null,
                autoRestart: false
            },
            stopChildProcess: false
        },
        expect: {
            restart: false
        }
    },
    {
        input: {
            childProcess: {
                key: "restart-kill-test",
                command: "test-command",
                ipc: null,
                autoRestart: true
            },
            stopChildProcess: false
        },
        expect: {
            restart: true
        }
    },
    {
        input: {
            childProcess: {
                key: "norestart-ipc-kill-test",
                command: "test-command",
                ipc: "norestart",
                autoRestart: false
            },
            stopChildProcess: false
        },
        expect: {
            restart: false
        }
    },
    {
        input: {
            childProcess: {
                key: "restart-ipc-kill-test",
                command: "test-command",
                ipc: "restart",
                autoRestart: true
            },
            stopChildProcess: false
        },
        expect: {
            restart: true
        }
    }
];

gpiiProcessTests.testData.monitorProcessFailures = [
    { input: null },
    { input: 0  },
    { input: -1 },
    { input: 4 } // System process
];

/**
 * Start a process that self terminates after 10 seconds.
 * @return {ChildProcess}
 */
gpiiProcessTests.startProcess = function () {
    var id = "gpiiProcessTest" + Math.random().toString(32).substr(2);
    var exe = path.join(process.env.SystemRoot, "/System32/waitfor.exe");
    var command = exe + " " + id + " /T 10 ";
    return child_process.exec(command);
};

/**
 * Waits for a mutex to be create, by polling until OpenMutex succeeds.
 *
 * @param mutexName {String} The name of the mutex.
 * @param timeout {Number} [Optional] How long to wait (ms), default 1000.
 * @return {Promise} Resolves when a mutex with the given name has been created, or with value of "timeout".
 */
gpiiProcessTests.waitForMutex = function (mutexName, timeout) {
    return new Promise(function (resolve, reject) {
        var nameBuffer = winapi.stringToWideChar(mutexName);

        var timedout = false;
        setTimeout(function () {
            timedout = true;
            resolve("timeout");
        }, timeout || 1000);

        // Poll until OpenMutex succeeds.
        var checkMutex = function () {
            var mutexHandle = winapi.kernel32.OpenMutexW(winapi.constants.SYNCHRONIZE, false, nameBuffer);

            if (mutexHandle) {
                winapi.kernel32.ReleaseMutex(mutexHandle);
                winapi.kernel32.CloseHandle(mutexHandle);
                resolve();
            } else if (!timedout) {
                var err = winapi.kernel32.GetLastError();
                var ERROR_FILE_NOT_FOUND = 2;
                if (err === ERROR_FILE_NOT_FOUND) {
                    setTimeout(checkMutex, 200);
                } else {
                    reject(winapi.error("OpenMutex", 0, err));
                }
            }
        };

        checkMutex();
    });
};

// Tests startChildProcess, stopChildProcess, and autoRestartProcess (indirectly)
jqUnit.asyncTest("Test startChildProcess", function () {

    var testData = gpiiProcessTests.testData.startChildProcess;
    // Don't delay restarting the process.
    var throttleRate_orig = gpiiProcess.throttleRate;
    gpiiProcess.throttleRate = function () {
        return 1;
    };
    teardowns.push(function () {
        gpiiProcess.throttleRate = throttleRate_orig;
    });

    // For each test a child process is started (using the input data). It's then stopped via either stopChildProcess or
    // kill. A check is made if the process has ended, and if the process has been restarted or not.
    // The pid of the new child process is unknown, so a mutex is created by the child then checked here if it exists or
    // not to determine if the new process is running.
    var nextTest = function (testIndex) {
        if (testIndex >= testData.length) {
            jqUnit.start();
            return;
        }
        var test = testData[testIndex];
        var messageSuffix = " - " + test.input.childProcess.key;

        var procConfig = Object.assign({}, test.input.childProcess);
        var mutexName = procConfig.key + Math.random().toString(32);
        procConfig.command = "node.exe " + path.join(__dirname, "gpii-ipc-tests-child.js") + " mutex " + mutexName;

        var promise = gpiiProcess.startChildProcess(procConfig);

        jqUnit.assertTrue("startProcess must return a promise" + messageSuffix,
            promise && typeof(promise.then) === "function");

        promise.then(function (pid) {
            jqUnit.assertFalse("startProcess must resolve with a numeric pid" + messageSuffix, isNaN(pid));
            var pidRunning = gpiiProcess.isProcessRunning(pid);
            jqUnit.assertTrue("startProcess must resolve with a running pid" + messageSuffix, pidRunning);

            // See if the process gets restarted (or not).
            windows.waitForProcessTermination(pid, 1000).then(function (value) {
                if (value === "timeout") {
                    jqUnit.fail("child process didn't terminate" + messageSuffix);
                } else {
                    // See if the new process was restarted, by waiting for the mutex it creates.
                    gpiiProcessTests.waitForMutex(mutexName).then(function (value) {
                        if (test.expect.restart) {
                            jqUnit.assertNotEquals("process should restart" + messageSuffix, "timeout", value);
                        } else {
                            jqUnit.assertEquals("process should not restart" + messageSuffix, "timeout", value);
                        }

                        gpiiProcess.stopChildProcess(procConfig.key);

                        nextTest(testIndex + 1);
                    }, jqUnit.fail);
                }
            }, jqUnit.fail);

            // Kill the first process.
            if (test.input.stopChildProcess) {
                gpiiProcess.stopChildProcess(procConfig.key);
            } else {
                process.kill(pid);
            }

        }, jqUnit.fail);
    };

    nextTest(0);

});

jqUnit.asyncTest("Test monitorProcess - single process", function () {
    jqUnit.expect(3);

    var child = gpiiProcessTests.startProcess();
    var promise = gpiiProcess.monitorProcess(child.pid);

    jqUnit.assertTrue("monitorProcess must return a promise", promise && typeof(promise.then) === "function");

    var killed = false;
    promise.then(function (value) {
        jqUnit.assertTrue("monitorProcess should not resolve before the process is killed", killed);
        jqUnit.assertEquals("monitorProcess should resolve with the process id", child.pid, value);
        jqUnit.start();
    }, jqUnit.fail);

    setTimeout(function () {
        killed = true;
        child.kill();
    }, 100);

});

jqUnit.asyncTest("Test monitorProcess - multiple processes", function () {

    var killOrder = [ 4, 0, 2, 1, 3 ];
    var procs = [];
    for (var n = 0; n < killOrder.length; n++) {
        procs.push(gpiiProcessTests.startProcess());
    }

    jqUnit.expect(procs.length * 2);

    var killed = [];
    var killProcess = function () {
        if (killOrder.length > 0) {
            var proc = procs[killOrder.shift()];
            killed.push(proc.pid);
            proc.kill();
        } else {
            jqUnit.start();
        }
    };

    procs.forEach(function (proc) {
        gpiiProcess.monitorProcess(proc.pid).then(function (pid) {
            jqUnit.assertEquals("monitorProcess must resolve with the same pid", proc.pid, pid);
            jqUnit.assertNotEquals("monitorProcess must resolve after the process is killed", -1, killed.indexOf(pid));
            killProcess();
        }, jqUnit.fail);
    });

    killProcess();

});

jqUnit.asyncTest("Test monitorProcess failures", function () {
    var testData = gpiiProcessTests.testData.monitorProcessFailures;
    jqUnit.expect(testData.length * 4 * 2 + 1);

    var child = gpiiProcessTests.startProcess();

    // Tests are ran twice - the 2nd time, another process is also being monitored. This is to check an innocent process
    // doesn't get caught up in the failure.
    var pass = 0;
    var runTest = function (testIndex) {
        var messageSuffix = " - testIndex=" + testIndex + ", pass=" + pass;

        if (testIndex >= testData.length) {
            pass++;
            if (pass > 1) {
                child.kill();
                return;
            } else {
                // Monitor a process to check it doesn't also get rejected.
                gpiiProcess.monitorProcess(child.pid).then(function () {
                    jqUnit.assertTrue("Child shouldn't resolve until the end" + messageSuffix, pass > 1);
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Child shouldn't fail");
                });
                testIndex = 0;
            }
        }

        var test = testData[testIndex];

        var promise = gpiiProcess.monitorProcess(test.input, 100, false);

        jqUnit.assertTrue("monitorProcess must return a promise", promise && typeof(promise.then) === "function");

        promise.then(function () {
            jqUnit.fail("monitorProcess should not have resolved" + messageSuffix);
        }, function (e) {
            jqUnit.assert("monitorProcess should have rejected" + messageSuffix);
            jqUnit.assertTrue("monitorProcess should have rejected with a value" + messageSuffix, !!e);
            jqUnit.assertTrue("monitorProcess should have rejected with an error" + messageSuffix,
                e instanceof Error || e.isError);

            runTest(testIndex + 1);
        });

    };

    runTest(0, 0);
});

jqUnit.asyncTest("Test unmonitorProcess", function () {
    jqUnit.expect(4);

    var child1 = gpiiProcessTests.startProcess();
    var child2 = gpiiProcessTests.startProcess();
    var promise1 = gpiiProcess.monitorProcess(child1.pid);
    var promise2 = gpiiProcess.monitorProcess(child2.pid);

    var killed = false;
    var removed = false;

    promise1.then(function (value) {
        jqUnit.assertTrue("promise1 should not resolve before it's removed", removed);
        jqUnit.assertEquals("promise1 should resolve with 'removed'", "removed", value);
        killed = true;
        child2.kill();
    }, jqUnit.fail);

    promise2.then(function (value) {
        jqUnit.assertTrue("promise2 should not resolve before the process is killed", killed);
        jqUnit.assertEquals("promise2 should resolve with the process id", child2.pid, value);
        jqUnit.start();
    }, jqUnit.fail);

    setTimeout(function () {
        removed = true;
        gpiiProcess.unmonitorProcess(child1.pid);
    }, 100);

});

