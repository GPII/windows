/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;
using System.Management;

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string commandLine = "";
    public string state = "";
}

public class Startup
{
    public async Task<object> Invoke(dynamic input)
    {
        ManagementObject[] processes = null;
        object propValue;
        ProcessModule mainModule;
        ProcInfo aProcInfo;
        ArrayList result;

        ManagementObjectCollection moc = new ManagementClass(new ManagementPath("Win32_Process")).GetInstances();
        processes = new ManagementObject[moc.Count];
        moc.CopyTo(processes, 0);
        result = new ArrayList();

        // Check input for specified process id or command name.
        if (input != null) {
            if (input.GetType() == typeof(System.Int32)) {
                ManagementObject aProcess = Array.Find(
                    processes, p => Convert.ToInt32(p.GetPropertyValue("ProcessId")) == input
                );
                if (aProcess != null) {
                    result.Add(makeProcInfo(aProcess));
                }
            } else {
                ManagementObject[] someProcesses = Array.FindAll(
                    processes, p => p.GetPropertyValue("Name").ToString() == input
                );
                foreach (ManagementObject p in someProcesses) {
                    result.Add(makeProcInfo(p));
                }
            }
        }
        // No process specified; get all processes and their info.
        else {
            foreach (ManagementObject p in processes) {
                result.Add(makeProcInfo(p));
            }
        }
        return result.ToArray();
    }

    public static ProcInfo makeProcInfo(ManagementObject process) {
        object propValue;

        ProcInfo procInfo = new ProcInfo();
        procInfo.command = process.GetPropertyValue("Name").ToString();
        procInfo.pid = Convert.ToInt32(process.GetPropertyValue("ProcessId"));

        propValue = process.GetPropertyValue("ExecutablePath");
        if (propValue != null) {
            procInfo.fullPath = propValue.ToString();
        }
        propValue = process.GetPropertyValue("CommandLine");
        if (propValue == null) {
            propValue = "";
        }
        procInfo.commandLine = propValue.ToString();

        // Should be able to get the state of the process using the
        // "ExecutionState" property, but that is not implemented; see:
        // http://maestriatech.com/wmi.php
        //
        // Use the Process's main thread's state (the first one).
        // Also, map Windows thread states to Linux-y process states.
        Process theProcess = Process.GetProcessById(procInfo.pid);
        switch (theProcess.Threads[0].ThreadState) {
            case ThreadState.Running:
            case ThreadState.Wait:
                procInfo.state = "Running";
                break;

            case ThreadState.Initialized:
            case ThreadState.Ready:
            case ThreadState.Standby:
            case ThreadState.Transition:
                procInfo.state = "Sleeping";
                break;

            case ThreadState.Terminated:
            case ThreadState.Unknown:
                procInfo.state = "Zombie";
                break;
        }
        return procInfo;
    }
}
