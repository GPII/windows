/*
 * USB User listener Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    ffi = require("ffi");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");

jqUnit.module("gpii.tests.userListener.usb");

fluid.defaults("gpii.tests.userListener.usbListener", {
    gradeNames: ["fluid.component", "gpii.userListeners.usb.windows"],
    listeners: {
        "onTokenArrive.callFlowManager": "fluid.identity",
        "onTokenRemove.callFlowManager": "fluid.identity"
    }
});

gpii.tests.userListener.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms633499
    "FindWindowW": [
        gpii.windows.types.HANDLE, ["char*", "int"]
    ],
    // https://msdn.microsoft.com/library/ms644950
    "SendMessageW": [
        "int", [gpii.windows.types.HANDLE, gpii.windows.types.UINT, gpii.windows.types.UINT, "void*" ]
    ]
});

gpii.tests.userListener.getUSBListener = function () {
    var userListeners = gpii.userListeners({
        listeners: {
            "onCreate.startListeners": "fluid.identity"
        },
        distributeOptions: {
            record: "gpii.tests.userListener.usbListener",
            target: "{that usb}.options.gradeNames"
        }
    });

    return userListeners.usb;
};

/**
 * Finds a window, based on the classname.
 * @param className {String} The window class name.
 * @return {number} The window handle, or null if not found.
 */
gpii.tests.userListener.findWindow = function (className) {
    var classNameBuffer = gpii.windows.stringToWideChar(className);
    var handle = gpii.tests.userListener.user32.FindWindowW(classNameBuffer, 0);
    return handle || null;
};

// Test the message window gets created and destroyed.
jqUnit.test("USB listener start/stop - message window", function () {
    var className = "gpii-usb-listener";

    var window = gpii.tests.userListener.findWindow(className);
    jqUnit.assertNull("Message window should not exist before starting the listener", window);

    var listener = gpii.tests.userListener.getUSBListener();

    // Start the listener
    listener.startListener();
    window = gpii.tests.userListener.findWindow(className);
    jqUnit.assertNotNull("Message window should exist after starting the listener", window);

    // Stop the listener
    listener.stopListener();

    window = gpii.tests.userListener.findWindow(className);
    jqUnit.assertNull("Message window should not exist after stopping the listener", window);

});

/**
 * Sends the device added/removed message (WM_DEVICECHANGE) to the message window, to simulate a device arrival/removal
 * event.
 *
 * It blocks until the message has been handled (by gpii.windows.userListeners.windowProc).
 *
 * @param added {boolean} true to add the device, false to remove
 * @param drives {String|String[]} The drive letter(s) that the device provides.
 */
gpii.tests.userListener.sendDeviceMessage = function (added, drives) {
    var className = "gpii-usb-listener";
    var window = gpii.tests.userListener.findWindow(className);

    var volume = new gpii.windows.DEV_BROADCAST_VOLUME();
    volume.ref().fill(0);
    volume.size = gpii.windows.DEV_BROADCAST_VOLUME.size;
    volume.deviceType = gpii.windows.API_constants.DBT_DEVTYP_VOLUME;

    // Each bit in the mask represents a drive letter.
    var mask = 0;
    var a = "A".charCodeAt(0);
    fluid.each(fluid.makeArray(drives), function (letter) {
        mask |= 1 << letter.toUpperCase().charCodeAt(0) - a;
    });
    volume.unitMask = mask;

    // Can't use PostMessage because lParam is a pointer.
    gpii.tests.userListener.user32.SendMessageW(
        window,
        gpii.windows.API_constants.WM_DEVICECHANGE,
        added ? gpii.windows.API_constants.DBT_DEVICEARRIVAL : gpii.windows.API_constants.DBT_DEVICEREMOVECOMPLETE,
        volume.ref());

};

// Test the USB detection by sending the appropriate message to the message window
jqUnit.asyncTest("USB listener - device detection", function () {
    var usbListener = gpii.tests.userListener.getUSBListener();

    var tests = [
        "A", "Z", // first and last
        [ "D", "E", "F" ], // multiple volumes
        "X", "X" // (un)mount an already (un)mounted
    ];

    // Expect the drive letter for each test item.
    var expected = fluid.transform(Array.prototype.concat.apply([], tests), function (input) {
        return input + ":\\";
    });

    jqUnit.expect(expected.length * 4);

    var mountIndex = 0;
    var unmountIndex = 0;

    usbListener.events.onMount.removeListener("readToken");
    usbListener.events.onMount.addListener(function (that, path) {
        var expect = expected[mountIndex];
        jqUnit.assertEquals("onMount that - index=" + mountIndex, usbListener, that);
        jqUnit.assertEquals("onMount path - index=" + mountIndex, expect, path);
        if (++mountIndex >= expected.length) {
            // Umount the drives
            fluid.each(tests, function (test) {
                gpii.tests.userListener.sendDeviceMessage(false, test);
            });
        }
    });

    usbListener.events.onUnmount.removeListener("readToken");
    usbListener.events.onUnmount.addListener(function (that, path) {
        var expect = expected[unmountIndex];
        jqUnit.assertEquals("onUnmount that - index=" + unmountIndex, usbListener, that);
        jqUnit.assertEquals("onUnmount path - index=" + unmountIndex, expect, path);
        if (++unmountIndex >= expected.length) {
            usbListener.stopListener();
            jqUnit.start();
        }
    });

    usbListener.startListener();

    // Mount the drives.
    fluid.each(tests, function (test) {
        gpii.tests.userListener.sendDeviceMessage(true, test);
    });

});
