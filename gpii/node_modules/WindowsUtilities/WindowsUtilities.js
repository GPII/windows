/*!
Windows Registry Settings Handler

Copyright 2012 Raising the Floor - International
Copyright 2012 Antranig Basman
Copyright 2012 Astea Solutions AD

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict"; 

var ffi = require("ffi");
var fluid = require("universal");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var ref = require("ref");
var Struct = require("ref-struct");
var NULL = ref.NULL;
var $ = fluid.jQueryStandalone;

var os = require("os");

windows.kernel32 = new ffi.Library("kernel32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd319072(v=vs.85).aspx
    // UINT, DWORD, LPCSTR, INT, LPWSTR, INT
    "MultiByteToWideChar": [
        "int", ["uint", "uint32", "pointer", "int", "pointer", "int"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130(v=vs.85).aspx
    // UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL
    "WideCharToMultiByte": [
        "int", ["uint", "uint32", "string", "int", "string", "int", "string", "bool*"]
    ],
    
    "GetLastError": [
        "int32", []
    ],
    "SetLastError": [
        "void", [ "int32" ]
    ]
});

// Windows API constants delved from the unfathomable deeps of windows.h
windows.API_constants = {
    HKEY_CLASSES_ROOT:   0x80000000,
    HKEY_CURRENT_USER:   0x80000001,
    HKEY_LOCAL_MACHINE:  0x80000002,
    HKEY_USERS:          0x80000003,
    HKEY_CURRENT_CONFIG: 0x80000005,
    CP_UTF8: 65001,
    KEY_QUERY_VALUE: 1,
    KEY_SET_VALUE: 2,
    returnCodes: {
        0: "ERROR_SUCCESS",
        1: "ERROR_INVALID_FUNCTION",
        2: "FILE_NOT_FOUND",
        3: "PATH_NOT_FOUND",
        6: "ERROR_INVALID_HANDLE"
    }
};

// http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
windows.HighContrast = new Struct({
    "cbSize": "uint32",
    "dwFlags": "int32",
    "lpszDefaultScheme": "pointer"
});
windows.highContrastPointer = ref.refType(windows.HighContrast);

// http://msdn.microsoft.com/en-us/library/windows/desktop/dd145037(v=vs.85).aspx
windows.LogFont = new Struct([
    ["int32",  "lfHeight"],
    ["int32",  "lfWidth"],
    ["int32",  "lfEscapement"],
    ["int32",  "lfOrientation"],
    ["int32",  "lfWeight"],
    ["uchar",  "lfItalic"],
    ["uchar",  "lfUnderline"],
    ["uchar",  "lfStrikeOut"],
    ["uchar",  "lfCharSet"],
    ["uchar",  "lfOutPrecision"],
    ["uchar",  "lfClipPrecision"],
    ["uchar",  "lfQuality"],
    ["uchar",  "lfPitchAndFamily"],
    ["pointer", "lfFaceName"]
]);
windows.LogFont.size = 92; // FIXME - This way we allocate memory for lfFaceName which is actually an array.
windows.logFontPointer = ref.refType(windows.LogFont);

// http://msdn.microsoft.com/en-us/library/windows/desktop/ff729175(v=vs.85).aspx
windows.NonClientMetrics = new Struct([
    ["uint32",   "cbSize"],
    ["int32",    "iBorderWidth"],
    ["int32",    "iScrollWidth"],
    ["int32",    "iScrollHeight"],
    ["int32",    "iCaptionWidth"],
    ["int32",    "iCaptionHeight"],
    [windows.LogFont,  "lfCaptionFont"],
    ["int32",    "iSmCaptionWidth"],
    ["int32",    "iSmCaptionHeight"],
    [windows.LogFont,  "lfSmCaptionFont"],
    ["int32",    "iMenuWidth"],
    ["int32",    "iMenuHeight"],
    [windows.LogFont,  "lfMenuFont"],
    [windows.LogFont,  "lfStatusFont"],
    [windows.LogFont,  "lfMessageFont"],
    ["int32", "iPaddedBorderWidth"]
]);
windows.nonClientMetricsPointer = ref.refType(windows.NonClientMetrics);
// TODO Define additional structures used in calls to SystemParametersInfo here.

/**
 * Contains actions that can be used as the first argument of the SystemParametersInfo function.
 */
windows.actionConstants = {
    "SPI_GETHIGHCONTRAST":     0x0042,
    "SPI_SETHIGHCONTRAST":     0x0043,
    "SPI_GETNONCLIENTMETRICS": 0x0029,
    "SPI_SETNONCLIENTMETRICS": 0x002A,
    "SPI_GETICONTITLELOGFONT": 0x001F,
    "SPI_SETICONTITLELOGFONT": 0x0022,
    "SPI_GETSTICKYKEYS":       0x003A,
    "SPI_SETSTICKYKEYS":       0x003B,
    "SPI_GETFILTERKEYS":       0x0032,
    "SPI_SETFILTERKEYS":       0x0033,
    "SPI_GETMOUSE":            0x0003,
    "SPI_SETMOUSE":            0x0004,
    "SPI_GETMOUSECLICKLOCK":   0x101E,
    "SPI_SETMOUSECLICKLOCK":   0x101F,

    "SPI_GETMOUSETRAILS":      0x005E,
    "SPI_SETMOUSETRAILS":      0x005D
    // TODO Define additional actions used in calls to SystemParametersInfo here.
};

/**
 * Contains flags used in the "dwFlags" field of various structures
 * that are used in calls to the SystemParametersInfo function.
 */
windows.flagConstants = {
    // HIGHCONTRAST flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
    "HCF_AVAILABLE":       0x00000002,
    "HCF_CONFIRMHOTKEY":   0x00000008,
    "HCF_HIGHCONTRASTON":  0x00000001,
    "HCF_HOTKEYACTIVE":    0x00000004,
    "HCF_HOTKEYAVAILABLE": 0x00000040,
    "HCF_HOTKEYSOUND":     0x00000010,
    "HCF_INDICATOR":       0x00000020,

    // STICKYKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd373652%28v=vs.85%29.aspx
    "SKF_AUDIBLEFEEDBACK": 0x00000040,
    "SKF_AVAILABLE":       0x00000002,
    "SKF_HOTKEYACTIVE":    0x00000004,

    // FILTERKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318079%28v=vs.85%29.aspx
    "FKF_AVAILABLE":       0x00000002,
    "FKF_CLICKON":         0x00000040,
    "FKF_CONFIRMHOTKEY":   0x00000008,
    "FKF_FILTERKEYSON":    0x00000001,
    "FKF_HOTKEYACTIVE":    0x00000004,
    "FKF_HOTKEYSOUND":     0x00000010,
    "FKF_INDICATOR":       0x00000020

    // TODO Define additional flags used across various structures here.
};

/**
 * Contains structures that are used in calls to the SystemParametersInfo function,
 * accessible by their names. Used to dynamically instantiate the appropriate structure.
 */
windows.structures = {
    "HIGHCONTRAST":     windows.HighContrast,
    "NONCLIENTMETRICS": windows.NonClientMetrics,
    "LOGFONT":          windows.LogFont
    // TODO Add additional structures that we need to instantiate here.
};

/**
 * A map between Windows and C types.
 */
windows.types = {
    "BOOL":   "int",
    "INT":    "int",
    "UINT":   "uint",
    "ULONG":  "ulong",
    "DWORD":  "ulong",
    "HKL":    "void*"
};


gpii.pointerToHex = function (pointer, count) {
    var togo = "";
    for (var i = 0; i < count; ++i) {
        var nbyte = pointer.readUInt8(i);
        togo += (nbyte < 16 ? "0" : "") + nbyte.toString(16);
        if (i !== count - 1) {
            togo += " ";
        }
    }
    return togo;
};

// Slow but short method to parse very forgiving hex streams - any non-hex characters will be ignored. Digits
// forming a single byte must be adjacent
gpii.hexToPointer = function (hexString) {
    var buffer = [];
    var i;
    for (i = 0; i < hexString.length; ++i) {
        var c = hexString.charAt(i);
        var digit = parseInt(c, 16);
        if (!isNaN(digit)) {
            buffer.push(digit);
        }
    }
    if ((buffer.length % 2) === 1) {
        fluid.fail("Odd number of hex digits in buffer " + hexString);
    }
    
    var togo = new Buffer(buffer.length / 2);
    
    for (i = 0; i < buffer.length; i += 2) {
        togo.writeUInt8(buffer[i] * 16 + buffer[i + 1], i / 2);
    }
    return {
        pointer: togo,
        length: buffer.length / 2
    };
};

var c = windows.API_constants; 

windows.convertReturnCode = function (code) {
    return "Return code " + code + ": " + c.returnCodes[code];
};

windows.checkReturnCode = function (code) {
    if (code !== 0) {
        fluid.fail(windows.convertReturnCode(code));
    }
};

windows.toWideChar = function (string) {
    var stringBuffer = new Buffer(string);
    
    var chars = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, NULL, 0);
    
    var buffer = new Buffer(chars * 2 + 2); // 2 extra bytes for the null character
    
    var chars2 = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, buffer, chars);
    if (chars2 !== chars) {
        fluid.fail("Expected to write " + chars + " characters, only wrote " + chars2); 
    }

    buffer.writeInt16BE(0, chars * 2);  // add the null character at the end
    return {
        pointer: buffer,
        length: chars * 2
    };
};

windows.fromWideChar = function (buffer) {
    buffer = ref.reinterpretUntilZeros(buffer, 2, 0);
    
    var bytes = windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, NULL, 0, NULL, NULL);

    var convertBuffer = new Buffer(bytes);
    
    windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, convertBuffer, bytes, NULL, NULL);
    
    return convertBuffer.toString();
};

/**
 * Buffer-based conversions
 */
windows.stringToWideChar = function (string) {
    return new Buffer(string + "\u0000", "ucs2"); // add null at the end
};

windows.stringFromWideChar = function (buffer) {
    return ref.reinterpretUntilZeros(buffer, 2, 0).toString("ucs2");
};

/*
 * Unicode registry functions need the string pointers aligned on 16bit boundary.
 */
windows.ensureAlignment = function (buffer) {
    if (ref.address(buffer) & 1) { // not aligned
        var alignedBuffer = new Buffer(buffer.length + 1);
        
        if (ref.address(alignedBuffer) & 1) { // the new buffer is not aligned as well
            buffer.copy(alignedBuffer, 1);
            return alignedBuffer.slice(1);
            
        } else { // the new buffer is OK
            buffer.copy(alignedBuffer);
            return alignedBuffer.slice(0, alignedBuffer.length - 1);
        }
    }
    
    return buffer;
};

/**
 * If a structure is not already defined, creates it by using the structure template in the payload.
 * If such is not provided, throws an exception.
 */
windows.defineStruct = function (payload) {
    if (payload.options.pvParam.type === "struct" && !windows.structures[payload.options.pvParam.name]) {
        if (!payload.options.pvParam.template) {
            throw "Cannot create structure " + payload.options.pvParam.name + " - payload.options.pvParam.template not found!";
        }

        windows.structures[payload.options.pvParam.name] = new Struct(payload.options.pvParam.template);
    }
};

/**
 * Creates an empty structure with a given name. It should be registered in the
 * <code>windows.structures</code> map with that name. If the structure has a <code>cbSize</code>
 * member, the function sets that member to the size of the structure using <code>ffi.sizeof</code>.
 *
 * @param {String} structName The name of the structure to create. Should be registered in the
 *                 <code>windows.structures</code> map.
 * @return {Object} The newly created structure with its <code>cbSize</code> member initialized.
 */
windows.createEmptyStructure = function (structName) {
    var struct = new windows.structures[structName]();

    if (struct.cbSize !== undefined) {
        struct.cbSize = windows.structures[structName].size;
        if (structName === "NONCLIENTMETRICS" && os.release() < "6") {
            struct.cbSize -= 4; // do not unclude NONCLIENTMETRICS.iPaddedBorderWidth
        }
    }

    return struct;
};

/**
 * Takes an array of flag names, applies binary OR among them and returns the result.
 * Used to supply the "dwFlags" argument of some structures.
 *
 * @param {Array} flagNamesArray An array of flag names.
 *                These should be predefined in windows.flagConstants.
 */
windows.combineFlags = function (flagNamesArray) {
    var combinedFlags = 0;
    if (!fluid.isArrayable(flagNamesArray)) {
        console.log("GPII Windows SpiSettingsHandler combineFlags: array expected!");
        return 0;
    }
    for (var index in flagNamesArray) {
        combinedFlags = combinedFlags | windows.flagConstants[flagNamesArray[index]];
    }
    return combinedFlags;
};

/**
 * Gets the value of a given flag name.
 *
 * @param {String} flagName The name of the flag whose value we need.
 * @return {Number} The value of the flag.
 */
windows.getFlagValue = function (flagName) {
    var flagValue = windows.flagConstants[flagName];
    if (flagValue === undefined) {
        fluid.fail("Unknown flag name " + flagName);
    }
    return flagValue;
};

/**
 * Accesses consecutive fields of an object.
 * 
 * @param {Object} object The object to be accessed.
 * @param {String} path A string containing the consecutive field names, separated by '.'
 * @param {Object} setValue <optional> A new value to be stored in the field.
 * @return {Object} The value stored in the field.
 */
windows.resolvePath = function (object, path, setValue) {
    var flagsIndex = path.indexOf("dwFlags");
    if (flagsIndex !== -1) {
        var path1 = path.substr(0, flagsIndex - 1);
        var flagName = path.substr(path.lastIndexOf(".") + 1);
        return windows.accessFlag(fluid.get(object, path1), flagName, setValue);
        
    } else {
        if (setValue !== undefined) {
            if (typeof setValue === "string") {
                setValue = windows.stringToWideChar(setValue);
            }
            fluid.set(object, path, setValue);
        }
        
        var value = fluid.get(object, path);
        return Buffer.isBuffer(value) ? windows.stringFromWideChar(value) : value;
    }
};

/**
 * Accesses a single flag in a flags field of an object.
 * 
 * @param {Object} object The object to be accessed.
 * @param {String} flagName A string containing the flag name according to the Windows API.
 * @param {Object} setValue <optional> A new value for the flag.
 * @return {Object} The value of the flag.
 */
windows.accessFlag = function (object, flagName, setValue) {
    var flagValue = windows.getFlagValue(flagName);
    
    if (setValue !== undefined) {
        setValue = Boolean(setValue);
        if (setValue) {
            object.dwFlags |= flagValue;
        } else {
            object.dwFlags &= ~flagValue;
        }
    }
    
    return Boolean(object.dwFlags & flagValue);
};

/**
 * Converts an array to a buffer.
 * 
 * @param {Array} array The array to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Buffer} A buffer representing the raw memory allocated for the array.
 */
windows.arrayToBuffer = function (array, type) {
    var size = ref.coerceType(windows.types[type]).size;
    var buf = new Buffer(array.length * size);
    
    for (var i = 0; i < array.length; ++i) {
        ref.set(buf, i * size, array[i], windows.types[type]);
    }
    
    return buf;
};

/**
 * Converts a buffer to an array.
 * 
 * @param {Buffer} buffer The buffer to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Array} An array containing the values stored in the buffer.
 */
windows.bufferToArray = function (buffer, type) {
    var array = [];
    var size = ref.coerceType(windows.types[type]).size;
    
    for (var i = 0; i < buffer.length / size; ++i) {
        array[i] = ref.get(buffer, i * size, windows.types[type]);
    }
    
    return array;
};

windows.invokeSettingsHandler = function (payload, handler) {
    // TODO: use model transformation
    return fluid.transform(payload, function (oneSolution) {
        return fluid.transform(oneSolution, function (element) {
              // TODO: more efficient algorithm
            var directLoad = fluid.filterKeys(fluid.copy(element), ["settings", "options"]);
            var others = fluid.censorKeys(fluid.copy(element), ["settings", "options"]);
            var results = {
                settings: handler(directLoad),
            };
            return $.extend(results, others);
        });
    });
};

exports.windows = windows;
