/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;
using System.Management;

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string[] argv;
    public string state = "";
}

public class Startup
{
    public async Task<object> Invoke(dynamic input)
    {
        ManagementObject[] processes = null;
        object propValue;
        ProcessModule mainModule;
        ProcInfo aProcInfo;
        ArrayList result;

        ManagementObjectCollection moc = new ManagementClass(new ManagementPath ("Win32_Process")).GetInstances();
        processes = new ManagementObject[moc.Count];
        moc.CopyTo(processes, 0);
        result = new ArrayList();

        // Check input for specified process id or command name.
        if (input != null) {
            if (input.GetType() == typeof(System.Int32)) {
                ManagementObject aProcess = Array.Find(
                    processes, p => Convert.ToInt32(p.GetPropertyValue("ProcessId")) == input
                );
                if (aProcess != null) {
                    result.Add(makeProcInfo(aProcess));
                }
            } else {
                ManagementObject[] someProcesses = Array.FindAll(
                    processes, p => p.GetPropertyValue("Name").ToString() == input
                );
                foreach (ManagementObject p in someProcesses) {
                    result.Add(makeProcInfo(p));
                }
            }
        }
        // No process specified; gat all processes and their info
        else {
            foreach (ManagementObject p in processes) {
                result.Add(makeProcInfo(p));
            }
        }
        return result.ToArray();
    }

    public static ProcInfo makeProcInfo(ManagementObject process) {
        object propValue;

        ProcInfo procInfo = new ProcInfo();
        procInfo.command = process.GetPropertyValue("Name").ToString();
        procInfo.pid = Convert.ToInt32(process.GetPropertyValue("ProcessId"));

        propValue = process.GetPropertyValue("ExecutablePath");
        if (propValue != null) {
            procInfo.fullPath = propValue.ToString();
        }
        propValue = process.GetPropertyValue("CommandLine");
        if (propValue != null) {
            procInfo.argv = makeArgv(propValue.ToString());

            // In some cases the result is just the command, e.g., "Notepad".
            // In others, it is the full path and may include the ".exe"
            // extension.  Normalize it to always be the full path, if there is
            // one.
            if (procInfo.fullPath.Length > 0) {
                procInfo.argv[0] = procInfo.fullPath;
            }
        }
        // Should be able to get the state of the process using the
        // "ExecutionState" property, but that is not implemented; see:
        // http://maestriatech.com/wmi.php
        //
        // Use the Process's main thread's state (the first one).
        // Also, map Windows thread states to Linux-y process states.
        Process theProcess = Process.GetProcessById(procInfo.pid);
        switch (theProcess.Threads[0].ThreadState) {
            case ThreadState.Running:
            case ThreadState.Wait:
                procInfo.state = "Running";
                break;

            case ThreadState.Initialized:
            case ThreadState.Ready:
            case ThreadState.Standby:
            case ThreadState.Transition:
                procInfo.state = "Sleeping";
                break;

            case ThreadState.Terminated:
            case ThreadState.Unknown:
                procInfo.state = "Zombie";
                break;
        }
        return procInfo;
    }

    public static String[] makeArgv(String commandLine)
    {
        List<String> arguments = new List<String>();

        commandLine = commandLine + " ";
        for (int c = 0; c < commandLine.Length; c++) {
            // Handle quoted strings.
            if (commandLine[c] == '"') {
                int firstChar = c + 1;
                int endQuoteIndex = commandLine.IndexOf('"', firstChar);
                arguments.Add(commandLine.Substring(firstChar, endQuoteIndex - firstChar));
                c = endQuoteIndex;
            }
            // Skip spaces outside of quoted strings.
            else if (commandLine[c] == ' ') {
                continue;
            }
            // Handle non-quoted string.
            else {
                int firstChar = c;
                int endStringIndex = commandLine.IndexOf(' ', firstChar);
                arguments.Add(commandLine.Substring(firstChar, endStringIndex - firstChar));
                c = endStringIndex;
            }
        }
        return arguments.ToArray();
    }
}
