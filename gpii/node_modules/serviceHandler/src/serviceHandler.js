/*
 * Windows Service interface.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    net = require("net");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.windows.serviceHandler");

require("../../WindowsUtilities/WindowsUtilities.js");

var windows = gpii.windows;

fluid.defaults("gpii.windows.serviceHandler", {
    gradeNames: ["fluid.component", "fluid.resolveRootSingle"],
    singleRootType: "gpii.windows.serviceHandler",

    events: {
        "onConnected": null,
        "onPipeClose": null,
        "onPipeError": null
    },
    listeners: {
        "onCreate.connectToService": "{that}.connectToService",
        "onPipeClose": {
            "funcName": "gpii.windows.servicePipeClosed",
            "args": [ "{that}" ]
        },
        "onPipeError": {
            "funcName": "gpii.windows.servicePipeError",
            "args": [ "{that}", "{arguments}.0" ]
        }
    },
    invokers: {
        connectToService: {
            funcName: "gpii.windows.connectToService",
            args: ["{that}"]
        }
    },
    members: {
        connected: false,
        pipePrefix: "\\\\.\\pipe\\gpii-"
    },

    /**
     * The connection to the service.
     * @type net.Socket
     */
    pipe: null
});


/**
 * Connect to the service, as specified by the GPII_SERVICE_PIPE environment variable, which is expected to be in the
 * form of "pipe:<pipe-id>".
 *
 * The full pipe name will then consist of: \\.\pipe\gpii-<pipe-id>.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @return {Promise} Resolves when the connection is complete (and authenticated).
 */
gpii.windows.connectToService = function (that) {
    var pipeId;
    var promise = fluid.promise();

    if (process.env.GPII_SERVICE_PIPE) {
        var match = process.env.GPII_SERVICE_PIPE.match(/^pipe:([^\\/\s]{1,200})\s*$/);
        if (match && match[1]) {
            pipeId = match[1];
        } else {
            fluid.log(fluid.logLevel.WARN, "GPII_SERVICE_PIPE is badly formed: " + process.env.GPII_SERVICE_PIPE);
        }
    } else {
        pipeId = "gpii";
    }

    if (pipeId) {
        var pipeName = that.pipePrefix + pipeId;

        fluid.log(fluid.logLevel.IMPORTANT, "Connecting to Windows service on " + pipeName);

        // Connect to the pipe.
        var connected = false;
        var pipe = net.connect(pipeName, function () {
            connected = true;
            var p = gpii.windows.serviceAuthenticate(that, pipe).then(function () {
                fluid.log("Connected!!");
            }, function (value) {
                fluid.log("Not authenticated with service ", value);
                pipe.destroy();
            });

            fluid.promise.follow(p, promise);
        });

        pipe.on("error", function (err) {
            that.events.onPipeError.fire(err);
            pipe.destroy();
            if (!connected) {
                promise.reject(err);
            }
        });

        that.options.pipe = pipe;
    } else {
        fluid.log("Not connecting to the service.");
        promise.reject();
    }

    return promise;
};

/**
 * Authenticate with the service.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param pipe {net.Socket} The pipe.
 * @return {Promise} Resolves when the connection is complete (and authenticated).
 */
gpii.windows.serviceAuthenticate = function (that, pipe) {
    var promise = fluid.promise();

    var allData = "";
    var authDone = false;

    pipe.on("data", function (data) {
        allData += data;
        if (allData.indexOf("\n") > -1) {
            var lines = allData.split("\n");
            if (allData.endsWith("\n")) {
                allData = "";
            } else {
                allData = lines.pop();
            }

            for (var n = 0; n < lines.length; n++) {
                var line = lines[n];
                var authenticated = false;
                if (line === "OK") {
                    // Service responds with "OK" when authenticated.
                    authenticated = true;
                } else if (line.startsWith("challenge:") && !authDone) {
                    var match = line.match(/^challenge:([0-9]+|none)$/);
                    if (!match || !match[1]) {
                        promise.reject("Invalid authentication challenge: '" + line + "'");
                        break;
                    }
                    var challenge = match[1];
                    if (challenge !== "none") {
                        // Call set event, to prove this process is the pipe client.
                        gpii.windows.serviceChallenge(challenge);
                    }
                    authDone = true;
                } else if (line.length > 0) {
                    promise.reject("Unexpected data from service: " + line);
                    break;
                }

                if (authenticated) {
                    promise.resolve();
                    break;
                }
            }
        }
    });

    pipe.on("close", function () {
        fluid.log("close");
        if (!promise.disposition) {
            promise.reject({
                isError: true,
                message: "Pipe closed"
            });
        }
    });

    pipe.on("error", function (err) {
        if (!that.connected) {
            promise.reject({
                isError: true,
                message: "Pipe error",
                error: err
            });
        }
    });

    return promise.then(function () {
        pipe.removeAllListeners();
    }, function () {
        pipe.removeAllListeners();
        pipe.destroy();
    });
};

/**
 * Performs the authentication challenge presented by the service upon connecting.
 *
 * The challenge data is an event handle, with which SetEvent is called. Only this process is able to use this handle,
 * and the service will know when it's been called (GPII-2399).
 *
 * @param challenge {string} The challenge data.
 */
gpii.windows.serviceChallenge = function (challenge) {
    var eventHandle = parseInt(challenge);
    windows.kernel32.SetEvent(eventHandle);
};

/**
 * Called when the pipe has been closed.
 * @param that {Component} The gpii.windowsMetrics instance.
 */
gpii.windows.servicePipeClosed = function (that) {
    if (that.connected) {
        fluid.log("Service connection closed");
    }
};

/**
 * Called when there's something wrong with the pipe.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param err {Error} The error.
 */
gpii.windows.servicePipeError = function (that, err) {
    if (that.connected) {
        fluid.log("Service connection error", err);
    } else {
        fluid.log("Unable to connect to windows service: ", err.message || err.code || err);
    }
};

if (!process.env.GPII_SERVICE_PIPE_DISABLED) {
    process.nextTick(gpii.windows.serviceHandler);
}
