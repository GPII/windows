/*!
Windows Registry Settings Handler

Copyright 2012 Raising the Floor - International
Copyright 2012 Antranig Basman
Copyright 2012 Astea Solutions AD

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var ffi = require("ffi");
var ref = require("ref");
var fluid = require("universal");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");
fluid.registerNamespace("gpii.windows.registrySettingsHandler")
var util = require("../../WindowsUtilities/WindowsUtilities");

var NULL = ref.NULL;

var user32 = new ffi.Library("user32", {
    "MessageBoxW": [
        "int32", [ "int32", "pointer", "pointer", "int32" ]
    ]
});

// Guide to node_ffi types and conversions:
// https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial

var advapi32 = new ffi.Library("advapi32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, REGSAM, PHKEY
    // Note abuse of type of argument 1 - node_ffi doesn't allow us to forge pointers from integers directly,
    // as required by base keys
    RegOpenKeyExW: [
        "int32", ["uint32", "pointer", "uint32", "uint32", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724837(v=vs.85).aspx
    // HKEY
    RegCloseKey: [
        "long", ["uint32"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724911(v=vs.85).aspx
    // HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD
    RegQueryValueExW: [
        "int32", ["uint32", "pointer", "pointer", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724844(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD
    // Similar abuse to RegOpenKeyExW
    RegCreateKeyExW: [
        "long", ["uint32", "pointer", "uint32", "pointer", "uint32", "uint32", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, DWORD, const BYTE*, DWORD
    RegSetValueExW: [
        "long", ["uint32", "pointer", "uint32", "uint32", "pointer", "uint32"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724845(v=vs.85).aspx
    // HKEY, LPCWSTR
    // Similar abuse to RegOpenKeyExW - for convenience, only accepts base keys
    RegDeleteKeyW: [
        "long", ["uint32", "pointer"]
    ]
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724847(v=vs.85).aspx
    // This API is disused since it was introduced only on Windows Server 2003 (XP support required)
    // HKEY, LPCWSTR, REGSAM, DWORD
    //RegDeleteKeyExW: [
    //    "long", ["uint32", "pointer", "uint32", "uint32"]
    //]
});

windows.registryTypes = {};

windows.registryTypes.REG_SZ = {
    code: 1,
    readConvert: function (pointer) {
        return windows.fromWideChar(pointer);
    },
    writeConvert: function (value) {
        return windows.toWideChar(value);
    }
};

windows.registryTypes.REG_DWORD = {
    code: 4,
    readConvert: function (pointer) {
        return pointer.readUInt32LE(0);
    },
    writeConvert: function (value) {
        var pointer = new Buffer(4);
        pointer.writeUInt32LE(Number(value), 0);
        return {
            pointer: pointer,
            length: 4
        };
    }
};

windows.registryTypes.REG_BINARY = {
    code: 3,
    readConvert: function (pointer, count) {
        return gpii.pointerToHex(pointer, count);
    },
    writeConvert: function (value) {
        return gpii.hexToPointer(value);
    }
};

var c = windows.API_constants;

windows.getBaseKey = function (baseKey) {
    var key = c[baseKey];
    if (key === undefined) {
        fluid.fail("Unknown registry base key " + baseKey);
    }
    return key;
};

var cr = windows.checkReturnCode;

windows.readRegistryKey = function (baseKey, path, subKey, type) {
    //console.log("\nread", baseKey, path, subKey, type, ":")
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };

    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var keyHolder = new Buffer(4);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegOpenKeyExW(base, pathW, 0, c.KEY_QUERY_VALUE, keyHolder);
    if (code === 2) { // FILE_NOT_FOUND
        togo.statusCode = 404;
        return togo;
    }
    cr(code);
    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);
        var dataLength = new Buffer(4);
        var code2 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, NULL, dataLength);
        if (code2 === 2) { // FILE_NOT_FOUND
            togo.statusCode = 404;
            return togo;
        }
        cr(code2);
        togo.bytes = dataLength.readInt32LE(0);

        var valueHolder = new Buffer(togo.bytes);
        var code3 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, valueHolder, dataLength);
        cr(code3);

        togo.value = converter.readConvert(valueHolder, togo.bytes);
    } finally {
        var code4 = advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
        cr(code4);
    }

    return togo;
};

windows.writeRegistryKey = function (baseKey, path, subKey, value, type) {
    //console.log("\nwrite", baseKey, path, subKey, type, ":")
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };
    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var keyHolder = new Buffer(4);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegCreateKeyExW(base, pathW, 0, NULL, 0, c.KEY_SET_VALUE, NULL, keyHolder, NULL);
    cr(code);

    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);
        var converted = converter.writeConvert(value);
        var code2 = advapi32.RegSetValueExW(keyHolder.readUInt32LE(0), subKeyW, 0, converter.code, converted.pointer, converted.length);
        // TODO: consider plausible errors which might result from this process
        cr(code2);
    } finally {
        advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
    }
    return togo;
};

// Note that this function cannot delete keys recursively. RegDeleteKeyExW is not available
// as a result of requirement for Windows XP level API support. This functionality can be
// implemented manually on top of this existing API if required.
windows.deleteRegistryKey = function (baseKey, path) {
    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegDeleteKeyW(base, pathW);
    cr(code);
};

windows.registrySettingsHandler.setImpl = function (payload) {
    var baseKey = payload.options.hKey;
    var path = payload.options.path;
    var results = fluid.transform(payload.settings, function (value, key) {
        //Once GPII-103 is fixed the below 4 lines can be removed
        if (value.value == undefined) {
            fluid.log("Undefined value passed to registry settings handler - ignoring setting with key: "+key);
            return;
        }
        var oldValue = windows.readRegistryKey(baseKey, path, key, value.dataType);
        var writeStatus = windows.writeRegistryKey(baseKey, path, key, value.value, value.dataType);
        var newValue = windows.readRegistryKey(baseKey, path, key, value.dataType);
        return {
            oldValue: oldValue,
            statusCode: writeStatus.statusCode,
            newValue: newValue
        };
    });
    fluid.log("Settings handler returning results ", results);
    return results;
};

windows.registrySettingsHandler.getImpl = function (payload) {
    var baseKey = payload.options.hKey;
    var path = payload.options.path;
    var results = fluid.transform(payload.settings, function (value, key) {
        var currentValue = windows.readRegistryKey(baseKey, path, key, value.dataType);
        return {
            value: currentValue.value,
            dataType: value.dataType
        };
    });
    fluid.log("Settings handler returning results ", results);
    return results;
};

windows.registrySettingsHandler.get = function (payload) {
    return gpii.windows.invokeSettingsHandler(windows.registrySettingsHandler.getImpl, payload);
};

windows.registrySettingsHandler.set = function (payload) {
    return gpii.windows.invokeSettingsHandler(windows.registrySettingsHandler.setImpl, payload);
};

if (process.argv[1].indexOf("egistrySettingsHandler") !== -1 && process.argv.length === 3) {
    var filename = __dirname + "/" + process.argv[2];
    // Note that this is now possible!
    // http://blog.gvm-it.eu/post/8175813806/node-js-0-5-2-load-json-files-with-require
    var testFile = require(filename);
    console.log("Executing payload: ", testFile);
    var results = windows.registrySettingsHandler.setImpl(testFile);
    console.log("Returned results: ", results);
    windows.deleteRegistryKey(testFile.options.hKey, testFile.options.path);
}
