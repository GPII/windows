/*
 * Windows Registry Settings Handler
 *
 * Copyright 2012 Raising the Floor - International
 * Copyright 2012 Antranig Basman
 * Copyright 2012 Astea Solutions AD
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

// GPII-3445: Monkey patch the Callback constructor to keep a reference of the callback info buffer, to prevent it from
// being GC'd. Otherwise, callbacks (such as the message window's window procedure) will end up reading a freed or
// reallocated piece of memory. This constructor is used by ffi-napi, so needs to be patched before it's included.
var ffiBindings = require("ffi-napi/lib/bindings.js");
var origCallback = ffiBindings.Callback;
ffiBindings.Callback = function (cif, size, argc, errorReportCallback, fn) {
    var ret = origCallback(cif, size, argc, errorReportCallback, fn);
    // Attach the data onto the returned callback pointer, so it lasts as long as the callback.
    ret["ffi.cif"] = cif;
    return ret;
};

var ffi = require("ffi-napi"),
    child_process = require("child_process"),
    fluid = require("gpii-universal");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var ref = require("ref");
var Struct = require("ref-struct");
var arrayType = require("ref-array");
var NULL = ref.NULL;

var os = require("os");
var arch = os.arch();

/**
 * A map between Windows and C types.
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx
 */
windows.types = {
    "BOOL":   "int",
    "PBOOL":   "*int",
    "INT":    "int",
    "UINT":   "uint",
    "ULONG":  "ulong",
    "DWORD":  "ulong",
    "LPDWORD":  "*ulong",
    "HKL":    "void*",
    "ULONG_PTR": arch === "x64" ? "uint64" : "uint32",
    "LONG": "long",
    "HANDLE": arch === "x64" ? "uint64" : "uint32",
    "PVOID": ref.refType("void"),
    "WORD":   "uint16",
    "LUID": "uint64",
    // TODO: TCHAR should support Unicode and Windows code pages. We are just guessing
    // the system is using Unicode (wchar_t == uint16 type). The implementation should
    // support both modes.
    // https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx
    "TCHAR": "uint16",
    "PTCHAR": ref.refType("uint16")
};

var t = windows.types;

windows.kernel32 = ffi.Library("kernel32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd319072(v=vs.85).aspx
    // UINT, DWORD, LPCSTR, INT, LPWSTR, INT
    "MultiByteToWideChar": [
        "int", ["uint", "uint32", "char*", "int", "void*", "int"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130(v=vs.85).aspx
    // UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL
    "WideCharToMultiByte": [
        "int", ["uint", "uint32", "void*", "int", "char*", "int", "char*", "bool*"]
    ],

    "GetLastError": [
        "uint32", []
    ],
    "SetLastError": [
        "void", [ "int32" ]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx
    "CreateToolhelp32Snapshot": [
        t.HANDLE, [t.DWORD, t.DWORD]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834%28v=vs.85%29.aspx
    "Process32First": [
        "bool", [t.DWORD, "pointer"]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx
    "OpenProcess": [
        t.HANDLE, [t.DWORD, t.BOOL, t.DWORD]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.85%29.aspx
    "TerminateProcess": [
        t.BOOL, [t.HANDLE, t.UINT]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx
    "CloseHandle": [
        t.BOOL, [t.HANDLE]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836%28v=vs.85%29.aspx
    "Process32Next": [
        t.BOOL, [t.HANDLE, "pointer"]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684139.aspx
    "IsWow64Process": [
        t.BOOL,  [t.INT, t.PBOOL ]
    ],
    // https://msdn.microsoft.com/library/ms684919.aspx
    "QueryFullProcessImageNameW": [
        t.BOOL, [t.HANDLE, t.DWORD, "char*", t.LPDWORD ]
    ],
    // https://msdn.microsoft.com/library/ms683199
    "GetModuleHandleW": [
        t.HANDLE, ["int"]
    ],
    // https://msdn.microsoft.com/library/ms683223
    "GetProcessTimes": [
        t.BOOL, [ t.HANDLE, "void*", "void*", "void*", "void*" ]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-formatmessage
    "FormatMessageW": [
        t.DWORD, [t.DWORD, t.PVOID, t.DWORD, t.DWORD, t.PTCHAR, t.DWORD, t.PVOID]
    ],
    // https://msdn.microsoft.com/library/ms686227
    "SetProcessShutdownParameters": [
        t.BOOL, [ t.DWORD, t.DWORD ]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-localfree
    "LocalFree": [
        "uint32", [ "int" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreaduilanguage
    "GetThreadUILanguage": [
        t.WORD, [ ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcidtolocalename
    "LCIDToLocaleName": [
        "int", [ t.WORD, "char*", "int", t.DWORD ]
    ]
});

windows.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms633497
    "EnumWindows": [
        t.BOOL, ["void*", t.HANDLE]
    ],
    // https://msdn.microsoft.com/library/ms633494
    "EnumChildWindows": [
        t.BOOL, [t.HANDLE, "void*", t.HANDLE]
    ],
    // https://msdn.microsoft.com/library/windows/desktop/ms633522
    "GetWindowThreadProcessId": [
        t.DWORD, [t.HANDLE, t.LPDWORD]
    ],
    // https://msdn.microsoft.com/library/windows/desktop/ms644944
    "PostMessageW": [
        t.BOOL, [t.HANDLE, t.UINT, t.UINT, t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633505
    "GetForegroundWindow": [
        t.HANDLE, []
    ],
    // https://msdn.microsoft.com/library/ms644990
    "SetWindowsHookExW": [
        t.HANDLE, [ t.INT, "void*", t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms644993
    "UnhookWindowsHookEx": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644974
    "CallNextHookEx": [
        t.HANDLE, [ t.HANDLE, "int", t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms646306
    "MapVirtualKeyW": [
        t.UINT, [ t.UINT, t.UINT ]
    ],
    // https://msdn.microsoft.com/en-us/library/dd145064.aspx
    "MonitorFromWindow": [
        t.HANDLE,  [ t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/dd144901
    "GetMonitorInfoW": [
        // HMONITOR, LPMONITORINFO
        t.BOOL, [t.HANDLE, "pointer"]
    ],
    // https://msdn.microsoft.com/library/ms632680
    "CreateWindowExW": [
        t.HANDLE, [
            t.DWORD,    // dwExStyle
            "char*",  // lpClassName
            "char*",  // lpWindowName
            t.DWORD,    // dwStyle
            t.INT,      // X
            t.INT,      // Y
            t.INT,      // nWidth
            t.INT,      // nHeight
            t.HANDLE,   // hWndParent
            t.HANDLE,   // hMenu
            t.HANDLE,   // hInstance
            t.HANDLE    // lpParam
        ]
    ],
    // https://msdn.microsoft.com/library/ms633586
    "RegisterClassW": [
        t.HANDLE, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms633572
    "DefWindowProcW": [
        t.HANDLE, [ t.HANDLE, t.UINT, t.UINT, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms644943
    "PeekMessageW": [
        t.BOOL, [ t.PVOID, t.HANDLE, t.UINT, t.UINT, t.UINT ]
    ],
    // https://msdn.microsoft.com/library/ms644955
    "TranslateMessage": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms644934
    "DispatchMessageW": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms632682
    "DestroyWindow": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644989
    "RegisterShellHookWindow": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644947
    "RegisterWindowMessageW": [
        t.UINT, [ "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclipboardformatnamew
    "GetClipboardFormatNameW": [
        t.UINT, [ t.UINT, "char*", "int" ]
    ],
    // https://msdn.microsoft.com/library/ms644950
    "SendMessageW": [
        "int", [t.HANDLE, t.UINT, t.UINT, "int" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagew
    "SendNotifyMessageW": [
        "int", [t.HANDLE, t.UINT, t.UINT, "int" ]
    ],
    // https://msdn.microsoft.com/library/ms633519
    "GetWindowRect": [
        t.BOOL, [ t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms646304
    "keybd_event": [
        "void", [ "char", "char", t.DWORD, t.ULONG_PTR ]
    ],
    // https://msdn.microsoft.com/library/ms646260
    "mouse_event": [
        "void", [ t.DWORD, t.DWORD, t.DWORD, t.LONG, t.ULONG_PTR ]
    ],
    // https://msdn.microsoft.com/library/ms648394
    "GetCursorPos": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms648394
    "SetCursorPos": [
        t.BOOL, [ "int", "int" ]
    ],
    // https://msdn.microsoft.com/library/ms633582
    "GetClassNameW": [
        t.INT, [ t.HANDLE, "char*", t.INT ]
    ],
    // https://msdn.microsoft.com/library/ms646329
    "VkKeyScanW": [
        "short", [ t.TCHAR ]
    ],
    // https://msdn.microsoft.com/library/ms633558
    "WindowFromPoint": [
        // Normally defined as WindowFromPoint(POINT)
        t.HANDLE, [ t.LONG, t.LONG ]
    ],
    // https://msdn.microsoft.com/library/ms633548
    "ShowWindow": [
        t.BOOL, [ t.HANDLE, "int" ]
    ],
    // https://msdn.microsoft.com/library/ms633510
    "GetParent": [
        t.HANDLE, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633527
    "IsIconic": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633499
    "FindWindowW": [
        gpii.windows.types.HANDLE, ["char*", "char*"]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getdoubleclicktime
    "GetDoubleClickTime": [
        "uint32", []
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setdoubleclicktime
    "SetDoubleClickTime": [
        "int32", ["uint32"]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics
    "GetSystemMetrics": [
        "int", ["int"]
    ],
    // https://msdn.microsoft.com/library/ms646301
    "GetKeyState": [
        "short", ["int"]
    ]
});

gpii.windows.advapi32 = new ffi.Library("advapi32", {
    // https://msdn.microsoft.com/library/ms684323
    "OpenSCManagerW": [
        t.HANDLE, [ t.HANDLE, t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms684323
    "OpenServiceW": [
        t.HANDLE, [ t.HANDLE, "char*", t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms684939
    "QueryServiceStatus": [
        t.BOOL,  [ t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms682028
    "CloseServiceHandle": [
        t.BOOL,  [ t.HANDLE ]
    ]
});

gpii.windows.shlwapi = new ffi.Library("shlwapi", {
    // https://docs.microsoft.com/en-us/windows/desktop/api/shlwapi/nf-shlwapi-shloadindirectstring
    "SHLoadIndirectString": [
        t.HANDLE, [ "char*", "char*", t.UINT, t.PVOID ]
    ]
});

gpii.windows.shcore = new ffi.Library("Shcore", {
    // https://msdn.microsoft.com/library/dn302122
    "SetProcessDpiAwareness": [
        t.HANDLE, [ t.UINT ]
    ]
});

// Make the process aware of DPI scaling, so Windows doesn't lie about non-client metrics (and perhaps other things).
// See GPII-3099.
gpii.windows.shcore.SetProcessDpiAwareness(1);

// Make gpii shutdown last, so it doesn't close before the shutdown is cancelled by another process.
gpii.windows.kernel32.SetProcessShutdownParameters(0x100, 0);

/**
 * Gets a function pointer for an EnumWindowsProc callback for EnumWindows.
 *
 * See: https://msdn.microsoft.com/en-us/library/ms633498
 *
 * @param {function} callback The callback.
 * @return {*} Function pointer for the given callback, to be passed to EnumWindows
 */
windows.EnumWindowsProc = function (callback) {
    return ffi.Callback(t.BOOL, [t.HANDLE, t.HANDLE], callback);
};

// Windows API constants delved from the unfathomable deeps of windows.h
windows.API_constants = {
    HKEY_CLASSES_ROOT:   0x80000000,
    HKEY_CURRENT_USER:   0x80000001,
    HKEY_LOCAL_MACHINE:  0x80000002,
    HKEY_USERS:          0x80000003,
    HKEY_CURRENT_CONFIG: 0x80000005,
    CP_UTF8: 65001,
    KEY_QUERY_VALUE: 1,
    KEY_SET_VALUE: 2,
    KEY_ENUMERATE_SUB_KEYS: 0x8,
    KEY_WOW64_32KEY: 0x200,
    KEY_WOW64_64KEY : 0x100,
    returnCodesLookup: {
        0: "ERROR_SUCCESS",
        1: "ERROR_INVALID_FUNCTION",
        2: "FILE_NOT_FOUND",
        3: "PATH_NOT_FOUND",
        6: "ERROR_INVALID_HANDLE",
        259: "ERROR_NO_MORE_ITEMS"
    },
    returnCodes: {},

    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx
    PROCESS_TERMINATE: 0x0001,
    PROCESS_QUERY_LIMITED_INFORMATION: 0x1000,
    PROCESS_QUERY_INFORMATION: 0x0400,
    PROCESS_VM_READ: 0x0010,

    // https://msdn.microsoft.com/library/ms685981
    SC_MANAGER_CONNECT: 0x0001,
    SERVICE_QUERY_STATUS : 0x0004,
    // https://msdn.microsoft.com/library/ms685996
    SERVICE_CONTINUE_PENDING: 0x00000005,
    SERVICE_PAUSE_PENDING: 0x00000006,
    SERVICE_PAUSED: 0x00000007,
    SERVICE_RUNNING: 0x00000004,
    SERVICE_START_PENDING: 0x00000002,
    SERVICE_STOP_PENDING: 0x00000003,
    SERVICE_STOPPED: 0x00000001,

    // http://stackoverflow.com/questions/23452271/is-max-path-always-same-size-even-if-unicode-macro-is-defined
    MAX_PATH: 260,
    MAX_NAME: 32,
    ENUM_CURRENT_SETTINGS: 0xffffffff,   // ((DWORD)-1)
    DISP_CHANGE_SUCCESSFUL: 0,
    DISP_CHANGE_RESTART: 1,
    FALSE:  0,
    TRUE:   1,
    // https://msdn.microsoft.com/library/windows/desktop/ms632641
    WM_QUIT: 0x12,
    // https://msdn.microsoft.com/library/ms912654
    WM_KEYDOWN: 0x100,
    // https://msdn.microsoft.com/library/ms646281
    WM_KEYUP: 0x101,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup
    WM_SYSKEYUP: 0x105,
    // https://msdn.microsoft.com/library/ms645616
    WM_MOUSEMOVE: 0x200,
    // https://msdn.microsoft.com/library/ms645608
    WM_LBUTTONUP: 0x202,
    // https://msdn.microsoft.com/library/ms646243
    WM_RBUTTONUP: 0x205,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-mousewheel
    WM_MOUSEWHEEL: 0x20A,

    // https://msdn.microsoft.com/library/aa363480
    WM_DEVICECHANGE: 0x219,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-user
    WM_USER: 0x400,
    // https://docs.microsoft.com/windows/desktop/dataxchg/wm-copydata
    WM_COPYDATA: 0x4a,

    // Registered messages
    WM_SHELLHOOK: "SHELLHOOK",

    HWND_BROADCAST: 0xffff,

    // https://docs.microsoft.com/windows/desktop/winmsg/wm-inputlangchange
    WM_INPUTLANGCHANGE: 0x51,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange
    WM_SETTINGCHANGE: 0x1a,
    // https://docs.microsoft.com/windows/desktop/hidpi/wm-dpichanged
    WM_DPICHANGED: 0x02E0,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-syscolorchange
    WM_SYSCOLORCHANGE: 0x15,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-displaychange
    WM_DISPLAYCHANGE: 0x7e,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-themechanged
    WM_THEMECHANGED: 0x31a,


    // https://msdn.microsoft.com/library/aa363205
    DBT_DEVNODES_CHANGED: 0x7,
    DBT_DEVICEARRIVAL: 0x8000,
    DBT_DEVICEREMOVEPENDING: 0x8003,
    DBT_DEVICEREMOVECOMPLETE: 0x8004,
    DBT_DEVTYP_VOLUME: 0x2,

    // https://msdn.microsoft.com/library/dd375731
    virtualKeyCodes: {
        VK_BACK: 0x08,
        VK_TAB: 0x09,
        VK_RETURN: 0x0D,
        VK_SHIFT: 0x10,
        VK_CONTROL: 0x11,
        VK_MENU: 0x12, // alt key
        VK_ESCAPE: 0x1B,
        VK_SPACE: 0x20,
        VK_PAGEUP: 0x21, // VK_PRIOR
        VK_PAGEDOWN: 0x22, // VK_NEXT
        VK_END: 0x23,
        VK_HOME: 0x24,
        VK_LEFT: 0x25,
        VK_UP: 0x26,
        VK_RIGHT: 0x27,
        VK_DOWN: 0x28,
        VK_SELECT: 0x29,
        VK_PRINT: 0x2A,
        VK_EXECUTE: 0x2B,
        VK_SNAPSHOT: 0x2C,
        VK_INSERT: 0x2D,
        VK_DELETE: 0x2E,
        VK_HELP: 0x2F,
        VK_LWIN: 0x5B,
        VK_RWIN: 0x5C,
        VK_APPS: 0x5D,
        VK_F1: 0x70,
        VK_F2: 0x71,
        VK_F3: 0x72,
        VK_F4: 0x73,
        VK_F5: 0x74,
        VK_F6: 0x75,
        VK_F7: 0x76,
        VK_F8: 0x77,
        VK_F9: 0x78,
        VK_F10: 0x79,
        VK_F11: 0x7A,
        VK_F12: 0x7B,
        VK_F13: 0x7C,
        VK_F14: 0x7D,
        VK_F15: 0x7E,
        VK_F16: 0x7F,
        VK_F17: 0x80,
        VK_F18: 0x81,
        VK_F19: 0x82,
        VK_F20: 0x83,
        VK_F21: 0x84,
        VK_F22: 0x85,
        VK_F23: 0x86,
        VK_F24: 0x87,
        VK_NUMLOCK: 0x90,
        VK_SCROLL: 0x91
    },

    LLKHF_EXTENDED:  0x01,
    LLKHF_INJECTED:  0x10,
    LLKHF_ALTDOWN:   0x20,
    LLKHF_UP:        0x80,
    LLMHF_INJECTED:  0x01,

    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registershellhookwindow
    HSHELL_WINDOWCREATED: 1,
    HSHELL_WINDOWDESTROYED: 2,
    HSHELL_WINDOWACTIVATED: 4,
    HSHELL_RUDEAPPACTIVATED: 0x8004,

    // https://msdn.microsoft.com/library/ms646306
    MAPVK_VK_TO_CHAR: 2,

    // The AccessibilityTemp values; https://msdn.microsoft.com/library/windows/desktop/bb879984.aspx
    disableAT: 2,
    enableAT: 3,

    MONITOR_DEFAULTTOPRIMARY: 1,
    CCHDEVICENAME: 32,
    QDC_ONLY_ACTIVE_PATHS: 2,
    // https://msdn.microsoft.com/en-us/library/windows/hardware/ff554003.aspx
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED: 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED: 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL: 0x80000000,

    // https://msdn.microsoft.com/en-us/library/296az74e.aspx
    UINT_MAX: 0xffffffff,

    // https://msdn.microsoft.com/library/ms724947
    SpiFlags: {
        SPIF_UPDATEINIFILE: 0x1,
        SPIF_SENDCHANGE: 0x2
    },

    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics
    SM_CXSCREEN: 0,
    SM_CYSCREEN: 1,

    SM_SWAPBUTTON: 23
};

fluid.each(windows.API_constants.returnCodesLookup, function (value, key) {
    windows.API_constants.returnCodes[value] = +key;
});

/*
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx
 * TH32CS_SNAPALL
 */
var TH32CS_SNAPHEAPLIST = 0x00000001;
var TH32CS_SNAPMODULE = 0x00000008;
var TH32CS_SNAPPROCESS = 0x00000002;
var TH32CS_SNAPTHREAD = 0x00000004;

var TH32CS_SNAPALL = TH32CS_SNAPHEAPLIST | TH32CS_SNAPMODULE |
    TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD;

windows.API_constants.TH32CS_SNAPALL = TH32CS_SNAPALL;
windows.API_constants.TH32CS_SNAPPROCESS = TH32CS_SNAPPROCESS;

var c = windows.API_constants;

// https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839%28v=vs.85%29.aspx
windows.PROCESSENTRY32 = new Struct([
    [t.DWORD, "dwSize"],
    [t.DWORD, "cntUsage"],
    [t.DWORD, "th32ProcessID"],
    [t.ULONG_PTR, "th32DefaultHeapID"],
    [t.DWORD, "th32ModuleID"],
    [t.DWORD, "cntThreads"],
    [t.DWORD, "th32ParentProcessID"],
    [t.LONG, "pcPriClassBase"],
    [t.DWORD, "dwFlags"],
    // TODO: This needs refactoring to adopt new type t.TCHAR instead of an array of
    // chars.
    [arrayType("char", c.MAX_PATH), "szExeFile"]
]);

// https://msdn.microsoft.com/library/ms685996
windows.SERVICE_STATUS = new Struct([
    [t.DWORD, "dwServiceType"],
    [t.DWORD, "dwCurrentState"],
    [t.DWORD, "dwControlsAccepted"],
    [t.DWORD, "dwWin32ExitCode"],
    [t.DWORD, "dwServiceSpecificExitCode"],
    [t.DWORD, "dwCheckPoint"],
    [t.DWORD, "dwWaitHint"]
]);


// http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
windows.HighContrast = new Struct({
    "cbSize": "uint32",
    "dwFlags": "int32",
    "lpszDefaultScheme": "pointer"
});
windows.highContrastPointer = ref.refType(windows.HighContrast);

// http://msdn.microsoft.com/en-us/library/windows/desktop/dd145037(v=vs.85).aspx
windows.LogFont = new Struct([
    ["int32",  "lfHeight"],
    ["int32",  "lfWidth"],
    ["int32",  "lfEscapement"],
    ["int32",  "lfOrientation"],
    ["int32",  "lfWeight"],
    ["uchar",  "lfItalic"],
    ["uchar",  "lfUnderline"],
    ["uchar",  "lfStrikeOut"],
    ["uchar",  "lfCharSet"],
    ["uchar",  "lfOutPrecision"],
    ["uchar",  "lfClipPrecision"],
    ["uchar",  "lfQuality"],
    ["uchar",  "lfPitchAndFamily"],
    [arrayType(t.TCHAR, c.MAX_NAME), "lfFaceName"]
]);
windows.logFontPointer = ref.refType(windows.LogFont);

// http://msdn.microsoft.com/en-us/library/windows/desktop/ff729175(v=vs.85).aspx
windows.NonClientMetrics = new Struct([
    ["uint32",   "cbSize"],
    ["int32",    "iBorderWidth"],
    ["int32",    "iScrollWidth"],
    ["int32",    "iScrollHeight"],
    ["int32",    "iCaptionWidth"],
    ["int32",    "iCaptionHeight"],
    [windows.LogFont,  "lfCaptionFont"],
    ["int32",    "iSmCaptionWidth"],
    ["int32",    "iSmCaptionHeight"],
    [windows.LogFont,  "lfSmCaptionFont"],
    ["int32",    "iMenuWidth"],
    ["int32",    "iMenuHeight"],
    [windows.LogFont,  "lfMenuFont"],
    [windows.LogFont,  "lfStatusFont"],
    [windows.LogFont,  "lfMessageFont"],
    ["int32", "iPaddedBorderWidth"]
]);
windows.nonClientMetricsPointer = ref.refType(windows.NonClientMetrics);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd373652(v=vs.85).aspx
windows.StickyKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"]
]);
windows.StickyKeysPointer = ref.refType(windows.StickyKeys);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd318079(v=vs.85).aspx
windows.FilterKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"],
    ["uint32",   "iWaitMSec"],
    ["uint32",   "iDelayMSec"],
    ["uint32",   "iRepeatMSec"],
    ["uint32",   "iBounceMSec"]
]);
windows.FilterKeysPointer = ref.refType(windows.FilterKeys);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd373593(v=vs.85).aspx
windows.MouseKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"],
    ["uint32",   "iMaxSpeed"],
    ["uint32",   "iTimeToMaxSpeed"],
    ["uint32",   "iCtrlSpeed"],
    ["uint32",   "dwReserved1"],
    ["uint32",   "dwReserved2"]
]);
windows.MouseKeysPointer = ref.refType(windows.MouseKeys);

// TODO Define additional structures used in calls to SystemParametersInfo here.

// https://msdn.microsoft.com/library/ms644967
windows.KBDLLHookStruct = new Struct([
    [t.DWORD,     "vkCode"],
    [t.DWORD,     "scanCode"],
    [t.DWORD,     "flags"],
    [t.DWORD,     "time"],
    [t.ULONG_PTR, "dwExtraInfo"]
]);
windows.KBDLLHookStructPointer = ref.refType(windows.KBDLLHookStruct);

// https://msdn.microsoft.com/library/ms644970
windows.MSDLLHookStruct = new Struct([
    [t.LONG,      "ptX"],
    [t.LONG,      "ptY"],
    [t.DWORD,     "mouseData"],
    [t.DWORD,     "flags"],
    [t.DWORD,     "time"],
    [t.ULONG_PTR, "dwExtraInfo"]
]);
windows.MSDLLHookStructPointer = ref.refType(windows.MSDLLHookStruct);

// https://msdn.microsoft.com/library/ms633576
windows.WNDCLASSW = new Struct([
    [t.UINT,      "style"],
    ["void*",     "lpfnWndProc"],
    [t.INT,       "cbClsExtra"],
    [t.INT,       "cbWndExtra"],
    [t.HANDLE,    "hInstance"],
    [t.HANDLE,    "hIcon"],
    [t.HANDLE,    "hCursor"],
    [t.HANDLE,    "hbrBackground"],
    [t.PVOID,     "lpszMenuName"],
    ["char*",     "lpszClassName"]
]);

// https://msdn.microsoft.com/library/aa363246
windows.DEV_BROADCAST_HDR = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"]
]);

// https://msdn.microsoft.com/library/aa363249
windows.DEV_BROADCAST_VOLUME = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"],
    [t.DWORD, "unitMask"],
    [t.DWORD, "flags"]
]);

// https://msdn.microsoft.com/library/dd162897
windows.RECT = new Struct([
    [t.LONG, "left"],
    [t.LONG, "top"],
    [t.LONG, "right"],
    [t.LONG, "bottom"]
]);

// https://msdn.microsoft.com/library/dd162805
windows.POINT = new Struct([
    [t.LONG, "x"],
    [t.LONG, "y"]
]);

// https://docs.microsoft.com/windows/desktop/api/Winuser/ns-winuser-tagcopydatastruct
windows.COPYDATASTRUCT = new Struct([
    ["int", "dwData"],
    [t.DWORD, "cbData"],
    ["void*", "lpData"]
]);

/**
 * Contains flags used in the "dwFlags" field of various structures
 * that are used in calls to the SystemParametersInfo function.
 */
windows.flagConstants = {
    // HIGHCONTRAST flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
    "HCF_AVAILABLE":       0x00000002,
    "HCF_CONFIRMHOTKEY":   0x00000008,
    "HCF_HIGHCONTRASTON":  0x00000001,
    "HCF_HOTKEYACTIVE":    0x00000004,
    "HCF_HOTKEYAVAILABLE": 0x00000040,
    "HCF_HOTKEYSOUND":     0x00000010,
    "HCF_INDICATOR":       0x00000020,

    // STICKYKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd373652%28v=vs.85%29.aspx
    "SKF_AUDIBLEFEEDBACK": 0x00000040,
    "SKF_AVAILABLE":       0x00000002,
    "SKF_HOTKEYACTIVE":    0x00000004,
    "SKF_STICKYKEYSON":    0x00000001,

    // FILTERKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318079%28v=vs.85%29.aspx
    "FKF_AVAILABLE":       0x00000002,
    "FKF_CLICKON":         0x00000040,
    "FKF_CONFIRMHOTKEY":   0x00000008,
    "FKF_FILTERKEYSON":    0x00000001,
    "FKF_HOTKEYACTIVE":    0x00000004,
    "FKF_HOTKEYSOUND":     0x00000010,
    "FKF_INDICATOR":       0x00000020,

    // MOUSEKEYS flags
    // https://msdn.microsoft.com/en-us/library/windows/desktop/dd373593(v=vs.85).aspx
    "MKF_AVAILABLE":       0x00000002,
    "MKF_CONFIRMHOTKEY":   0x00000008,
    "MKF_HOTKEYACTIVE":    0x00000004,
    "MKF_HOTKEYSOUND":     0x00000010,
    "MKF_INDICATOR":       0x00000020,
    "MKF_LEFTBUTTONDOWN":  0x01000000,
    "MKF_LEFTBUTTONSEL":   0x10000000,
    "MKF_MODIFIERS":       0x00000040,
    "MKF_MOUSEKEYSON":     0x00000001,
    "MKF_MOUSEMODE":       0x80000000,
    "MKF_REPLACENUMBERS":  0x00000080,
    "MKF_RIGHTBUTTONDOWN": 0x02000000,
    "MKF_RIGHTBUTTONSEL":  0x20000000,

    // FORMATMESSAGE flags
    // https://docs.microsoft.com/es-es/windows/desktop/Debug/retrieving-the-last-error-code
    "FORMAT_MESSAGE_ALLOCATE_BUFFER":   0x00000100,
    "FORMAT_MESSAGE_FROM_SYSTEM":       0x00001000,
    "FORMAT_MESSAGE_IGNORE_INSERTS":    0x00000200,

    // LANGUAGE Identifiers flags
    "LANG_NEUTRAL": 0x00,
    "SUBLANG_DEFAULT": 0x01

    // TODO Define additional flags used across various structures here.
};

// ACCESS TYPES
// https://docs.microsoft.com/en-us/windows/desktop/secauthz/standard-access-rights
windows.accessTypes = {
    "DELETE":                     0x00010000,
    "READ_CONTROL":               0x00020000,
    "WRITE_DAC":                  0x00040000,
    "WRITE_OWNER":                0x00080000,
    "SYNCHRONIZE":                0x00100000,

    "STANDARD_RIGHTS_REQUIRED":   0x000F0000,

    "STANDARD_RIGHTS_READ":       0x00020000,
    "STANDARD_RIGHTS_WRITE":      0x00020000,
    "STANDARD_RIGHTS_EXECUTE":    0x00020000,
    "STANDARD_RIGHTS_ALL":        0x001F0000,
    "SPECIFIC_RIGHTS_ALL":        0x0000FFFF,

    "GENERIC_READ":               0x80000000,
    "GENERIC_WRITE":              0x40000000,
    "GENERIC_EXECUTE":            0x20000000,
    "GENERIC_ALL":                0x10000000
};

// _ACCESS_MODE enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_access_mode
windows.accessMode = {
    "NOT_USED_ACCESS":      0,
    "GRANT_ACCESS":         1,
    "SET_ACCESS":           2,
    "DENY_ACCESS":          3,
    "REVOKE_ACCESS":        4,
    "SET_AUDIT_SUCCESS":    5,
    "SET_AUDIT_FAILURE":    6
};

// _TRUSTEE_FORM enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_trustee_form
windows.trusteeForm = {
    "TRUSTEE_IS_SID":              0,
    "TRUSTEE_IS_NAME":             1,
    "TRUSTEE_BAD_FORM":            2,
    "TRUSTEE_IS_OBJECTS_AND_SID":  3,
    "TRUSTEE_IS_OBJECTS_AND_NAME": 4
};

// _TRUSTEE_TYPE enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_trustee_type
windows.trusteeType = {
    "TRUSTEE_IS_UNKNOWN":          0,
    "TRUSTEE_IS_USER":             1,
    "TRUSTEE_IS_GROUP":            2,
    "TRUSTEE_IS_DOMAIN":           3,
    "TRUSTEE_IS_ALIAS":            4,
    "TRUSTEE_IS_WELL_KNOWN_GROUP": 5,
    "TRUSTEE_IS_DELETED":          6,
    "TRUSTEE_IS_INVALID":          7,
    "TRUSTEE_IS_COMPUTER":         8
};

// https://docs.microsoft.com/en-us/windows/desktop/secauthz/security-information
windows.securityInformation = {
    "OWNER_SECURITY_INFORMATION":               0x00000001,
    "GROUP_SECURITY_INFORMATION":               0x00000002,
    "DACL_SECURITY_INFORMATION":                0x00000004,
    "SACL_SECURITY_INFORMATION":                0x00000008,
    "LABEL_SECURITY_INFORMATION":               0x00000010,
    "ATTRIBUTE_SECURITY_INFORMATION":           0x00000020,
    "SCOPE_SECURITY_INFORMATION":               0x00000040,
    "PROCESS_TRUST_LABEL_SECURITY_INFORMATION": 0x00000080,
    "ACCESS_FILTER_SECURITY_INFORMATION":       0x00000100,
    "BACKUP_SECURITY_INFORMATION":              0x00010000,

    "PROTECTED_DACL_SECURITY_INFORMATION":      0x80000000,
    "PROTECTED_SACL_SECURITY_INFORMATION":      0x40000000,
    "UNPROTECTED_DACL_SECURITY_INFORMATION":    0x20000000,
    "UNPROTECTED_SACL_SECURITY_INFORMATION":    0x10000000
};

// Inheritance flags for primary ACE object
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ns-accctrl-_explicit_access_a
windows.inheritanceFlags = {
    "NO_INHERITANCE":                       0x0,
    "SUB_OBJECTS_ONLY_INHERIT":             0x1,
    "SUB_CONTAINERS_ONLY_INHERIT":          0x2,
    "SUB_CONTAINERS_AND_OBJECTS_INHERIT":   0x3,
    "INHERIT_NO_PROPAGATE":                 0x4,
    "INHERIT_ONLY":                         0x8
};

/**
 * The MAKELONG win32 macro. Combines two 16-bit numbers into a 32-bit unsigned number.
 *
 * https://msdn.microsoft.com/library/ms632660
 *
 * @param {Number} low The low-order word of the new value.
 * @param {Number} high The high-order word of the new value.
 * @return {Number} A 32-bit number consisting of the two 16-bit numbers, low and high.
 */
windows.makeLong = function (low, high) {
    return ((low & 0xffff) | ((high & 0xffff) << 16)) >>> 0;
};

/**
 * The LOWORD win32 macro. Gets the low 16-bit number from a 32-bit number.
 *
 * https://msdn.microsoft.com/library/ms632659
 *
 * @param {Number} value The 32-bit number from which the low 16 bits are retrieved.
 * @return {Number} A number consisting of the lower 16 bits of value.
 */
windows.loWord = function (value) {
    return value & 0xffff;
};

/**
 * The HIWORD win32 macro. Gets the high 16-bit number from a 32-bit number.
 *
 * https://msdn.microsoft.com/library/ms632657
 *
 * @param {Number} value The 32-bit number from which the high 16 bits are retrieved.
 * @return {Number} A number consisting of the higher 16 bits of value.
 */
windows.hiWord = function (value) {
    return (value >> 16) & 0xffff;
};

/**
 * Contains structures that are used in calls to the SystemParametersInfo function,
 * accessible by their names. Used to dynamically instantiate the appropriate structure.
 */
windows.structures = {
    "HIGHCONTRAST":     windows.HighContrast,
    "NONCLIENTMETRICS": windows.NonClientMetrics,
    "LOGFONT":          windows.LogFont,
    "STICKYKEYS":       windows.StickyKeys,
    "FILTERKEYS":       windows.FilterKeys,
    "MOUSEKEYS":        windows.MouseKeys
    // TODO Add additional structures that we need to instantiate here.
};

gpii.pointerToHex = function (pointer, count) {
    var togo = "";
    for (var i = 0; i < count; ++i) {
        var nbyte = pointer.readUInt8(i);
        togo += (nbyte < 16 ? "0" : "") + nbyte.toString(16);
        if (i !== count - 1) {
            togo += " ";
        }
    }
    return togo;
};

// Slow but short method to parse very forgiving hex streams - any non-hex characters will be ignored. Digits
// forming a single byte must be adjacent
gpii.hexToPointer = function (hexString) {
    var buffer = [];
    var i;
    for (i = 0; i < hexString.length; ++i) {
        var c = hexString.charAt(i);
        var digit = parseInt(c, 16);
        if (!isNaN(digit)) {
            buffer.push(digit);
        }
    }
    if ((buffer.length % 2) === 1) {
        fluid.fail("Odd number of hex digits in buffer " + hexString);
    }

    var togo = new Buffer(buffer.length / 2);

    for (i = 0; i < buffer.length; i += 2) {
        togo.writeUInt8(buffer[i] * 16 + buffer[i + 1], i / 2);
    }
    return {
        pointer: togo,
        length: buffer.length / 2
    };
};

windows.convertReturnCode = function (code) {
    return "Return code " + code + ": " + c.returnCodesLookup[code];
};

windows.checkReturnCode = function (code) {
    if (code !== 0) {
        fluid.fail(windows.convertReturnCode(code));
    }
};

windows.toWideChar = function (string) {
    var stringBuffer = new Buffer(string);

    var chars = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, NULL, 0);

    var buffer = new Buffer(chars * 2 + 2); // 2 extra bytes for the null character

    var chars2 = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, buffer, chars);
    if (chars2 !== chars) {
        fluid.fail("Expected to write " + chars + " characters, only wrote " + chars2);
    }

    buffer.writeInt16BE(0, chars * 2);  // add the null character at the end
    return {
        pointer: buffer,
        length: chars * 2 + 2
    };
};

windows.fromWideChar = function (buffer) {
    buffer = ref.reinterpretUntilZeros(buffer, 2, 0);

    var bytes = windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, NULL, 0, NULL, NULL);

    var convertBuffer = new Buffer(bytes);

    windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, convertBuffer, bytes, NULL, NULL);

    return convertBuffer.toString();
};

/**
 * Create a buffer containing the wide-character representation of string.
 * Used to convert strings to a buffer usable by the Windows API.
 *
 * @param {String} string The original string.
 * @return {Buffer} The buffer containing the UTF-16 string.
 */
windows.stringToWideChar = function (string) {
    return new Buffer(string + "\u0000", "ucs2"); // add null at the end
};

/**
 * Reads a buffer containing the wide-character representation of string.
 * Used to convert strings from a buffer used by the Windows API, into a node UTF-8 string.
 *
 * @param {Buffer} buffer The buffer containing the UTF-16 string.
 * @return {String} The UTF-8 node string.
 */
windows.stringFromWideChar = function (buffer) {
    return ref.reinterpretUntilZeros(buffer, 2, 0).toString("ucs2");
};

/**
 * Convert an array of strings into a wide-character C-style array of the array elements.
 * That is, the items of the array seperated by null and terminated by double null.
 *
 * @param {Array<String>} array The array.
 * @return {Buffer} The buffer containing the UTF-16 string array.
 */
windows.stringToWideCharArray = function (array) {
    // A null at the end of each item.
    var string = fluid.makeArray(array).join("\u0000") + "\u0000";
    // Also add the double-null at the end
    return new Buffer(string + "\u0000\u0000", "ucs2");
};


/**
 * Convert a buffer containing an array of wide-char strings, to an array of strings.
 *
 * The input array is a C style string array, where the values are separated by null characters. The array is terminated
 * by an additional 2 null characters.
 *
 * @param {Buffer} buffer The buffer to convert.
 * @return {Array<String>} An array of string.
 */
windows.stringFromWideCharArray = function (buffer) {
    var togo = [];
    var offset = 0;
    var current;
    do {
        current = ref.reinterpretUntilZeros(buffer, 2, offset);
        if (current.length) {
            togo.push(current.toString("ucs2"));
            offset += current.length + 2; // Extra 2 bytes is to skip the (wide) null separator
        }
    } while (current.length > 0);

    return togo;
};

/**
 * Ensures the bytes of a buffer begin on an even address.
 *
 * Unicode registry functions need the string pointers aligned on 16bit boundary.
 *
 * @param {Buffer} buffer The buffer to align.
 * @return {Buffer} The original buffer, or a copy.
 */
windows.ensureAlignment = function (buffer) {
    if (ref.address(buffer) & 1) { // not aligned
        var alignedBuffer = new Buffer(buffer.length + 1);

        if (ref.address(alignedBuffer) & 1) { // the new buffer is not aligned as well
            buffer.copy(alignedBuffer, 1);
            return alignedBuffer.slice(1);

        } else { // the new buffer is OK
            buffer.copy(alignedBuffer);
            return alignedBuffer.slice(0, alignedBuffer.length - 1);
        }
    }

    return buffer;
};

/**
 * If a structure is not already defined, creates it by using the structure template in the payload.
 * If such is not provided, throws an exception.
 *
 * @param {Object} payload Settings handler payload.
 */
windows.defineStruct = function (payload) {
    if (payload.options.pvParam.type === "struct" && !windows.structures[payload.options.pvParam.name]) {
        if (!payload.options.pvParam.template) {
            throw "Cannot create structure " + payload.options.pvParam.name + " - payload.options.pvParam.template not found!";
        }

        windows.structures[payload.options.pvParam.name] = new Struct(payload.options.pvParam.template);
    }
};

/**
 * Creates an empty structure with a given name. It should be registered in the
 * <code>windows.structures</code> map with that name. If the structure has a <code>cbSize</code>
 * member, the function sets that member to the size of the structure using <code>ffi.sizeof</code>.
 *
 * @param {String} structName The name of the structure to create. Should be registered in the
 *                 <code>windows.structures</code> map.
 * @return {Object} The newly created structure with its <code>cbSize</code> member initialized.
 */
windows.createEmptyStructure = function (structName) {
    var struct = new windows.structures[structName]();

    if (struct.cbSize !== undefined) {
        struct.cbSize = windows.structures[structName].size;
        // TODO: This needs to be dropped. It's duplicated in SpiSettingsHandler too,
        // creating a poison dependency. It should be in the struct definition or
        // let it pass because it only applies on Windows Server 2003 and
        // Windows XP/2000
        if (structName === "NONCLIENTMETRICS" && os.release() < "6") {
            struct.cbSize -= 4; // do not unclude NONCLIENTMETRICS.iPaddedBorderWidth
        }
    }

    return struct;
};

/**
 * Takes an array of flag names, applies binary OR among them and returns the result.
 * Used to supply the "dwFlags" argument of some structures.
 *
 * @param {Array} flagNamesArray An array of flag names, which must be in allFlags.
 * @param {Object} allFlags [optional] An object of all possible flags and their value. Defaults to windows.flagConstants.
 * @param {String} op [optional] The operation, either "or" (default) or "and".
 * @return {Number} The values of the array items OR'd together.
 */
windows.combineFlags = function (flagNamesArray, allFlags, op) {
    allFlags = allFlags || windows.flagConstants;
    var or = op !== "and" && op !== "&";

    var combine = or
        ? function (left, right) { return left | right; }
        : function (left, right) { return left & right; };

    var combinedFlags = or
        ? 0 : 1;

    if (!fluid.isArrayable(flagNamesArray)) {
        fluid.log("GPII Windows SpiSettingsHandler combineFlags: array expected!");
        return 0;
    }
    for (var index in flagNamesArray) {
        combinedFlags = combine(combinedFlags, allFlags[flagNamesArray[index]]);
    }
    return combinedFlags;
};

/**
 * Resolves a list of flags into the numeric value. Flags can either be a string, with the delimiter of either
 * "|" or "&" specifying the operation:
 *
 * Ex: "F1 | F2 | F3" || "F1 & F2 & F3".
 *
 * Or an array of flag strings (in which case the operation is binary OR).
 *
 * Ex: ["F1", "F2", "F3"].
 *
 * The value of each possible flag is specified in allFlags.
 *
 * @param {String|Array} flags The list of flags to resolve.
 * @param {Object} allFlags An associative object of every flag. In which keys are flag names and values
 *  are flag values.
 * @return {Number} The numeric value of flags.
 */
windows.resolveFlags = function (flags, allFlags) {
    var togo = 0;

    var op = "or";
    // Split a string into an array.
    if (typeof(flags) === "string") {
        var or = flags.indexOf("&") < 0;
        op = or ? "or" : "and";
        flags = flags.split(/ *[&|,]+ */);
    }
    if (fluid.isArrayable(flags)) {
        togo = gpii.windows.combineFlags(flags, allFlags, op);
    } else {
        fluid.fail("windows.resolveFlags was passed an unknown type of flags");
    }

    return togo;
};

/**
 * Gets the value of a given flag name.
 *
 * @param {String} flagName The name of the flag whose value we need.
 * @return {Number} The value of the flag.
 */
windows.getFlagValue = function (flagName) {
    var flagValue = windows.flagConstants[flagName];
    if (flagValue === undefined) {
        fluid.fail("Unknown flag name " + flagName);
    }
    return flagValue;
};

/**
 * Accesses consecutive fields of an object.
 *
 * @param {Object} object The object to be accessed.
 * @param {String} path A string containing the consecutive field names, separated by '.'
 * @param {Object} setValue <optional> A new value to be stored in the field.
 * @return {Object} The value stored in the field.
 */
windows.resolvePath = function (object, path, setValue) {
    var flagsIndex = path.indexOf("dwFlags");
    if (flagsIndex !== -1) {
        var path1 = path.substr(0, flagsIndex - 1);
        var flagName = path.substr(path.lastIndexOf(".") + 1);
        return windows.accessFlag(fluid.get(object, path1), flagName, setValue);

    } else {
        if (setValue !== undefined) {
            if (typeof setValue === "string") {
                setValue = windows.stringToWideChar(setValue);
            }
            fluid.set(object, path, setValue);
        }

        var value = fluid.get(object, path);
        return Buffer.isBuffer(value) ? windows.stringFromWideChar(value) : value;
    }
};

/**
 * Accesses a single flag in a flags field of an object.
 *
 * @param {Object} object The object to be accessed.
 * @param {String} flagName A string containing the flag name according to the Windows API.
 * @param {Object} setValue <optional> A new value for the flag.
 * @return {Object} The value of the flag.
 */
windows.accessFlag = function (object, flagName, setValue) {
    var flagValue = windows.getFlagValue(flagName);

    if (setValue !== undefined) {
        setValue = Boolean(setValue);
        // The '>>>' operator is needed to convert the number back to an unsigned 32-bit int.
        if (setValue) {
            object.dwFlags = (object.dwFlags | flagValue) >>> 0;
        } else {
            object.dwFlags = (object.dwFlags & ~flagValue) >>> 0;
        }
    }

    return Boolean(object.dwFlags & flagValue);
};

/**
 * Converts an array to a buffer.
 *
 * @param {Array} array The array to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Buffer} A buffer representing the raw memory allocated for the array.
 */
windows.arrayToBuffer = function (array, type) {
    var size = ref.coerceType(windows.types[type]).size;
    var buf = new Buffer(array.length * size);

    for (var i = 0; i < array.length; ++i) {
        ref.set(buf, i * size, array[i], windows.types[type]);
    }

    return buf;
};

/**
 * Converts a buffer to an array.
 *
 * @param {Buffer} buffer The buffer to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Array} An array containing the values stored in the buffer.
 */
windows.bufferToArray = function (buffer, type) {
    var array = [];
    var size = ref.coerceType(windows.types[type]).size;

    for (var i = 0; i < buffer.length / size; ++i) {
        array[i] = ref.get(buffer, i * size, windows.types[type]);
    }

    return array;
};

/**
 * Enumerates all top-level windows on the desktop, or all child windows (and their descendants) of a given window,
 * invoking the callback for each one.
 *
 * @param {Number} hwndParent [optional] The handle of the window whose child windows are to be enumerated.
 * @param {Function} callback Called for each Window, returning a value other than undefined to break the enumeration.
 * @return {Mixed} The last return value of callback.
 */
windows.enumerateWindows = function (hwndParent, callback) {
    if (!callback && typeof(hwndParent) === "function") {
        callback = hwndParent;
        hwndParent = null;
    }

    var result;
    // Suppress "no-unused-vars" - lparam argument is required for EnumWindowsProc.
    // eslint-disable-next-line no-unused-vars
    var proc = gpii.windows.EnumWindowsProc(function (hwnd, lparam) {
        result = callback(hwnd);
        return result === undefined;
    });

    if (hwndParent) {
        gpii.windows.user32.EnumChildWindows(hwndParent, proc, 0);
    } else {
        gpii.windows.user32.EnumWindows(proc, 0);
    }

    return result;
};

/**
 * Determines whether this process is running under WoW64. That is, 32-bit node on 64-bit Windows.
 *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa384249(v=vs.85).aspx
 *
 * @return {Boolean} true if this process is 32-bit, and the OS is 64-bit otherwise false.
 */
windows.isWow64 = function () {
    var ptr = ref.alloc(windows.types.DWORD);
    gpii.windows.kernel32.IsWow64Process(-1, ptr);
    return !!ptr.deref();
};

/**
 * Get the process ID that owns the given window.
 *
 * @param {Number} hwnd The window handle.
 * @return {Number} The process ID.
 */
windows.getWindowProcessId = function (hwnd) {
    var pid = null;
    if (hwnd) {
        var buf = ref.alloc(windows.types.DWORD);
        windows.user32.GetWindowThreadProcessId(hwnd, buf);
        pid = buf.deref();
    }

    return pid;
};

/**
 * Returns a given window's rectangle.
 *
 * @param {Number} hwnd The window handle.
 * @return {Object} Contains the left, top, right, bottom, width, and height values of the window.
 */
windows.getWindowRect = function (hwnd) {
    var rect = new windows.RECT();
    var success = windows.user32.GetWindowRect(hwnd, rect.ref());
    var result;
    if (success) {
        result = {
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom
        };
        result.width = result.right - result.left;
        result.height = result.bottom - result.top;
    }
    return result;
};

/**
 * Gets the top-level window that's a parent of a given window.
 *
 * @param {Number} hwnd Handle of the child window.
 * @return {Number} Handle of the top-level window that's a parent of a given window.
 */
windows.getTopParent = function (hwnd) {
    var parent = hwnd;
    var togo;
    while (parent !== 0) {
        togo = parent;
        parent = windows.user32.GetParent(parent);
    }

    return togo;
};

/**
 * Finds all windows with the given class name.
 *
 * @param {String|Array<String>} className The window class, or an array describing the path to a class (starting at the
 * top-level parent), used to find child windows.
 * @param {Number} parent [optional] The parent handle from which the search begins.
 * @return {Array<String>} The window handles of the matching windows.
 */
windows.findWindows = function (className, parent) {
    var path = fluid.makeArray(className);

    var windowClass = path.shift();

    var classBuffer = Buffer.alloc(0xff);
    classBuffer.ref().fill(0);

    // Get the window that has the specified class
    var matches = [];
    windows.enumerateWindows(parent, function (hwndFound) {
        if (windows.user32.GetClassNameW(hwndFound, classBuffer, classBuffer.length)) {
            var cls = windows.stringFromWideChar(classBuffer);
            if (cls === windowClass) {
                if (path.length > 0) {
                    var child = windows.findWindows(path, hwndFound);
                    matches.push.apply(matches, child);
                } else {
                    matches.push(hwndFound);
                }
            }
        }
    });

    return matches;
};

/**
 * Gets a localised resource string from an executable.
 *
 * @param {String} dll The dll name that contains the string.
 * @param {Number} resourceID The numeric resource identifier of the string.
 * @param {String} defaultValue [optional] The string to return if no string was found.
 * @return {String} The localised string, or defaultValue.
 */
windows.getResourceString = function (dll, resourceID, defaultValue) {
    // "@filename,-resId"
    return fluid.firstDefined(windows.getIndirectString("@" + dll + ",-" + resourceID), defaultValue);
};

/**
 * Wrapper for SHLoadIndirectString:
 * "Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins
 * with the '@' symbol)."
 *
 * This function accepts a string in the form of "@dllname,-resourceID". This will load the resource string identified
 * by the numeric resourceID, from the specified dll. Strings that do not begin with "@" will be returned as-is.
 *
 * See: https://docs.microsoft.com/en-gb/windows/desktop/api/shlwapi/nf-shlwapi-shloadindirectstring
 *
 * @param {String} indirectString A string in the form of "@dllname,-resourceID" (consult MSDN for other forms).
 * @return {String} The localised resource string which the indirectString resolves do, or undefined on error.
 */
windows.getIndirectString = function (indirectString) {
    var ret;
    if (indirectString.startsWith("@")) {
        var src = windows.stringToWideChar(indirectString);
        var buf = Buffer.alloc(0xfff);
        if (gpii.windows.shlwapi.SHLoadIndirectString(src, buf, buf.length, ref.NULL) === 0) {
            ret = gpii.windows.stringFromWideChar(buf);
        } else {
            ret = undefined;
        }
    } else {
        ret = indirectString;
    }

    return ret;
};

/**
 * Waits for a condition, by polling a given function. A promise is returned, resolving when the condition is met or
 * rejecting upon timeout. If the condition is already met, then the returned promise will be resolved.
 *
 * The function is called repeatedly (with a delay) until it returns a truthful value, or a period of time has elapsed.
 *
 * @param {Function} func The function to call which checks the condition.
 * @param {Object} [options] Options
 * @param {Number|Boolean|Object} options.conditionValue The value that the function will return to indicate the condition is met.
 *  This is compared using '===', but the default is to match any truthy value.
 * @param {Number} options.argument An argument to pass to the function.
 * @param {Number} options.timeout How long to wait (ms) before timing out, or null (default) for no timeout.
 * @param {Number} options.pollDelay The delay (ms) between each poll. 500ms by default.
 * @param {Boolean} options.dontReject If true, then resolve the promise with "timeout" instead of rejecting.
 * @param {Object} options.error The error object used when rejecting.
 * @return {Promise} Promise resolving when the condition is met, rejecting upon timeout.
 *
 * @todo A better place for this should be found/created, as it's not even specific to Windows.
 */
windows.waitForCondition = function (func, options) {
    var defaultOptions = {
        timeout: null,
        pollDelay: 500,
        dontReject: false
    };
    options = fluid.extend(defaultOptions, options);

    var promise = fluid.promise();
    var startTime = process.hrtime();

    var checkCondition = function () {
        // See if the condition has been met.
        var returnValue = func(options.argument);
        var conditionMet;
        if (options.conditionValue === undefined) {
            conditionMet = !!returnValue;
        } else {
            conditionMet = (returnValue === options.conditionValue);
        }

        if (conditionMet) {
            promise.resolve();
        } else {
            // Check the time.
            var timedout = false;
            if (typeof(options.timeout) === "number") {
                var hr = process.hrtime(startTime);
                // combine seconds + nanoseconds into milliseconds
                var timeTakenMs = (hr[0] * 1000) + (hr[1] / 1e6);

                if (timeTakenMs >= options.timeout) {
                    timedout = true;
                    if (options.dontReject) {
                        promise.resolve("timeout");
                    } else {
                        promise.reject(options.error);
                    }
                }
            }

            if (!timedout) {
                setTimeout(checkCondition, options.pollDelay);
            }
        }
    };

    checkCondition();
    return promise;
};

/**
 * Returns an Error containing the arguments.
 *
 * @param {String} message The message.
 * @param {String|Number} returnCode [optional] The return code of the function causing the error.
 * @param {String|Number} errorCode [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error.
 */
windows.win32error = function (message, returnCode, errorCode) {
    var err = new Error(windows.win32errorText(message, returnCode, errorCode));
    err.returnCode = returnCode;
    err.errorCode = errorCode;
    err.isError = true;
    return err;
};

/**
 * Creates an error message for a win32 error.
 *
 * @param {String} message The message.
 * @param {String|Number} returnCode [optional] The return code of the function causing the error.
 * @param {String|Number} errorCode [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error message.
 */
windows.win32errorText = function (message, returnCode, errorCode) {
    var text = "win32 error: " + message;
    text += (returnCode === undefined) ? "" : (" return:" + returnCode);
    text += " win32:" + (errorCode || windows.kernel32.GetLastError());
    return text;
};

/**
 * Copy of the macro to create a language identifier from a primary language identifier and
 * a sublanguage identifier.
 *
 * https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-makelangid
 *
 * @param {Number} p Primary language identifier.
 * @param {Number} s Sublanguage identifier.
 * @return {Number} A language identifier which is the combination of the primary language identifier,
 *  and the sublanguage identifier.
 */
windows.makeLangId = function (p, s) {
    var uintS = s >>> 0;
    var uintP = p >>> 0;

    return ((uintS << 10) | uintP);
};

/**
 * Get the last system error in human readable format.
 *
 * @param {Number} dw The system error code to be translated.
 * @return {String} A message with the string representation of the system error code.
 */
windows.translateLastError = function (dw) {
    var maxOutputBuf = 64 * 1024;
    var buffer = new Buffer(maxOutputBuf);

    var formatFlags =
        windows.flagConstants.FORMAT_MESSAGE_FROM_SYSTEM |
        windows.flagConstants.FORMAT_MESSAGE_IGNORE_INSERTS;
    var langId = windows.makeLangId(windows.flagConstants.LANG_NEUTRAL, windows.flagConstants.SUBLANG_DEFAULT);

    var formatRes = windows.kernel32.FormatMessageW(
        formatFlags,
        null,
        dw,
        langId,
        buffer,
        maxOutputBuf,
        null
    );

    if (formatRes === 0) {
        var errCode = windows.kernel32.GetLastError();
        fluid.fail("windows.translateLastError: Error translating system error code - '" + errCode + "'");
    }

    return windows.fromWideChar(buffer);
};

/**
 * Execute a command, ensuring it uses the native System32 directory instead of the 32-bit version.
 *
 * When running as a 32-bit process on a 64-bit OS, in order make sure the native version is executed the 64-bit
 * cmd.exe will be used to perform the invocation.
 *
 * @param {String} command The command to execute.
 * @param {Object} [options] The options for child_process.exec.
 * @param {function} [callback] Called when the process terminates.
 * @return {Object} Returns what child_process.exec returns.
 */
gpii.windows.nativeExec = function (command, options, callback) {
    var execOptions = fluid.extend({}, options);
    if (gpii.windows.isWow64()) {
        execOptions.shell = process.env.SYSTEMROOT + "\\Sysnative\\cmd.exe";
    }
    return child_process.exec(command, execOptions, callback);
};

exports.windows = windows;
