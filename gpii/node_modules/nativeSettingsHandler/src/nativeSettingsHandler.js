/*
 * Windows Native Settings Handler
 *
 * Deals with individual settings that are only accessible throught isolated
 * API calls.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    gpii = fluid.registerNamespace("gpii"),
    windows = fluid.registerNamespace("gpii.windows");

require("../../WindowsUtilities/WindowsUtilities.js");

fluid.registerNamespace("gpii.windows.nativeSettingsHandler");


var GetDoubleClickTime = function () {
    return user32Lib.GetDoubleClickTime();
};

var SetDoubleClickTime = function (num) {
    var retVal = user32Lib.SetDoubleClickTime(num);

    if (retVal !== 0) {
        return 1;
    } else {
        return 0;
    }
};

var functionNames = {
    DoubleClickTime: {
        set: SetDoubleClickTime,
        get: GetDoubleClickTime
    }
};


/**
 * Setter for the nativeSettingsHandler.
 *
 * The payload should have the following format:
 *
 * {
 *      "function": "FunctionName",
 *      "setParam": 0,
 *      "checkReturn": true,
 *      "successValue": "value"
 * }
 *
 * The first two items:
 *   - function: Function name for the function to be used to set/get the value.
 *   - setParam: Parameter to be passed to the 'set' function.
 *   - checkReturn: Determines if it's desired to check the return code from the function with a value.
 *   - successValue: The value to compare against, in case of returnCheck being true.
 *
 * @param {object} payload The payload.
 * @return {Promise} Resolves with the response.
 */
windows.nativeSettingsHandler.setImpl = function (payload) {
    var setFn = functionNames[payload.options.functionName].set;
    var getFn = functionNames[payload.options.functionName].get;
    var results = {};

    for (var currentSettingGet in payload.settings) {
        results[currentSettingGet] = {};

        var oldVal = getFn();

        results[currentSettingGet].oldValue = oldVal;
    }


    for (var currentSettingSet in payload.settings) {
        var valueToSet = payload.settings[currentSettingSet].value;

        var retVal = setFn(valueToSet);
        var newVal = getFn();

        results[currentSettingSet].newValue = newVal;

        if (payload.options.checkReturn) {
            if (payload.options.successValue === retVal) {
                results[currentSettingSet].statusCode = payload.options.successValue;
            } else {
                results[currentSettingSet].statusCode = retVal;
            }
        }
    }

    fluid.each(results, function (value, setting) {
        results[setting].oldValue = {"value": value.oldValue, "path": payload.settings[setting].path};
        results[setting].newValue = {"value": value.newValue, "path": payload.settings[setting].path};
    });

    if (payload.options.checkReturn) {
        var failedSettings = [];
        fluid.each(results, function (value, setting) {
            if (value.statusCode !== payload.options.successValue) {
                var failedSetting = {settingName: setting, statusCode: value.statusCode};
                failedSettings.push(failedSetting);
            }
        });
        if (failedSettings.length) {
            fluid.fail(
                "NativeSettingsHandler: Success code is '" + payload.options.successValue + "'"
                + ". The following settings failed with the following error codes:"
                + JSON.stringify(failedSettings, null, 2)
            );
        } else {
            return results;
        }
    } else {
        return results;
    }
};

/**
 * Getter for the nativeSettingsHandler.
 *
 * @param {object} payload The payload.
 */
windows.nativeSettingsHandler.getImpl = function (payload) {
    var getFn = functionNames[payload.options.functionName].get;
    var curVal = getFn();

    var currentSettings = {
        setParam: curVal
    };

    var results = {};
    for (var currentSetting in payload.settings) {
        results[currentSetting] = {};

        var path = payload.settings[currentSetting].path;
        var valueToSet = gpii.windows.resolvePath(currentSettings, path);

        results[currentSetting] = {
            value: valueToSet,
            path: path
        };
    }

    return results;
};

/**
 * Invoke the settings handler.
 *
 * @param {object} payload The payload
 * @return {Promise} Resolves with the response.
 */
windows.nativeSettingsHandler.get = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(windows.nativeSettingsHandler.getImpl, payload);
};

/**
 * Invoke the settings handler.
 *
 * @param {object} payload The payload
 * @return {Promise} Resolves with the response.
 */
windows.nativeSettingsHandler.set = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(windows.nativeSettingsHandler.setImpl, payload);
};

fluid.defaults("fluid.transforms.fallbackValue", {
    gradeNames: ["fluid.transformFunction", "fluid.lens"]
});

/**
 * New transformation that lets you ignore a path if it's undefined, and supply another value instead.
 *
 * The input format for it should be the following:
 *
 * "transform": {
 *     "type": "fluid.transforms.fallbackValue",
 *     "inputPath": pathToValue,
 *     "outputPath": outputPathToStoreValue,
 *     "default": defaultValue
 * }
 *
 * Spec:
 *  - inputPath: The input path to test for nullity.
 *  - outputPath: The output path to put the result value from the transformation.
 *  - default: The default value to put in the "outputPath" in case of this being null.
 *
 * @param {object} transformSpec Transformation specification.
 * @param {*} transformer The transformer for the transformation.
 */
fluid.transforms.fallbackValue = function (transformSpec, transformer) {
    if (transformSpec.defaultValue === undefined) {
        fluid.fail("fallbackValue requires an fallback value named \"default\", supplied ", transformSpec);
    }
    var value = fluid.model.transform.getValue(transformSpec.inputPath, transformSpec.defaultInput, transformer);

    transformer.outputPrefixOp.push(transformSpec.outputPath);

    var outputValue = undefined;
    if (value === undefined) {
        outputValue = transformSpec.defaultValue;
        if (typeof(transformSpec.outputPath) === "string" && outputValue !== undefined) {
            fluid.model.transform.setValue(undefined, outputValue, transformer, transformSpec.merge);
            outputValue = undefined;
        }
    } else {
        outputValue = value;
        if (typeof(transformSpec.outputPath) === "string" && outputValue !== undefined) {
            fluid.model.transform.setValue(undefined, outputValue, transformer, transformSpec.merge);
            outputValue = undefined;
        }
    }
    transformer.outputPrefixOp.pop();

    return outputValue;
};

fluid.transforms.fallbackValue.collect = function (transformSpec, transformer) {
    var togo = [];
    fluid.model.transform.accumulateStandardInputPath("defaultInput", transformSpec, transformer, togo);
    fluid.each(transformSpec.match, function (option) {
        fluid.model.transform.accumulateInputPath(option.inputPath, transformer, togo);
    });
    return togo;
};
