/*
 * Windows Kill Process Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");

require("../processHandling.js");

fluid.registerNamespace("gpii.tests.windows.processHandling");

var waitExe = "gpii-process-handling-test.exe";
var waitExePath = null;

jqUnit.module("gpii.tests.windows.processHandling", {
    setup: function () {
        // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
        // This command is a glorified "sleep" that is also able to be terminated "nicely".
        waitExePath = path.join(process.env.TEMP, waitExe);
        shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), waitExePath);
    },
    teardown: function () {
        if (waitExePath !== null) {
            shelljs.rm(waitExePath);
        }
    }
});

/**
 * Waits for a task to start by polling every 0.5s.
 * @param task A function to check for the task, returning true if it's running.
 * @param callback The function to call when the task has been running.
 * @param maxCount Number of times to check.
 */
gpii.tests.waitForTask = function (task, callback, maxCount) {
    var repeatCount = 0;
    var waitOnce = function () {
        ++repeatCount;
        if (repeatCount === maxCount) {
            fluid.fail("Failed to find process executing");
        }
        if (!task()) {
            fluid.log("FAILED ONCE, retry " + repeatCount);
            setTimeout(waitOnce, 500);
        } else {
            callback(true);
        }
    };
    waitOnce();
};

jqUnit.test("Testing findProcessByName", function () {
    // Find a process that isn't running.
    var pid = gpii.windows.findProcessByName("a non-matching process.exe");
    jqUnit.assertEquals("Process should not have been found running", null, pid);

    // Find a process that is running.
    pid = gpii.windows.findProcessByName("node.exe");
    jqUnit.assertNotEquals("Process should have been found running", null,  pid);

    // Find multiple processes. There's always more than one svchost.exe running on Windows.
    var pids = gpii.windows.findProcessByName("svchost.exe", true);
    jqUnit.assertTrue("Should have found several matching process.", pids.length > 1);
});

jqUnit.asyncTest("Testing waiting for processes death", function () {
    jqUnit.expect(3);

    // Create the process, with a 5 second timeout
    shelljs.exec(waitExePath + " waitForProcessTerminationTest /T 5 > nul", {
        async: true
    });

    var checkForTask = function () {
        return gpii.windows.findProcessByName(waitExe) !== null;
    };

    jqUnit.assertEquals("We've haven't started it yet.", false, checkForTask());

    gpii.tests.waitForTask(checkForTask, function () {
        jqUnit.assertEquals("We just started the new process.", true, checkForTask());

        // Begin the waiting
        gpii.windows.waitForProcessTermination(waitExe)
            .then(function () {
                jqUnit.assert("Child process terminated.");
                jqUnit.start();
            });

        // Tell the process to stop now.
        shelljs.exec("waitfor /SI waitForProcessTerminationTest");
    }, 10);
});

jqUnit.asyncTest("Testing Killing Processes", function () {
    jqUnit.expect(3);

    var checkForTask = function () {
        return gpii.windows.findProcessByName(waitExe) !== null;
    };

    jqUnit.assertEquals("We've haven't started it yet.", false, checkForTask());
    // On the call below, async is true because if it is false shelljs will
    // wait around until it is manually killed before continuing with the
    // rest of the tests.
    var command =  waitExePath + " killProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    shelljs.exec(command, {
        async: true
    }, function (code, stdout, stderr) {
        fluid.log("Exit code:", code);
        jqUnit.assertEquals("Process should have terminated with code SIGKILL", 9, code);
        fluid.log("Program output:", stdout);
        fluid.log("Program stderr:", stderr);
        jqUnit.start();
    });
    gpii.tests.waitForTask(checkForTask, function () {
        jqUnit.assertEquals("We just started the new process.", true, checkForTask());
        gpii.windows.killProcessByName(waitExe);
    }, 10);
});


