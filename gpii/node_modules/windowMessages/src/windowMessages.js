/* Captures Window messages.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    ffi = require("ffi");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.windows.messages");

require("../../WindowsUtilities/WindowsUtilities.js");

var windows = gpii.windows;

fluid.defaults("gpii.windows.messages", {
    gradeNames: ["fluid.component"],
    events: {
        /**
         * Message received (see https://msdn.microsoft.com/library/ms633573)
         * @param hwnd {number} Window handle
         * @param msg {number} Message (WM_*)
         * @param wParam {number} Message specific data
         * @param lParam {void*}  Message specific data (ffi pointer, may not be valid after return)
         */
        "onMessage": null
    },
    listeners: {
        "onDestroy": {
            funcName: "gpii.windows.messages.stop",
            args: "{that}"
        }
    },
    invokers: {
        start: {
            funcName: "gpii.windows.messages.start",
            args: "{that}"
        },
        stop: {
            funcName: "gpii.windows.messages.stop",
            args: "{that}"
        },
        getWindowHandle: {
            funcName: "gpii.windows.messages.getWindowHandle"
        }
    }
});

/** Message window class */
gpii.windows.messages.windowClassname = "gpii-message-window";

/** Window handle of the message window (multiple component instances use the same window). */
gpii.windows.messages.messageWindow = null;

/** A reference counter, so the window can be destroyed when no longer required. */
gpii.windows.messages.references = [];

/** An event firer used to raise the onMessage event of the components. */
gpii.windows.messages.messageEvent = null;

/**
 * Start listening for window messages. Create the message window if it's not already created.
 *
 * @param that {Component} The gpii.windows.messages instance.
 */
gpii.windows.messages.start = function (that) {
    var id = that.id;
    if (gpii.windows.messages.references.indexOf(id) === -1) {
        if (!gpii.windows.messages.messageEvent) {
            gpii.windows.messages.messageEvent = fluid.makeEventFirer();
        }
        if (!gpii.windows.messages.messageWindow) {
            gpii.windows.messages.createMessageWindow();
        }

        gpii.windows.messages.messageEvent.addListener(that.events.onMessage.fire, id);
        gpii.windows.messages.references.push(id);
    }
};

/**
 * Stop listening for window messages. Destroy the message window if no other instance is using it.
 *
 * @param that {Component} The gpii.windows.messages instance.
 */
gpii.windows.messages.stop = function (that) {
    var id = that.id;
    var index = gpii.windows.messages.references.indexOf(id);
    if (index > -1) {
        gpii.windows.messages.references.splice(index, 1);
        gpii.windows.messages.messageEvent.removeListener(id);

        if (gpii.windows.messages.references.length === 0) {
            gpii.windows.messages.destroyMessageWindow();
        }
    }
};

/**
 * Gets the handle of the message window (hWnd).
 *
 * @return {number} The handle, or 0 if there's no window.
 */
gpii.windows.messages.getWindowHandle = function () {
    return gpii.windows.messages.messageWindow || 0;
};

/**
 * The window procedure for the window. Fires the event, then passes the message to the default window procedure.
 *
 * WindowProc: https://msdn.microsoft.com/library/ms633573
 *
 * @param hwnd {number} Window handle.
 * @param msg {number} The window message.
 * @param wParam {number} Message parameter.
 * @param lParam {number} Message parameter.
 */
gpii.windows.messages.windowProc = function (hwnd, msg, wParam, lParam) {
    gpii.windows.messages.messageEvent.fire(hwnd, msg, wParam, lParam);
    return windows.user32.DefWindowProcW(hwnd, msg, wParam, lParam);
};

/**
 * Polls for messages - only required if not running under electron.
 */
gpii.windows.messages.messagePump = function () {

    var loop = function () {
        // sizeof(MSG) = 48 on 64-bit, 28 on 32-bit.
        var msg = new Buffer(process.arch === "x64" ? 48 : 28);

        // Unable to use GetMessage because it blocks, and can't call via .async because it needs to be in the same
        // thread as the window.
        while (gpii.windows.user32.PeekMessageW(msg.ref(), 0, 0, 0, 1)) {
            gpii.windows.user32.TranslateMessage(msg.ref());
            gpii.windows.user32.DispatchMessageW(msg.ref());
        }

        if (gpii.windows.messages.messageWindow) {
            setTimeout(loop, 2000);
        }
    };
    loop();
};

/**
 * Creates a window whose only purpose is to receive messages.
 *
 * The window has no visibility - it just exists.
 */
gpii.windows.messages.createMessageWindow = function () {
    if (gpii.windows.messages.messageWindow) {
        fluid.fail("Message window already created.");
    }

    var className = windows.stringToWideChar(gpii.windows.messages.windowClassname);

    // Window class only needs to be registered once.
    if (!gpii.windows.messages.windowProcPointer) {
        // Create the Window Class for the window
        var cls = new windows.WNDCLASSW();
        cls.ref().fill(0);

        cls.lpszClassName = className;

        // Create a pointer to the window procedure function.
        cls.lpfnWndProc = ffi.Callback(gpii.windows.types.HANDLE,
            [gpii.windows.types.HANDLE, gpii.windows.types.UINT, gpii.windows.types.UINT, gpii.windows.types.PVOID],
            gpii.windows.messages.windowProc);

        // Keep a reference to the function pointer, otherwise the GC will free it.
        gpii.windows.messages.windowProcPointer = function () {
            cls.lpfnWndProc();
        };

        var result = gpii.windows.user32.RegisterClassW(cls.ref());
        if (!result) {
            fluid.fail("RegisterClass failed");
        }
    }

    // Start the message loop
    if (!process.versions.electron) {
        gpii.windows.messages.messageWindow = 1; // make the loop think there's already a window.
        gpii.windows.messages.messagePump();
    }

    // Create the Window.
    gpii.windows.messages.messageWindow =
        gpii.windows.user32.CreateWindowExW(0, className, className, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    if (!gpii.windows.messages.messageWindow) {
        fluid.fail("CreateWindowEx failed");
    }
};

/**
 * Destroys the window created by createMessageWindow.
 *
 * @return {boolean} false on failure.
 */
gpii.windows.messages.destroyMessageWindow = function () {
    var success = true;
    if (gpii.windows.messages.messageWindow) {
        // Destroy the window.
        success = !!windows.user32.DestroyWindow(gpii.windows.messages.messageWindow);
        gpii.windows.messages.messageWindow = null;

        gpii.windows.messages.messageEvent.destroy();
        gpii.windows.messages.messageEvent = null;
        gpii.windows.messages.references = [];

    }
    return success;
};

