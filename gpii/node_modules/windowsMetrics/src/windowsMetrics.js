/*
 * Captures metrics specific to the Windows operating system - for example, non-identifying keyboard metrics,
 * activation and deactivation of top-level windows, etc.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var ffi = require("ffi");
var fluid = require("infusion");

var windows = fluid.registerNamespace("gpii.windows");

fluid.require("%gpii-windows/gpii/node_modules/WindowsUtilities/WindowsUtilities.js");


fluid.defaults("gpii.windowsMetrics", {
    gradeNames: ["fluid.modelComponent", "fluid.contextAware", "gpii.metrics"],
    contextAwareness: {
        platform: {
            checks: {
                test: {
                    contextValue: "{gpii.contexts.test}",
                    gradeNames: "gpii.windowsMetrics.test"
                },
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.windowsMetrics.windows"
                }
            }
        }
    },
    listeners: {
        "onDestroy.stopMetrics": "{that}.events.onStopMetrics",
        "onStartMetrics.application": "{that}.startApplicationMetrics",
        "onStopMetrics.application": "{that}.stopApplicationMetrics",
        "onStartMetrics.input": "{that}.startInputMetrics",
        "onStopMetrics.input": "{that}.stopInputMetrics"
    },
    invokers: {
        logMetric: {
            func: "{eventLog}.logEvent",
            args: ["{eventLog}", "metrics", "{arguments}.0", "{arguments}.1"]
        },
        startApplicationMetrics: {
            funcName: "gpii.windows.startApplicationMetrics",
            args: ["{that}"]
        },
        stopApplicationMetrics: {
            funcName: "gpii.windows.stopApplicationMetrics",
            args: ["{that}"]
        },
        startInputMetrics: {
            funcName: "gpii.windows.startInputMetrics",
            args: ["{that}"]
        },
        stopInputMetrics: {
            funcName: "gpii.windows.stopInputMetrics",
            args: ["{that}"]
        }
    },
    members: {
        config: {
            application: {
                // Milliseconds to poll the active window.
                precision: 5000
            },
            input: {
                // Minimum typing session time, in milliseconds.
                minSession: 30000,
                // The time a session will last with no activity, in milliseconds.
                sessionTimeout: 60000,
                // Minimum number of keys in a typing session time.
                minSessionKeys: 30000,
                // Milliseconds of no input to assume inactive
                inactiveTime: 300000
            }
        },
        state: {
            application: {},
            input: {
                keyboardHookHandle: null,
                mouseHookHandle: null,
                lastKeyLogged: null,
                lastKeyTime: 0,
                // Timestamp of typing session start.
                sessionStart: null,
                // Number of keys in the typing session.
                keyCount: 0,
                // Number of special keys
                specialCount: 0,
                // Mouse position
                lastPos: null,
                distance: 0,
                lastInputTime: 0
            }
        }
    }
});

fluid.defaults("gpii.metrics.windows", {
    components: {
        windowsMetrics: {
            type: "gpii.windowsMetrics"
        }
    }
});

fluid.defaults("gpii.installID.windows", {
    invokers: {
        getMachineID: "gpii.windows.getMachineID"
    }
});

/**
 * Gets the machine ID - something that uniquely identifies this machine.
 *
 * This relies on the MachineGUID, which is generated when Windows is installed or when a cloned image is deployed
 * in the recommended way using sysprep.
 *
 * @return {String} The machine ID.
 */
windows.getMachineID = function () {
    var machineID = windows.readRegistryKey(
        "HKEY_LOCAL_MACHINE", "64:SOFTWARE\\Microsoft\\Cryptography", "MachineGuid", "REG_SZ").value;
    return machineID;
};

/**
 * Check if the currently active pid+exe has been seen before. If not, log it as an application launch.
 * Called when a window has been activated.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.checkNewApplication = function (that) {
    var runningApplications = that.state.application.runningApplications;
    var pid = that.state.application.currentProcess.pid;
    var exePath = that.state.application.currentProcess.exe;

    // pid might have been re-used.
    var oldExe = runningApplications[pid];
    var isNew = oldExe !== exePath;

    if (isNew) {
        var data = {
            exe: exePath
        };

        that.logMetric("app-launch", data);

        if (!oldExe) {
            runningApplications.count++;
        }
        runningApplications[pid] = exePath;

        // It doesn't need to be constantly kept up to date, but trim it at a certain point.
        if (runningApplications.count > 30) {
            for (var key in runningApplications) {
                if (runningApplications.hasOwnProperty(key) && !isNaN(key)) {
                    if (!windows.isProcessRunning(key)) {
                        delete runningApplications[key];
                        runningApplications.count--;
                    }
                }
            }
        }
    }
};

/**
 * Begin monitoring the application launches and active windows.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startApplicationMetrics = function (that) {
    that.state.application = {
        active: true,
        runningApplications: {
            count: 0
        }
    };
    windows.checkActiveWindow(that, null);
};

/**
 * Stops collecting the application metrics.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.stopApplicationMetrics = function (that) {
    that.state.application.active = false;
    // Log the currently active window as though it was de-activated.
    windows.logAppActivate(that);
};

/**
 * Logs the application active metric - how long an application has been active for.
 * Called when a new window is being activated, while currentProcess refers to the application losing focus.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.logAppActivate = function (that) {
    if (that.state.application.currentProcess) {
        var duration = process.hrtime(that.state.application.currentProcess.timeActivated);
        var data = {
            exe: that.state.application.currentProcess.exe,
            // Round to the nearest second.
            duration: duration[0] + (duration[1] < 5e8 ? 0 : 1)
        };
        that.logMetric("app-active", data);
    }
};
/**
 * Begin checking if the active Window has changed. It will continue to check while application.state.active is true.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.checkActiveWindow = function (that) {
    var activePid = 0;
    var lastHwnd = 0;
    if (!that.state.application.currentProcess) {
        that.state.application.currentProcess = {};
    }
    that.state.application.currentProcess.timeActivated = process.hrtime();

    windows.waitForCondition(function () {
        // Get the process ID that owns the active Window.
        var hwnd = windows.user32.GetForegroundWindow();
        if (hwnd) {
            if (hwnd !== lastHwnd) {
                lastHwnd = hwnd;
            }
            activePid = windows.getWindowProcessId(hwnd);
        }
        return activePid !== that.state.application.currentProcess.pid || !that.state.application.active;
    }, {
        pollDelay: that.config.application.precision
    }).then(function () {
        if (that.state.application.active) {
            // Log how long the last window was active.
            windows.logAppActivate(that);

            var exePath = activePid ? windows.getProcessPath(activePid) : "(none)";
            that.state.application.currentProcess.pid = activePid;
            that.state.application.currentProcess.exe = exePath;

            // Also perform the "application launch" metric here. A process having its window activated implies it's
            // been launched.
            windows.checkNewApplication(that);
            windows.checkActiveWindow(that);
        }
    });
};

/**
 * Starts the input metrics.
 *
 * This sets up low-level keyboard and mouse hooks (WH_KEYBOARD_LL, WH_MOUSE_LL) that makes the system invoke a
 * call-back whenever a key is pressed or released, or the mouse is moved/clicked.
 * Hooks overview: https://msdn.microsoft.com/library/ms644959
 *
 * This comes with the following limitations:
 * - The process needs a window-message loop. Fortunately, Electron has one so this means it will only work if running
 *   via gpii-app (otherwise this becomes an interesting way of disabling the keyboard).
 * - It can't see the keys that are destined to a window owned by a process running as Administrator (and rightly so).
 * - The hook call-back has to return in a timely manner - not only because it would cause key presses to lag, but also
 *   Windows will silently remove the hook if it times out. The time is unspecified (but it can be set in the registry).
 * - Anti-virus software may question this.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startInputMetrics = function (that) {
    windows.stopInputMetrics(that);
    if (process.versions.electron) {
        var callHook = function (code, wparam, lparam) {
            // Handle the hook in the next tick, to allow the hook callback to return quickly.
            process.nextTick(windows.inputHook, that, code, wparam, lparam);
            return windows.user32.CallNextHookEx(0, code, wparam, lparam);
        };

        // The callbacks need to be referenced outside here otherwise the GC will pull the rug from beneath it.
        windows.keyboardHookCallback = ffi.Callback(
            windows.types.HANDLE, [windows.types.INT, windows.types.HANDLE, windows.KBDLLHookStructPointer], callHook);
        windows.mouseHookCallback = ffi.Callback(
            windows.types.HANDLE, [windows.types.INT, windows.types.HANDLE, windows.MSDLLHookStructPointer], callHook);

        var WH_KEYBOARD_LL = 13, WH_MOUSE_LL = 14;
        var hModule = windows.kernel32.GetModuleHandleW(0);

        // Start the keyboard hook
        that.state.input.keyboardHookHandle =
            windows.user32.SetWindowsHookExW(WH_KEYBOARD_LL, windows.keyboardHookCallback, hModule, 0);

        if (!that.state.input.keyboardHookHandle) {
            var errCode = windows.kernel32.GetLastError();
            windows.stopInputMetrics(that);
            fluid.fail("SetWindowsHookExW did not work (keyboard). win32 error: " + errCode);
        }

        // Start the mouse hook
        that.state.input.mouseHookHandle =
            windows.user32.SetWindowsHookExW(WH_MOUSE_LL, windows.mouseHookCallback, hModule, 0);

        if (!that.state.input.mouseHookHandle) {
            var errCode2 = windows.kernel32.GetLastError();
            windows.stopInputMetrics(that);
            fluid.fail("SetWindowsHookExW did not work (mouse). win32 error: " + errCode2);
        }

        windows.userInput(that);
    } else {
        // The keyboard hook's ability to work is a side-effect of running with electron.
        fluid.log(fluid.logLevel.WARN, "Input metrics not available without Electron.");
    }
};

/**
 * Disables the key stroke metrics.
 *
 * Removes the low-level keyboard hook from the system, and sends the last timings to the log.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.stopInputMetrics = function (that) {
    var state = that.state.input;
    // remove the hooks
    if (state.keyboardHookHandle) {
        windows.user32.UnhookWindowsHookEx(state.keyboardHookHandle);
    }
    if (state.mouseHookHandle) {
        windows.user32.UnhookWindowsHookEx(state.mouseHookHandle);
    }
    state.keyboardHookHandle = null;
    state.keyboardHookCallback = null;
    state.mouseHookHandle = null;
    state.mouseHookCallback = null;

    if (state.inactivityTimer) {
        clearTimeout(state.inactivityTimer);
        state.inactivityTimer = null;
    }
};

/**
 * Keys that have a special meaning.
 */
windows.specialKeys = fluid.freezeRecursive((function () {
    var special = {
        "BS": windows.API_constants.VK_BACK,
        "DEL": windows.API_constants.VK_DELETE,
        "ESC": windows.API_constants.VK_ESCAPE,
        "LEFT": windows.API_constants.VK_LEFT
    };

    // Swap to ease look-ups.
    fluid.each(special, function (value, key) {
        special[value] = key;
    });

    return special;
})());

/**
 * Records the timing of a key press. This only logs the time between two keys being pressed, and not the actual
 * value of the key (unless it's a special key). Characters aren't being recorded.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param timestamp {Number} Milliseconds since a fixed point in time.
 * @param specialKey {String} The value key, if it's a special key.
 */
windows.recordKeyTiming = function (that, timestamp, specialKey) {
    var state = that.state.input;
    var config = that.config.input;

    // The time since the last key press
    var keyTime = state.lastKeyTime ? timestamp - state.lastKeyTime : 0;
    if (keyTime > config.sessionTimeout) {
        // Only care about the time between keys in a typing session.
        keyTime = 0;
    }

    /* "A recordable typing session would be determined only once a threshold of thirty seconds of typing has been
     * reached and ending after a period of not typing for 60 seconds. (the recorded typing time for calculation would
     * include the 30 seconds for threshold and exclude the 60 seconds inactivity session end threshold)"
     */
    if ((state.keyCount > 1) && !keyTime) {
        var duration = state.lastKeyTime - state.sessionStart;
        if (duration > config.minSession && state.keyCount >= config.minSessionKeys) {
            // Record the typing rate for the last typing session.
            var data = {
                duration: duration,
                count: state.keyCount,
                corrections: state.specialCount
            };
            // Keys per minute.
            data.rate = Math.round(60000 / data.duration * data.count);
            that.logMetric("typing-session", data);
        }
        state.keyCount = 0;
    }

    if (!state.keyCount) {
        if (!specialKey) {
            // New typing session.
            state.keyCount = 1;
            state.specialCount = 0;
            state.sessionStart = timestamp;
        }
    } else if (specialKey) {
        state.specialCount++;
    } else {
        state.keyCount++;
    }

    state.lastKeyTime = timestamp;

    var record = {
        keyTime: keyTime
    };

    if (specialKey) {
        // Double-check that only certain keys are being recorded (it would be a serious blunder).
        if (windows.specialKeys[specialKey] && typeof (specialKey) === "string" && specialKey.length > 1) {
            record.key = windows.specialKeys[windows.specialKeys[specialKey]];
        }
    }

    that.logMetric("key-time", record);
};

/**
 * Records a mouse event. Movement isn't logged, but the distance is accumulated.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param eventType {String} "move" or "button".
 * @param button {Number} Mouse button: 0 movement only, 1 for primary (left) or 2 or secondary.
 * @param pos {Object} mouse cursor coordinates {x, y}.
 */
windows.recordMouseEvent = function (that, button, pos) {
    var state = that.state.input;

    if (state.lastPos) {
        state.distance += Math.sqrt(Math.pow(state.lastPos.x - pos.x, 2) + Math.pow(state.lastPos.y - pos.y, 2));
    }

    state.lastPos = pos;

    if (button) {
        that.logMetric("mouse", {
            button: button,
            distance: Math.round(state.distance)
        });
        state.distance = 0;
    }
};

/**
 * Called by inputHook when it receives some input, then waits for no further input to detect inactivity.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.userInput = function (that) {
    var state = that.state.input;

    if (state.inactive) {
        // First input from being inactive.
        var duration = process.hrtime(state.lastInputTime);
        that.logMetric("inactive-stop", { duration: duration[0] });
        state.inactive = false;
    }
    if (state.inactivityTimer) {
        clearTimeout(state.inactivityTimer);
        state.inactivityTimer = null;
    }

    state.lastInputTime = process.hrtime();
    state.inactivityTimer = setTimeout(windows.userInactive, that.config.input.inactiveTime, that);
};

/**
 * Called when there's been some time since receiving input from the user.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.userInactive = function (that) {
    that.state.input.inactive = true;
    that.logMetric("inactive-begin");
};

/**
 * The keyboard hook callback. Called when a key is pressed or released.
 * https://msdn.microsoft.com/library/ms644985
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param code {Number} If less than zero, then don't process.
 * @param wparam {Number} The input message (eg, WM_KEYDOWN or WM_MOUSEMOVE).
 * @param lparam {Number} A pointer to a KBDLLHOOKSTRUCT or MSDLLHOOKSTRUCT structure.
 * @return {Number} The return value of CallNextHookEx.
 */
windows.inputHook = function (that, code, wparam, lparam) {
    var togo;
    if (code >= 0) {
        windows.userInput(that);

        // For testing, allows the object to be passed directly rather than a ffi/ref struct.
        var eventData = lparam.deref ? lparam.deref() : lparam;

        switch (wparam) {
        case windows.API_constants.WM_KEYUP:
            // Key press
            var wanted = false;

            var specialKey = windows.specialKeys[eventData.vkCode];

            // Ignore injected and Alt keys.
            var ignoreFlags = windows.API_constants.LLKHF_INJECTED | windows.API_constants.LLKHF_ALTDOWN;

            if ((eventData.flags & ignoreFlags) === 0) {
                // If the key doesn't generate a character, then don't count it.
                wanted = specialKey || windows.user32.MapVirtualKeyW(eventData.vkCode, windows.API_constants.MAPVK_VK_TO_CHAR);
                if (eventData.vkCode === windows.API_constants.VK_LEFT) {
                    // Special case for the 'left' cursor key - if the last key was logged then log this key as it was
                    // probably used for correcting a mistake.
                    wanted = that.state.input.lastKeyLogged;
                }
                if (wanted) {
                    // Process in the next tick, to allow this function to return soon.
                    windows.recordKeyTiming(that, eventData.time, specialKey);
                }

                that.state.input.lastKeyLogged = wanted && !specialKey;
            }
            break;

        case windows.API_constants.WM_MOUSEMOVE:
        case windows.API_constants.WM_LBUTTONUP:
        case windows.API_constants.WM_RBUTTONUP:
            // Don't log injected events.
            if ((eventData.flags & windows.API_constants.LLMHF_INJECTED) === 0) {
                var button = (wparam >> 1) & 3; // 2nd + 3rd bits happen to map to the button
                windows.recordMouseEvent(that, button, { x: eventData.ptX, y: eventData.ptY });
            }
            break;
        }
    }
    return togo;
};
