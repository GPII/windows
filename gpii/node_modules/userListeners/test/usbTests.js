/*
 * USB User listener Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    ffi = require("ffi");

fluid.require("%gpii-windows/gpii/node_modules/windowMessages");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");

jqUnit.module("gpii.tests.userListener.usb", {
    setup: function () {
        // Stop any listeners already running
        var listeners = fluid.queryIoCSelector(fluid.rootComponent, "gpii.userListeners");
        while (listeners.length) {
            listeners.shift().destroy();
        }
    }
});

fluid.defaults("gpii.tests.userListener.usbListener", {
    gradeNames: ["fluid.component", "gpii.userListeners.usb.windows"],
    listeners: {
        "onTokenArrive.callFlowManager": "fluid.identity",
        "onTokenRemove.callFlowManager": "fluid.identity"
    },
    invokers: {
        getWindowHandle: "{gpii.windows.messages}.getWindowHandle"
    }
});

gpii.tests.userListener.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms644950
    "SendMessageW": [
        "int", [gpii.windows.types.HANDLE, gpii.windows.types.UINT, gpii.windows.types.UINT, "void*" ]
    ]
});

gpii.tests.userListener.getUSBListener = function () {
    var userListeners = gpii.userListeners({
        listeners: {
            "onCreate.startListeners": "fluid.identity"
        },
        distributeOptions: {
            record: "gpii.tests.userListener.usbListener",
            target: "{that usb}.options.gradeNames"
        }
    });

    return userListeners.usb;
};

/**
 * Sends the device added/removed message (WM_DEVICECHANGE) to the message window, to simulate a device arrival/removal
 * event.
 *
 * It blocks until the message has been handled.
 *
 * @param {Number} window The window handle to send the message to.
 * @param {Boolean} added true to add the device, false to remove
 * @param {String|String[]} drives The drive letter(s) that the device provides.
 */
gpii.tests.userListener.sendDeviceMessage = function (window, added, drives) {
    var volume = new gpii.windows.DEV_BROADCAST_VOLUME();
    volume.ref().fill(0);
    volume.size = gpii.windows.DEV_BROADCAST_VOLUME.size;
    volume.deviceType = gpii.windows.API_constants.DBT_DEVTYP_VOLUME;

    // Each bit in the mask represents a drive letter.
    var mask = 0;
    var a = "A".charCodeAt(0);
    fluid.each(fluid.makeArray(drives), function (letter) {
        mask |= 1 << letter.toUpperCase().charCodeAt(0) - a;
    });
    volume.unitMask = mask;

    // Can't use PostMessage because lParam is a pointer.
    gpii.tests.userListener.user32.SendMessageW(
        window,
        gpii.windows.API_constants.WM_DEVICECHANGE,
        added ? gpii.windows.API_constants.DBT_DEVICEARRIVAL : gpii.windows.API_constants.DBT_DEVICEREMOVECOMPLETE,
        volume.ref());

};

// Test the USB detection by sending the appropriate message to the message window
jqUnit.asyncTest("USB listener - device detection", function () {
    var usbListener = gpii.tests.userListener.getUSBListener();

    var tests = [
        "A", "Z", // first and last
        [ "D", "E", "F" ], // multiple volumes
        "X", "X" // (un)mount an already (un)mounted
    ];

    // Expect the drive letter for each test item.
    var expected = fluid.transform(Array.prototype.concat.apply([], tests), function (input) {
        return input + ":\\";
    });

    jqUnit.expect(expected.length * 4);

    var mountIndex = 0;
    var unmountIndex = 0;

    usbListener.startListener();
    var window = usbListener.getWindowHandle();

    usbListener.events.onMount.removeListener("readToken");
    usbListener.events.onMount.addListener(function (that, path) {
        var expect = expected[mountIndex];
        jqUnit.assertEquals("onMount that - index=" + mountIndex, usbListener, that);
        jqUnit.assertEquals("onMount path - index=" + mountIndex, expect, path);
        if (++mountIndex >= expected.length) {
            // Unmount the drives
            fluid.each(tests, function (test) {
                gpii.tests.userListener.sendDeviceMessage(window, false, test);
            });
        }
    });

    usbListener.events.onUnmount.removeListener("readToken");
    usbListener.events.onUnmount.addListener(function (that, path) {
        var expect = expected[unmountIndex];
        jqUnit.assertEquals("onUnmount that - index=" + unmountIndex, usbListener, that);
        jqUnit.assertEquals("onUnmount path - index=" + unmountIndex, expect, path);
        if (++unmountIndex >= expected.length) {
            usbListener.stopListener();
            jqUnit.start();
        }
    });

    // Mount the drives.
    fluid.each(tests, function (test) {
        gpii.tests.userListener.sendDeviceMessage(window, true, test);
    });

});
