/*
 * Captures metrics specific to the Windows operating system - for example, non-identifying keyboard metrics,
 * activation and deactivation of top-level windows, etc.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var ffi = require("ffi");
var fluid = require("infusion");

var windows = fluid.registerNamespace("gpii.windows");

fluid.require("%gpii-windows/gpii/node_modules/WindowsUtilities/WindowsUtilities.js");


fluid.defaults("gpii.windowsMetrics", {
    gradeNames: ["fluid.modelComponent", "fluid.contextAware"],
    contextAwareness: {
        platform: {
            checks: {
                test: {
                    contextValue: "{gpii.contexts.test}",
                    gradeNames: "gpii.windowsMetrics.test"
                },
                windows: {
                    contextValue: "{gpii.contexts.windows}",
                    gradeNames: "gpii.windowsMetrics.windows"
                }
            }
        }
    },
    listeners: {
        "{lifecycleManager}.events.onSessionStop": {
            "func": "{that}.events.onStopMetrics",
            "priority": "before:eventLog"
        },
        "onDestroy.stopMetrics": "{that}.events.onStopMetrics",
        "onStartMetrics.application": "{that}.startApplicationMetrics",
        "onStopMetrics.application": "{that}.stopApplicationMetrics",
        "onStartMetrics.keyboard": "{that}.startKeyboardMetrics",
        "onStopMetrics.keyboard": "{that}.stopKeyboardMetrics"
    },
    events: {
        "onStartMetrics": null,
        "onStopMetrics": null
    },
    invokers: {
        logMetric: {
            func: "{eventLog}.logEvent",
            args: ["{eventLog}", "metrics", "{arguments}.0", "{arguments}.1"]
        },
        startApplicationMetrics: {
            funcName: "gpii.windows.startApplicationMetrics",
            args: ["{that}"]
        },
        stopApplicationMetrics: {
            funcName: "gpii.windows.stopApplicationMetrics",
            args: ["{that}"]
        },
        startKeyboardMetrics: {
            funcName: "gpii.windows.startKeyboardMetrics",
            args: ["{that}"]
        },
        stopKeyboardMetrics: {
            funcName: "gpii.windows.stopKeyboardMetrics",
            args: ["{that}"]
        }
    },
    model: {
        config: {
            application: {
                // Milliseconds to poll the active window.
                precision: 5000
            },
            keyboard: {
                // Minimum typing session time, in milliseconds.
                minSession: 30000,
                // The time a session will last with no activity, in milliseconds.
                sessionTimeout: 60000,
                // Minimum number of keys in a typing session time.
                minSessionKeys: 30000
            }
        },
        state: {
            application: {},
            keyboard: {
                keyboardHookHandle: null,
                lastKeyLogged: null,
                lastKeyTime: 0,
                // Timestamp of typing session start.
                sessionStart: null,
                // Number of keys in the typing session.
                keyCount: 0,
                // Numnber of special keys
                specialCount: 0
            }
        }
    }
});

fluid.defaults("gpii.windowsMetrics.windows", {
    listeners: {
        "{lifecycleManager}.events.onSessionStart": "{that}.events.onStartMetrics"
    }
});

// Don't auto-start the metrics capture when testing.
fluid.defaults("gpii.windowsMetrics.test", {
});

fluid.defaults("gpii.eventLog.windows", {
    components: {
        windowsMetrics: {
            type: "gpii.windowsMetrics"
        }
    }
});

fluid.defaults("gpii.installID.windows", {
    invokers: {
        getMachineID: "gpii.windows.getMachineID"
    }
});

/**
 * Gets the machine ID - something that uniquely identifies this machine.
 *
 * This relies on the MachineGUID, which is generated when Windows is installed or when a cloned image is deployed
 * in the recommended way using sysprep.
 *
 * @return {String} The machine ID.
 */
windows.getMachineID = function () {
    var machineID = windows.readRegistryKey(
        "HKEY_LOCAL_MACHINE", "64:SOFTWARE\\Microsoft\\Cryptography", "MachineGuid", "REG_SZ").value;
    return machineID;
};

/**
 * Check if the currently active pid+exe has been seen before. If not, log it as an application launch.
 * Called when a window has been activated.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.checkNewApplication = function (that) {
    var runningApplications = that.model.state.application.runningApplications;
    var pid = that.model.state.application.currentProcess.pid;
    var exePath = that.model.state.application.currentProcess.exe;

    // pid might have been re-used.
    var oldExe = runningApplications[pid];
    var isNew = oldExe !== exePath;

    if (isNew) {
        var data = {
            exe: exePath
        };

        that.logMetric("app-launch", data);

        if (!oldExe) {
            runningApplications.count++;
        }
        runningApplications[pid] = exePath;

        // It doesn't need to be constantly kept up to date, but trim it at a certain point.
        if (runningApplications.count > 30) {
            for (var key in runningApplications) {
                if (runningApplications.hasOwnProperty(key) && !isNaN(key)) {
                    if (!windows.isProcessRunning(key)) {
                        delete runningApplications[key];
                        runningApplications.count--;
                    }
                }
            }
        }
    }
};

/**
 * Begin monitoring the application launches and active windows.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startApplicationMetrics = function (that) {
    that.model.state.application = {
        active: true,
        runningApplications: {
            count: 0
        }
    };
    windows.checkActiveWindow(that, null);
};

/**
 * Stops collecting the application metrics.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.stopApplicationMetrics = function (that) {
    that.model.state.application.active = false;
    // Log the currently active window as though it was de-activated.
    windows.logAppActivate(that);
};

/**
 * Logs the application active metric - how long an application has been active for.
 * Called when a new window is being activated, while currentProcess refers to the application losing focus.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.logAppActivate = function (that) {
    if (that.model.state.application.currentProcess) {
        var duration = process.hrtime(that.model.state.application.currentProcess.timeActivated);
        var data = {
            exe: that.model.state.application.currentProcess.exe,
            // Round to the nearest second.
            duration: duration[0] + (duration[1] < 5e8 ? 0 : 1)
        };
        that.logMetric("app-active", data);
    }
};
/**
 * Begin checking if the active Window has changed. It will continue to check while application.state.active is true.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.checkActiveWindow = function (that) {
    var activePid = 0;
    var lastHwnd = 0;
    if (!that.model.state.application.currentProcess) {
        that.model.state.application.currentProcess = {};
    }
    that.model.state.application.currentProcess.timeActivated = process.hrtime();

    windows.waitForCondition(function () {
        // Get the process ID that owns the active Window.
        var hwnd = windows.user32.GetForegroundWindow();
        if (hwnd) {
            if (hwnd !== lastHwnd) {
                lastHwnd = hwnd;
            }
            activePid = windows.getWindowProcessId(hwnd);
        }
        return activePid !== that.model.state.application.currentProcess.pid || !that.model.state.application.active;
    }, {
        pollDelay: that.model.config.application.precision
    }).then(function () {
        if (that.model.state.application.active) {
            // Log how long the last window was active.
            windows.logAppActivate(that);

            var exePath = windows.getProcessPath(activePid);
            that.model.state.application.currentProcess.pid = activePid;
            that.model.state.application.currentProcess.exe = exePath;

            // Also perform the "application launch" metric here. A process having its window activated implies it's
            // been launched.
            windows.checkNewApplication(that);
            windows.checkActiveWindow(that);
        }
    });
};

/**
 * Starts the key stroke metrics.
 *
 * This sets up a low-level keyboard hook (WH_KEYBOARD_LL) that makes the system invoke a call-back whenever a key is
 * pressed or released. (https://msdn.microsoft.com/library/ms644959)
 *
 * This comes with the following limitations:
 * - The process needs a window-message loop. Fortunately, Electron has one so this means it will only work if running
 *   via gpii-app (otherwise this becomes an interesting way of disabling the keyboard).
 * - It can't see the keys that are destined to a window owned by a process running as Administrator (and rightly so).
 * - The hook call-back has to return in a timely manner - not only because it would cause key presses to lag, but also
 *   Windows will silently remove the hook if it times out. The time is unspecified (but it can be set in the registry).
 * - Anti-virus software may question this.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startKeyboardMetrics = function (that) {
    windows.stopKeyboardMetrics(that);
    if (process.versions.electron) {
        // The callback needs to be referenced outside here otherwise the GC will pull the rug from beneath it.
        windows.keyboardHookCallback = ffi.Callback(
            windows.types.HANDLE, [windows.types.INT, windows.types.HANDLE, windows.KBDLLHookStructPointer],
            function (code, wparam, lparam) {
                windows.keyboardHook(that, code, wparam, lparam);
            });

        var hModule = windows.kernel32.GetModuleHandleW(0);
        that.model.state.keyboard.keyboardHookHandle =
            windows.user32.SetWindowsHookExW(13, windows.keyboardHookCallback, hModule, 0);

        if (!that.model.state.keyboard.keyboardHookHandle) {
            windows.keyboardHookCallback = null;
            fluid.fail("SetWindowsHookExW did not work. win32 error: " + windows.kernel32.GetLastError());
        }

    } else {
        // The keyboard hook's ability to work is a side-effect of running with electron.
        fluid.log(fluid.logLevel.WARN, "Keyboard metrics not available without Electron.");
    }

    that.model.state.keyboard.config = that.model.config.keyboard;
};

/**
 * Disables the key stroke metrics.
 *
 * Removes the low-level keyboard hook from the system, and sends the last timings to the log.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.stopKeyboardMetrics = function (that) {
    // remove the keyboard hook
    if (that.model.state.keyboard.keyboardHookHandle) {
        windows.user32.UnhookWindowsHookEx(that.model.state.keyboard.keyboardHookHandle);
    }
    that.model.state.keyboard.keyboardHookHandle = null;
    that.model.state.keyboard.keyboardHookCallback = null;
    // flush the log.
    if (that.model.state.keyboard.times) {
        windows.logKeyTimings(that);
        that.model.state.keyboard.times = [];
    }
};

/**
 * Keys that have a special meaning.
 */
windows.specialKeys = fluid.freezeRecursive((function () {
    var special = {
        "BS": windows.API_constants.VK_BACK,
        "DEL": windows.API_constants.VK_DELETE,
        "ESC": windows.API_constants.VK_ESCAPE,
        "LEFT": windows.API_constants.VK_LEFT
    };

    // Swap to ease look-ups.
    fluid.each(special, function (value, key) {
        special[value] = key;
    });

    return special;
})());

/**
 * Records the timing of a key press. This only logs the time between two keys being pressed, and not the actual
 * value of the key (unless it's a special key). Characters aren't being recorded.
 *
 * @param state {Object} The keyboard metrics state.
 * @param timestamp {Number} Milliseconds since a fixed point in time.
 * @param specialKey {String} The value key, if it's a special key.
 */
windows.recordKeyTiming = function (that, timestamp, specialKey) {
    var state = that.model.state.keyboard;

    // The time since the last key press
    var keyTime = state.lastKeyTime ? timestamp - state.lastKeyTime : 0;
    if (keyTime > state.config.sessionTimeout) {
        // Only care about the time between keys in a typing session.
        keyTime = 0;
    }

    /* "A recordable typing session would be determined only once a threshold of thirty seconds of typing has been
     * reached and ending after a period of not typing for 60 seconds. (the recorded typing time for calculation would
     * include the 30 seconds for threshold and exclude the 60 seconds inactivity session end threshold)"
     */
    if ((state.keyCount > 1) && !keyTime) {
        var duration = state.lastKeyTime - state.sessionStart;
        if (duration > state.config.minSession && state.keyCount >= state.config.minSessionKeys) {
            // Record the typing rate for the last typing session.
            var data = {
                duration: duration,
                count: state.keyCount,
                corrections: state.specialCount
            };
            // Keys per minute.
            data.rate = Math.round(60000 / data.duration * data.count);
            that.logMetric("typing-session", data);
        }
        state.keyCount = 0;
    }

    if (!state.keyCount) {
        if (!specialKey) {
            // New typing session.
            state.keyCount = 1;
            state.specialCount = 0;
            state.sessionStart = timestamp;
        }
    } else if (specialKey) {
        state.specialCount++;
    } else {
        state.keyCount++;
    }

    state.lastKeyTime = timestamp;

    var record = {
        keyTime: keyTime
    };

    if (specialKey) {
        // Double-check that only certain keys are being recorded (it would be a serious blunder).
        if (windows.specialKeys[specialKey] && typeof (specialKey) === "string" && specialKey.length > 1) {
            record.key = windows.specialKeys[windows.specialKeys[specialKey]];
        }
    }

    that.logMetric("key-time", record);
};

/**
 * The keyboard hook callback. Called when a key is pressed or released.
 * https://msdn.microsoft.com/library/ms644985
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param code {Number} If less than zero, then don't process.
 * @param wparam {Number} The keyboard message. One of WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP
 * @param lparam {Number} A pointer to a KBDLLHOOKSTRUCT structure.
 * @return {Number} The return value of CallNextHookEx.
 */
windows.keyboardHook = function (that, code, wparam, lparam) {
    var togo;
    try {
        if (code >= 0 && wparam === windows.API_constants.WM_KEYUP) {
            var wanted = false;
            // For testing, allows the object to be passed directly rather than a ffi/ref struct.
            var kb = lparam.deref ? lparam.deref() : lparam;

            var specialKey = windows.specialKeys[kb.vkCode];

            // Ignore injected and Alt keys.
            var ignoreFlags = windows.API_constants.LLKHF_INJECTED | windows.API_constants.LLKHF_ALTDOWN;

            if ((kb.flags & ignoreFlags) === 0) {
                // If the key doesn't generate a character, then don't count it.
                wanted = specialKey || windows.user32.MapVirtualKeyW(kb.vkCode, windows.API_constants.MAPVK_VK_TO_CHAR);
                if (kb.vkCode === windows.API_constants.VK_LEFT) {
                    // Special case for the 'left' cursor key - if the last key was logged then log this key as it was
                    // probably used for correcting a mistake.
                    wanted = that.model.state.keyboard.lastKeyLogged;
                }
                if (wanted) {
                    // Process in the next tick, to allow this function to return soon.
                    process.nextTick(windows.recordKeyTiming, that, kb.time, specialKey);
                }

                that.model.state.keyboard.lastKeyLogged = wanted && !specialKey;
            }
        }
    } finally {
        // This needs to be called, or the key will be lost.
        togo = windows.user32.CallNextHookEx(0, code, wparam, lparam);
    }
    return togo;
};
