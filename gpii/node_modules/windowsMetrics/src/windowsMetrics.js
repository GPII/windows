/*
 * Captures metrics.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

require("../../WindowsUtilities/WindowsUtilities.js");
var ffi = require("ffi");

fluid.defaults("gpii.windowsMetrics", {
    gradeNames: ["fluid.modelComponent"],
    listeners: {
        "onCreate.startMetrics": "{that}.events.onStartMetrics",
        "onDestroy.stopMetrics": "{that}.events.onStopMetrics",
        "onStartMetrics.application": "{that}.startApplicationMetrics",
        "onStopMetrics.application": "{that}.stopApplicationMetrics",
        "onStartMetrics.keyboard": "{that}.startKeyboardMetrics",
        "onStopMetrics.keyboard": "{that}.stopKeyboardMetrics"
    },
    events: {
        "onStartMetrics": null,
        "onStopMetrics": null
    },
    invokers: {
        startApplicationMetrics: {
            funcName: "gpii.windows.startApplicationMetrics",
            args: ["{that}"]
        },
        stopApplicationMetrics: {
            funcName: "gpii.windows.stopApplicationMetrics",
            args: ["{that}"]
        },
        startKeyboardMetrics: {
            funcName: "gpii.windows.startKeyboardMetrics",
            args: ["{that}"]
        },
        stopKeyboardMetrics: {
            funcName: "gpii.windows.stopKeyboardMetrics",
            args: ["{that}"]
        }
    },
    model: {
        config: {
            application: {
                // Milliseconds to poll the active window.
                precision: 5000
            },
            keyboard: {
                // Number of records per log line (falsey for no limit).
                maxRecords: 500,
                // Minimum typing session time.
                minSession: 30,
                // The time a session will last with no activity.
                sessionTimeout: 60
            }
        },
        state: {
            application: {},
            keyboard: {
                keyboardHookHandle: null,
                lastKeyLogged: null,
                lastKeyTime: 0,
                times: []
            }
        }
    }
});

fluid.defaults("gpii.eventLog.windows", {
    components: {
        windowsMetrics: {
            type: "gpii.windowsMetrics"
        }
    }
});

fluid.defaults("gpii.installID.windows", {
    invokers: {
        getMachineID: "gpii.windows.getMachineID"
    }
});

/**
 * Gets the machine ID - something that uniquely identifies this machine.
 *
 * This relies on the MachineGUID, which is generated when Windows is installed or when a cloned image is deployed
 * in the recommended way using sysprep.
 *
 * @return {String} The machine ID.
 */
windows.getMachineID = function () {
    var machineID = windows.readRegistryKey(
        "HKEY_LOCAL_MACHINE", "64:SOFTWARE\\Microsoft\\Cryptography", "MachineGuid", "REG_SZ").value;
    return machineID;
};

/**
 * Check if a pid+exe file has been seen before. If not, log it as an application launch.
 * Called when a window has been activated.
 *
 * @param runningApplications {Object} The map of running applications (will be modified).
 * @param pid {Number} The process ID.
 * @param exePath {String} Path to the running executable file.
 */
windows.checkNewApplication = function (runningApplications, pid, exePath) {
    // pid might have been re-used.
    var oldExe = runningApplications[pid];
    var isNew = oldExe !== exePath;

    if (isNew) {
        var data = {
            exe: exePath
        };
        gpii.eventLog.log("metrics", "app-launch", data);

        if (!oldExe) {
            runningApplications.count++;
        }
        runningApplications[pid] = exePath;

        // It doesn't need to be constantly kept up to date, but trim it at a certain point.
        if (runningApplications.count > 30) {
            for (var key in runningApplications) {
                if (runningApplications.hasOwnProperty(key) && !isNaN(key)) {
                    if (!windows.isProcessRunning(key)) {
                        delete runningApplications[key];
                        runningApplications.count--;
                    }
                }
            }
        }
    }
};

/**
 * Begin monitoring the application launches and active windows.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startApplicationMetrics = function (that) {
    that.model.state.application = {
        active: true,
        runningApplications: {
            count: 0
        }
    };
    windows.checkActiveWindow(that, null);
};

windows.stopApplicationMetrics = function (that) {
    that.model.state.application.active = false;
    gpii.eventLog.logDeferred("activeWindowTime");
};

/**
 * Begin checking if the active Window has changed. It will continue to check while application.state.active is true.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param currentPid {Number} The PID owning the currently active window.
 */
windows.checkActiveWindow = function (that, currentPid) {
    var activePid = 0;
    var lastHwnd = 0;

    windows.waitForCondition(function () {
        // Get the process ID that owns the active Window.
        var hwnd = windows.user32.GetForegroundWindow();
        if (hwnd) {
            if (hwnd !== lastHwnd) {
                lastHwnd = hwnd;
            }
            activePid = windows.getWindowProcessId(hwnd);
        }
        return activePid !== currentPid || !that.model.state.application.active;
    }, {
        pollDelay: that.model.config.application.precision
    }).then(function () {
        if (that.model.state.application.active) {
            if (currentPid) {
                gpii.eventLog.logDeferred("activeWindowTime");
            }

            var exePath = windows.getProcessPath(activePid);

            // Also perform the "application launch" metric here. A process having its window activated implies it's
            // been launched.
            windows.checkNewApplication(that.model.state.application.runningApplications, activePid, exePath);

            var data = {
                exe: exePath
            };
            gpii.eventLog.defer("metrics", "app-active", data, "activeWindowTime");

            windows.checkActiveWindow(that, activePid);
        }
    });
};

/**
 * Starts the key stroke metrics.
 *
 * This sets up a low-level keyboard hook (WH_KEYBOARD_LL) that makes the system invoke a call-back whenever a key is
 * pressed or released. (https://msdn.microsoft.com/library/ms644959)
 *
 * This comes with the following limitations:
 * - The process needs a window-message loop. Fortunately, Electron has one so this means it will only work if running
 *   via gpii-app (otherwise this becomes an interesting way of disabling the keyboard).
 * - It can't see the keys that are destined to a window owned by a process running as Administrator (and rightly so).
 * - The hook call-back has to return in a timely manner - not only because it would cause key presses to lag, but also
 *   Windows will silently remove the hook if it times out. The time is unspecified (but it can be set in the registry).
 * - Anti-virus software may question this.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.startKeyboardMetrics = function (that) {
    windows.stopKeyboardMetrics(that);
    if (process.versions.electron) {
        // The callback needs to be referenced outside here otherwise the GC will pull the rug from beneath it.
        windows.keyboardHookCallback = ffi.Callback(
            windows.types.HANDLE, [windows.types.INT, windows.types.HANDLE, windows.KBDLLHookStructPointer],
            function (code, wparam, lparam) {
                windows.keyboardHook(that, code, wparam, lparam);
            });

        var hModule = windows.kernel32.GetModuleHandleW(0);
        that.model.state.keyboard.keyboardHookHandle =
            windows.user32.SetWindowsHookExW(13, windows.keyboardHookCallback, hModule, 0);

        if (!that.model.state.keyboard.keyboardHookHandle) {
            windows.keyboardHookCallback = null;
            fluid.fail("SetWindowsHookExW did not work. win32 error: " + windows.kernel32.GetLastError());
        }

        that.model.state.keyboard.maxRecords = that.model.config.keyboard.maxRecords;
        that.model.state.config = that.model.config;
    } else {
        // The keyboard hook's ability to work is a side-effect of running with electron.
        fluid.log(fluid.logLevel.WARN, "Keyboard metrics not available without Electron.");
    }
};

/**
 * Disables the key stroke metrics.
 *
 * Removes the low-level keyboard hook from the system, and sends the last timings to the log.
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 */
windows.stopKeyboardMetrics = function (that) {
    // remove the keyboard hook
    if (that.model.state.keyboard.keyboardHookHandle) {
        windows.user32.UnhookWindowsHookEx(that.model.state.keyboard.keyboardHookHandle);
    }
    that.model.state.keyboard.keyboardHookHandle = null;
    that.model.state.keyboard.keyboardHookCallback = null;
    // flush the log.
    if (that.model.state.keyboard.times) {
        windows.logKeyTimings(that.model.state.keyboard.times, that.model.config.keyboard.maxRecords);
        that.model.state.keyboard.times = [];
    }
};

/**
 * Keys that have a special meaning.
 */
windows.specialKeys = fluid.freezeRecursive((function () {
    var special = {
        "BS": windows.API_constants.VK_BACK,
        "DEL": windows.API_constants.VK_DELETE,
        "ESC": windows.API_constants.VK_ESCAPE,
        "LEFT": windows.API_constants.VK_LEFT
    };

    // Swap to ease look-ups.
    fluid.each(special, function (value, key) {
        special[value] = key;
    });

    return special;
})());

/**
 * Sends the key timings to the log.
 *
 * @param times {Array} Array of key times.
 * @param maxRecords {Number} Maximum key times per log entry.
 */
windows.logKeyTimings = function (times, maxRecords) {
    maxRecords = maxRecords || times.length;
    for (var offset = 0; offset < times.length; offset += maxRecords) {
        // Split the list of timings into chunks.
        var data = {
            times: times.slice(offset, offset + maxRecords)
        };
        gpii.eventLog.log("metrics", "key-times", data);
    }
};

/**
 * Records the timing of a key press. This only logs the time between two keys being pressed, and not the actual
 * value of the key (unless it's a special key). Characters aren't being recorded.
 *
 * @param state {Object} The keyboard metrics state.
 * @param timestamp {Number} Milliseconds since a fixed point in time.
 * @param specialKey {String} The value key, if it's a special key.
 */
windows.recordKeyTiming = function (state, timestamp, specialKey) {
    if (!state.times) {
        state.times = [];
    }

    // The time since the last key press
    var keyTime = state.lastKeyTime ? timestamp - state.lastKeyTime : 0;

    /* "A recordable typing session would be determined only once a threshold of thirty seconds of typing has been
     * reached and ending after a period of not typing for 60 seconds. (the recorded typing time for calculation would
     * include the 30 seconds for threshold and exclude the 60 seconds inactivity session end threshold)"
     */
    if ((state.times.length === 1) && (keyTime > state.config.minSession)) {
        // This key was hit after the minimum session time, so ignore the last key.
        state.times = [];
    } else if ((state.times.length > 1) && (keyTime > state.config.sessionTimeout)) {
        // Store the current session, and begin a new one.
        windows.logKeyTimings(state.times, state.maxRecords);
        state.times = [];
    }

    state.lastKeyTime = timestamp;

    var record = {
        t: keyTime
    };

    if (specialKey) {
        // Double-check that only certain keys are being recorded (it would be a serious blunder).
        if (windows.specialKeys[specialKey] && typeof (specialKey) === "string" && specialKey.length > 1) {
            record.key = windows.specialKeys[windows.specialKeys[specialKey]];
        }
    }

    state.times.push(record);
    if (state.maxRecords && state.times.length >= state.maxRecords) {
        windows.logKeyTimings(state.times, state.maxRecords);
        state.times = [];
    }
};

/**
 * The keyboard hook callback. Called when a key is pressed or released.
 * https://msdn.microsoft.com/library/ms644985
 *
 * @param that {Component} The gpii.windowsMetrics instance.
 * @param code {Number} If less than zero, then don't process.
 * @param wparam {Number} The keyboard message. One of WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP
 * @param lparam {Number} A pointer to a KBDLLHOOKSTRUCT structure.
 * @return {Number} The return value of CallNextHookEx.
 */
windows.keyboardHook = function (that, code, wparam, lparam) {
    var togo;
    try {
        if (code >= 0 && wparam === windows.API_constants.WM_KEYUP) {
            var wanted = false;
            // For testing, allows the object to be passed directly rather than a ffi/ref struct.
            var kb = lparam.deref ? lparam.deref() : lparam;

            var specialKey = windows.specialKeys[kb.vkCode];

            // Ignore injected and Alt keys.
            var ignoreFlags = windows.API_constants.LLKHF_INJECTED | windows.API_constants.LLKHF_ALTDOWN;

            if ((kb.flags & ignoreFlags) === 0) {
                // If the key doesn't generate a character, then don't count it.
                wanted = specialKey || windows.user32.MapVirtualKeyW(kb.vkCode, windows.API_constants.MAPVK_VK_TO_CHAR);
                if (kb.vkCode === windows.API_constants.VK_LEFT) {
                    // Special case for the 'left' cursor key - if the last key was logged then log this key as it was
                    // probably used for correcting a mistake.
                    wanted = that.model.state.keyboard.lastKeyLogged;
                }
                if (wanted) {
                    // Process in the next tick, to allow this function to return soon.
                    process.nextTick(windows.recordKeyTiming, that.model.state.keyboard, kb.time, specialKey);
                }

                that.model.state.keyboard.lastKeyLogged = wanted && !specialKey;
            }
        }
    } finally {
        // This needs to be called, or the key will be lost.
        togo = windows.user32.CallNextHookEx(0, code, wparam, lparam);
    }
    return togo;
};
