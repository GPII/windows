/* USB user listener.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    ffi = require("ffi"),
    path = require("path"),
    fs = require("fs");

var gpii = fluid.registerNamespace("gpii");

require("../../WindowsUtilities/WindowsUtilities.js");

fluid.registerNamespace("gpii.windows.userListeners");
var windows = gpii.windows;

// Windows specific mixin for the usb listener
fluid.defaults("gpii.userListeners.usb.windows", {
    gradeNames: ["fluid.component"],
    members: {
        proximity: true,
        listenerName: "USB"
    },
    invokers: {
        startListener: {
            funcName: "gpii.windows.userListeners.startUSBListener",
            args: ["{that}"]
        },
        stopListener: {
            funcName: "gpii.windows.userListeners.stopUSBListener",
            args: ["{that}"]
        }
    }
});

/**
 * Start the USB user listener.
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 * @return {Promise} A resolved promise if it succeeds.
 */
gpii.windows.userListeners.startUSBListener = function (that) {
    var promise = fluid.promise();
    gpii.windows.userListeners.createMessageWindow(that);
    promise.resolve();
    return promise;
};

/**
 * Stop the USB user listener
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 * @returns {Promise} Resolved with a value of true if the listener was stopped, false if it wasn't running.
 */
gpii.windows.userListeners.stopUSBListener = function (that) {
    var promise = fluid.promise();
    gpii.windows.userListeners.destroyMessageWindow(that);
    promise.resolve(true);
    return promise;
};

/**
 * The window procedure for the window.
 *
 * WindowProc: https://msdn.microsoft.com/library/ms633573
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 * @param hwnd {number} Window handle.
 * @param msg {number} The window message.
 * @param wParam {number} Message parameter.
 * @param lParam {number} Message parameter.
 */
gpii.windows.userListeners.windowProc = function (that, hwnd, msg, wParam, lParam) {
    switch (msg) {
    case windows.API_constants.WM_DEVICECHANGE:
        switch (wParam) {
        // https://msdn.microsoft.com/library/aa363205
        case windows.API_constants.DBT_DEVICEARRIVAL:
        // https://msdn.microsoft.com/library/aa363208
        case windows.API_constants.DBT_DEVICEREMOVECOMPLETE:

            var arrived = wParam === windows.API_constants.DBT_DEVICEARRIVAL;

            var hdr = new windows.DEV_BROADCAST_HDR(lParam.reinterpret(windows.DEV_BROADCAST_HDR.size));
            if (hdr.deviceType === windows.API_constants.DBT_DEVTYP_VOLUME) {
                var DBTF_NET = 0x2;
                var volume = new windows.DEV_BROADCAST_VOLUME(lParam.reinterpret(windows.DEV_BROADCAST_VOLUME.size));

                // Only local drives.
                if (!(volume.flags & DBTF_NET)) {
                    // Each bit represents a drive letter that's arrived/removed by this device - more than one could
                    // be set.
                    var bitmask = volume.unitMask & 0x3FFFFFF; // (2^26)-1
                    var letter = "A".charCodeAt(0);
                    for (; bitmask; bitmask >>= 1, letter++) {
                        if (bitmask & 1) {
                            var dir = String.fromCharCode(letter) + ":\\";
                            process.nextTick(gpii.windows.userListeners.usbMounted, that, dir, arrived);
                        }
                    }
                }
            }
            break;

        default:
            break;
        }

        break;
    default:
        break;
    }

    return windows.user32.DefWindowProcW(hwnd, msg, wParam, lParam);
};

/**
 * A device has been added or removed. A single device may contain more than one volume - this is called for each one.
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 * @param directory {string} The volume.
 * @param arrived {boolean} true if it's been added, false if removed.
 */
gpii.windows.userListeners.usbMounted = function (that, directory, arrived) {
    if (arrived) {
        that.events.onMount.fire(that, directory);
    } else {
        that.events.onUnmount.fire(that, directory);
    }
};

/**
 * Read the token file form the usb device.
 *
 * @param directory
 * @return {*}
 */
gpii.windows.userListeners.readUSBDevice = function (directory) {
    var promise = fluid.promise();
    var tokenFile = path.join(directory, ".gpii-user-token.txt");
    console.log("Token file:", tokenFile);
    fs.readFile(tokenFile, "utf8", function (err, data) {
        if (err) {
            console.log(err);
            promise.reject(err);
        } else {
            var token = data.trim();
            console.log("Token:", token);
            promise.resolve(token);
        }
    });

    return promise;
};

/**
 * Polls for messages - only required if not running under electron.
 */
gpii.windows.userListeners.messagePump = function () {

    var loop = function () {
        // sizeof(MSG) = 48 on 64-bit, 28 on 32-bit.
        var msg = new Buffer(process.arch === "x64" ? 48 : 28);

        // Unable to use GetMessage because it blocks, and can't call via .async because it needs to be in the same
        // thread as the window.
        while (windows.user32.PeekMessageW(msg.ref(), 0, 0, 0, 1)) {
            windows.user32.TranslateMessage(msg.ref());
            windows.user32.DispatchMessageW(msg.ref());
        }

        setTimeout(loop, 2000);
    };
    loop();
};

/**
 * Creates a window whose only purpose is to receive the WM_DEVICECHANGE message that Windows broadcasts when there's
 * a change to the device list.
 *
 * The window has no visibility - it just exists.
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 */
gpii.windows.userListeners.createMessageWindow = function (that) {

    if (!process.versions.electron) {
        gpii.windows.userListeners.messagePump();
    }

    var className = windows.stringToWideChar("gpii-usb-listener");

    // Create the Window Class for the window
    var cls = new windows.WNDCLASSW();
    cls.ref().fill(0);

    cls.lpszClassName = className;

    // Create a pointer to the window procedure function.
    cls.lpfnWndProc = ffi.Callback(windows.types.HANDLE,
        [windows.types.HANDLE, windows.types.UINT, windows.types.UINT, windows.types.PVOID],
        // WindowProc: https://msdn.microsoft.com/library/ms633573
        function (hwnd, msg, wParam, lParam) {
            return gpii.windows.userListeners.windowProc(that, hwnd, msg, wParam, lParam);
        }
    );

    // Keep a reference to the function pointer, otherwise the GC will free it.
    gpii.windows.userListeners.windowProcPointer = function () {
        cls.lpfnWndProc();
    };

    var result = windows.user32.RegisterClassW(cls.ref());
    if (!result) {
        fluid.fail("RegisterClass failed");
    }

    // Create the Window.
    that.messageWindowHandle = windows.user32.CreateWindowExW(0, className, className, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    if (!that.messageWindowHandle) {
        fluid.fail("CreateWindowEx failed");
    }

};

/**
 * Destroys the window created by createMessageWindow.
 *
 * @param that {Component} The gpii.userListeners.usb instance.
 * @return {boolean} false on failure.
 */
gpii.windows.userListeners.destroyMessageWindow = function (that) {
    var success = true;
    if (that.messageWindowHandle) {
        success = !!windows.user32.DestroyWindow(that.messageWindowHandle);
        that.messageWindowHandle = null;
        var className = windows.stringToWideChar("gpii-usb-listener");
        windows.user32.UnregisterClassW(className, 0);
        gpii.windows.userListeners.windowProcPointer = null;
    }
    return success;
};
