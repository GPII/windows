/*
 * SPI High-contrast completion. Waits for the completion of the SPI_SETHIGHCONTRAST call.
 *
 * Experimentation has uncovered an undocumented occurrence when the high-contrast is changed
 * via the SPI call, where Windows executes %WINDIR%\system32\sethc.exe to perform the actual
 * work of changing the contrast. Investigations have shown that this executable may be
 * called with parameters "10", "11", "100", or "101" (numbers < 100 turn HC off).
 *
 * It has been noticed that the work behind setting SPI_SETHIGHCONTRAST is complete when
 * this process terminates, so this script checks for the existence of this process and
 * does not return until the has ended.
 *
 * There is a chance that by the time this script is ran the sethc.exe process has already
 * exited. This is assumed to be the case when the process isn't found, as the sethc
 * process has (according to testing) already started by the time the call to SPI returns.
 *
 * The CreateToolhelp32Snapshot and Process32First/Next functions are used to enumerate
 * the running processes, and WaitForSingleObject is used on the handle of the matching
 * process to block until it dies.
 *
 * The recommended way of determining whether a call to SystemParametersInfo has succeeded
 * is to wait for the WM_SETTINGCHANGE window message to be broadcast (SPI_SETHIGHCONTRAST
 * causes this message to be sent 3 times). This introduced other problems, since this
 * message is sent under other conditions, the order of messages isn't guaranteed, and
 * the acceptance tests cause many of these messages to be sent.
 *
 * There is a third method, which involves passing SPIF_UPDATEINIFILE and SPIF_SENDCHANGE
 * to the SPI function. This seems to cause SPI to block until the message has been
 * processed [requires further testing to validate]. This causes the setting to be
 * persist in the user's profile, making this solution less desirable.
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */
"use strict";

if (!process.env.GPII_CHILD_PROCESS) {
    /* The environment variable is used as a safety check, in case of accidental inclusion */
    console.error(__filename + " should be executed as a child process");
    return;
}

var windows = require("../../WindowsUtilities/WindowsUtilitiesCore.js").windows;
var ref = require("ref");


/**
 * Finds a running process with the given name.
 *
 * @param filename The exe file name to search for.
 * @returns {windows.types.HANDLE} Handle to the process.
 */
windows.findProcess = function (filename) {

    // Get a snapshot of the processes.
    var hSnapShot = windows.kernel32.CreateToolhelp32Snapshot(windows.API_constants.TH32CS_SNAPPROCESS, null);
    if (hSnapShot === windows.API_constants.INVALID_HANDLE_VALUE) {
        console.error("CreateToolhelp32Snapshot failed. Win32 error: " + windows.GetLastError());
        return null;
    }

    try {
        // Create the structure for the return parameter of Process32First/Next.
        var pEntry = new windows.PROCESSENTRY32();
        pEntry.dwSize = windows.PROCESSENTRY32.size;

        // Enumerate the processes.
        var hRes = windows.kernel32.Process32First(hSnapShot, pEntry.ref());
        while (hRes) {
            var buf = new Buffer(pEntry.szExeFile);
            var processName = ref.readCString(buf, 0);

            if (processName === filename) {
                // Found a match; Get return a handle to the process.
                return windows.kernel32.OpenProcess(windows.API_constants.SYNCHRONIZE, 0, pEntry.th32ProcessID);
            }

            hRes = windows.kernel32.Process32Next(hSnapShot, pEntry.ref());
        }
    } finally {
        // Make sure the snapshot is closed.
        if (hSnapShot) {
            windows.kernel32.CloseHandle(hSnapShot);
        }
    }

    // Process has not been found.
    return null;
};

/**
 * Waits for an object's state to become signalled. For a process, it is "signalled" when it terminates.
 *
 * @param hHandle The handle to an object.
 * @returns {boolean} true
 */
windows.waitForObject = function (hHandle) {
    // Waits for the process to end, timing out at 2 minutes.
    var wait = windows.kernel32.WaitForSingleObject(hHandle, 120000);

    switch (wait) {
    case windows.API_constants.WAIT_OBJECT_0:
        // Success
    case windows.API_constants.WAIT_TIMEOUT:
        // Timeout is a "success", because the process no longer needs to be waited upon.
        return true;
    default:
        // The wait failed.
        return false;
    }
};

/**
 * Waits for a process to terminate, returning when there are no matching processes running.
 *
 * @param filename The executable.
 */
windows.waitForProcessTermination = function (filename) {

    var hProcess;

    // Continue while there there is a matching process.
    while ((hProcess = windows.findProcess(filename)) !== null) {
        try {
            var waited = false;
            if (hProcess !== ref.NULL) {
                waited = windows.waitForObject(hProcess);
            }

            if (!waited) {
                // Either the process handle couldn't be opened or waited upon.
                // When this happens just pause the thread for a moment to allow other things to happen,
                // and continue polling for a matching process.
                windows.kernel32.Sleep(1000);
            }
        }
        finally {
            windows.kernel32.CloseHandle(hProcess);
        }
    }
};

// Allow the process name to be overridden
var sethcProcess = process.env.GPII_SETHC_EXE || "sethc.exe";

windows.waitForProcessTermination(sethcProcess);
