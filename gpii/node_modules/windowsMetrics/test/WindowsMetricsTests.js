/*
 * eventLog Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal"),
    fs = require("fs"),
    os = require("os"),
    path = require("path"),
    readline = require("readline"),
    child_process = require("child_process");

require("../../processHandling/processHandling.js");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.metrics");

require("../index.js");

var teardowns = [];

jqUnit.module("gpii.tests.metrics", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

fluid.logObjectRenderChars = 0xffff;

// Wrap the gpii.windowsMetrics to disable auto-starting the metrics capturing.
fluid.defaults("gpii.tests.metrics.windowsMetricsWrapper", {
    gradeNames: ["fluid.component", "gpii.windowsMetrics", "gpii.eventLog", "gpii.lifecycleManager"],
    listeners: {
        "onCreate.startMetrics": null,
        "onDestroy.stopMetrics": null
    }
});

// Tests logKeyTimings, splitting of key timings into separate log entries.
gpii.tests.metrics.logKeyTimingsTests = fluid.freezeRecursive([
    {   // Single record
        input: {
            times: [{t: 10}],
            maxRecords: 1
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 10} ] }
        }
    },
    {   // Multiple records, 1 line each
        input: {
            times: [{t: 20}, {t: 21}, {t: 22}],
            maxRecords: 1
        },
        expect: [
            {
                module: "metrics",
                event: "key-times",
                data: { times: [{t: 20}] }
            },
            {
                module: "metrics",
                event: "key-times",
                data: { times: [{t: 21}] }
            },
            {
                module: "metrics",
                event: "key-times",
                data: { times: [{t: 22}] }
            }
        ]
    },
    {   // 2 sets of 3 records
        input: {
            times: [{t: 30}, {t: 31}, {t: 32}, {t: 33}, {t: 34}, {t: 35}],
            maxRecords: 3
        },
        expect: [
            {
                module: "metrics",
                event: "key-times",
                data: {
                    times: [{t: 30}, {t: 31}, {t: 32}]
                }
            },
            {
                module: "metrics",
                event: "key-times",
                data: {
                    times: [{t: 33}, {t: 34}, {t: 35}]
                }
            }
        ]
    },
    {
        // Imperfect number
        input: {
            times: [{t: 40}, {t: 41}, {t: 42}, {t: 43}, {t: 44}],
            maxRecords: 3
        },
        expect: [
            {
                module: "metrics",
                event: "key-times",
                data: {
                    times: [{t: 40}, {t: 41}, {t: 42}]
                }
            },
            {
                module: "metrics",
                event: "key-times",
                data: {
                    times: [{t: 43}, {t: 44}]
                }
            }
        ]
    },
    {
        // No cut-off
        input: {
            times: [{t: 50}, {t: 51}, {t: 52}, {t: 53}, {t: 54}, {t: 55}, {t: 56}, {t: 57}, {t: 58}, {t: 59}],
            maxRecords: null
        },
        expect: [
            {
                module: "metrics",
                event: "key-times",
                data: {
                    times: [{t: 50}, {t: 51}, {t: 52}, {t: 53}, {t: 54}, {t: 55}, {t: 56}, {t: 57}, {t: 58}, {t: 59}]
                }
            }
        ]
    }
]);

gpii.tests.metrics.defaultKeyboardConfig = fluid.freezeRecursive();

// Tests for recordKeyTiming: key presses
gpii.tests.metrics.recordKeyTimingKeyTests = fluid.freezeRecursive({
    defaultState: {
        times: []
    },
    defaultConfig: {
        minSession: 0xffffff,
        sessionTimeout: 0xffffff,
        maxRecords: 1000
    },
    testData: [
        {   // First key press
            state: {},
            input: {
                timestamp: 1,
                key: undefined
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0}]}
            }
        },
        {   // Key press, existing state
            state: null,
            input: {
                timestamp: 1,
                key: undefined
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0}]}
            }
        },
        {   // Key press, existing state with previous keys
            state: {
                times: [{t:10}, {t:11}, {t:12} ]
            },
            input: {
                timestamp: 1,
                key: undefined
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 10}, {t: 11}, {t: 12}, {t: 0} ]}
            }
        },
        {   // Key press, existing state with previous keys and lastKeyTime set
            state: {
                times: [{t:20}, {t:21}, {t:22}],
                lastKeyTime: 100
            },
            input: {
                timestamp: 200,
                key: undefined
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 20}, {t: 21}, {t: 22}, {t: 100} ]}
            }
        },
        {   // special key
            state: null,
            input: {
                key: "BS"
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: "BS"}]}
            }
        },
        // Test that non-special keys don't get leaked.
        {   // not a special key (letter)
            state: null,
            input: {
                key: "A"
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        },
        {   // not a special key (symbol)
            state: null,
            input: {
                key: "!"
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        },
        {   // not a special key (numeric string)
            state: null,
            input: {
                key: "1"
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        },
        {   // not a special key (number)
            state: null,
            input: {
                key: 0x41
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        },
        {   // not a special key (string)
            state: null,
            input: {
                key: "ABC"
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        },
        {   // not a special key (virtual key code of a special key)
            state: null,
            input: {
                key: gpii.windows.API_constants.VK_ESCAPE
            },
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0, key: fluid.NO_VALUE }]}
            }
        }
    ]
});

// Tests for recordKeyTiming: typing sessions
gpii.tests.metrics.typingSessionTests = fluid.freezeRecursive({
    defaultState: {
        times: []
    },
    defaultConfig: {
        minSession: 30,
        sessionTimeout: 60,
        maxRecords: 1000
    },
    testData: [
        {   // Single session
            state: {
                times: []
            },
            input: [
                { timestamp: 1 },
                { timestamp: 2 },
                { timestamp: 4 },
                { timestamp: 8 }
            ],
            expect: {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0}, {t: 1}, {t: 2}, {t: 4} ]}
            }
        },
        {   // Two sessions
            state: {
                times: []
            },
            input: [
                {timestamp: 1},
                {timestamp: 2},
                {timestamp: 3},
                {timestamp: 4},
                {timestamp: 200},
                {timestamp: 202},
                {timestamp: 204},
                {timestamp: 206}
            ],
            expect: [{
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0}, {t: 1}, {t: 1}, {t: 1}]}
            }, {
                module: "metrics",
                event: "key-times",
                data: {times: [{t: 0}, {t: 2}, {t: 2}, {t: 2}]}
            }]
        }
    ]
});

// Tests for keyboardHook.
gpii.tests.metrics.keyboardHookTests = fluid.freezeRecursive([
    {   // Invalid nCode.
        input: {
            nCode: -1,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 1,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // First key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 150,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: fluid.NO_VALUE} ] }
        }
    },
    {   // Next key (50ms later).
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 50, key: fluid.NO_VALUE} ] }
        }
    },
    {   // Non-special non-input key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_HOME,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // Special key: back space.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_BACK,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: "BS"} ] }
        }
    },
    {   // Special key: delete.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_DELETE,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: "DEL"} ] }
        }
    },
    {   // Special key: escape.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_ESCAPE,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: "ESC"} ] }
        }
    },
    {   // Special key: left arrow. Expect nothing, because this only logs if hit after a character key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_LEFT,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // Normal key: 'X'
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "X".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: fluid.NO_VALUE } ] }
        }
    },
    {   // Special key: left arrow.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_LEFT,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-times",
            data: { times: [ {t: 0, key: "LEFT"} ] }
        }
    }
]);

/**
 * Configure a log file that's just used for testing.
 * The file will be deleted automatically after the current test completes.
 *
 * @return {String} The path of the log file.
 */
gpii.tests.metrics.setLogFile = function () {
    var logFile = os.tmpdir() + "/gpii-test-eventLog-" + Date.now();
    teardowns.push(function () {
        fs.unlinkSync(logFile);
    });
    gpii.eventLog.logFilePath = logFile;
    return logFile;
};

/**
 * Check if all properties of expected are also in subject and are equal, ignoring any extra ones in subject.
 *
 * @param subject {Object} The object to check against
 * @param expected {Object} The object containing the values to check for.
 * @param maxDepth {Number} [Optional] How deep to check.
 */
gpii.tests.metrics.deepMatch = function (subject, expected, maxDepth) {
    var match = false;
    if (maxDepth < 0) {
        return false;
    } else if (!maxDepth && maxDepth !== 0) {
        maxDepth = fluid.strategyRecursionBailout;
    }

    if (!subject) {
        return subject === expected;
    }

    for (var prop in expected) {
        if (expected.hasOwnProperty(prop)) {
            var exp = expected[prop];
            if (fluid.isMarker(exp, fluid.VALUE)) {
                // match any value
                match = subject.hasOwnProperty(prop);
            } else if (fluid.isMarker(exp, fluid.NO_VALUE)) {
                // match no value
                match = !subject.hasOwnProperty(prop);
            } else if (fluid.isPrimitive(exp)) {
                match = subject[prop] === exp;
            } else {
                match = gpii.tests.metrics.deepMatch(subject[prop], exp, maxDepth - 1);
            }
            if (!match) {
                break;
            }
        }
    }

    return match;
};

/**
 * Checks the log file for some lines that are expected. (see deepMatch for the matching rules)
 *
 * @param logFile {String} The file to read.
 * @param expected {Object[]} An array of log items to search for (in order of how they should be found).
 * @returns {Promise} Resolves when all expected lines where found, or rejects if the end of the log is reached first.
 */
gpii.tests.metrics.expectLogLines = function (logFile, expected) {
    jqUnit.expect(expected.length);
    var promise = fluid.promise();
    var reader = readline.createInterface({
        input: fs.createReadStream(logFile)
    });

    var remainingLines = [];

    var index = 0;
    var currentExpected = expected[index];
    var complete = false;

    reader.input.on("error", function (err) {
        jqUnit.fail(err);
    });

    reader.on("line", function (line) {
        if (complete) {
            return;
        }

        var obj = JSON.parse(line);
        remainingLines.push(obj);

        if (gpii.tests.metrics.deepMatch(obj, currentExpected)) {
            jqUnit.assert("Found a matching line");
            index++;
            remainingLines = [];
            if (index >= expected.length) {
                complete = true;
                reader.close();
            } else {
                currentExpected = expected[index];
            }
        }
    });

    reader.on("close", function () {
        if (complete) {
            promise.resolve();
        } else {
            fluid.log("No matching line (index=" + index + "):", currentExpected);
            fluid.log("Remaining log lines:", remainingLines);
            promise.reject("Unable to find matching log entry " + index);
        }
    });

    return promise;
};

/**
 * Test the application metrics - app launches and window times.
 */
jqUnit.asyncTest("Testing application metrics", function () {
    jqUnit.expect(3);

    var logFile = gpii.tests.metrics.setLogFile();

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    windowsMetrics.model.config.application.precision = 100;

    // Start monitoring.
    windowsMetrics.startApplicationMetrics();

    // Start notepad.exe, in order to set the active window to something predictable.
    var exePath = path.join(process.env.SystemRoot, "System32\\notepad.exe");
    var child = child_process.spawn(exePath);
    // Get the "real" path the process is running as - on 32-bit node "System32" is really "SysWOW32"
    var runningPath = gpii.windows.getProcessPath(child.pid);

    // Get the currently active window. The only time there isn't an active window is when the focus is changing.
    var originalWindow = gpii.windows.user32.GetForegroundWindow();
    jqUnit.assertTrue("The should already be an active window", !!originalWindow);
    var originalExe = gpii.windows.getProcessPath(gpii.windows.getWindowProcessId(originalWindow));

    gpii.windows.waitForCondition(function () {
        // Wait for the new window to become active.
        var currentWindow = gpii.windows.user32.GetForegroundWindow();
        return originalWindow !== currentWindow;
    }).then(function () {
        // Window should now be active. Kill it after giving the metrics routine a chance to notice it.
        jqUnit.assert("test application should have been focused.");
        setTimeout(function () {
            windowsMetrics.stopApplicationMetrics();
            child.kill();
        }, 500);
    }, function () {
        jqUnit.fail("Timed out waiting for test window to focus.");
        child.kill();
    });

    var expectedLines = [
        // The window that was already active.
        {
            module: "metrics",
            event: "app-launch",
            data: {
                exe: originalExe
            }
        },
        {
            module: "metrics",
            event: "app-active",
            data: {
                exe: originalExe,
                duration: fluid.VALUE
            }
        },
        // The test window.
        {
            module: "metrics",
            event: "app-launch",
            data: {
                exe: runningPath
            }
        },
        {
            module: "metrics",
            event: "app-active",
            data: {
                exe: runningPath,
                duration: fluid.VALUE
            }
        }
    ];

    child.on("close", function () {
        setTimeout(function () {
            // Check the expected lines are in the log file.
            gpii.tests.metrics.expectLogLines(logFile, expectedLines).then(function () {
                jqUnit.assert("All expected lines should be found.");
                jqUnit.start();
            }, function (err) {
                jqUnit.fail(err);
            });
        }, 500);
    });
});

jqUnit.asyncTest("Testing keyboard metrics: logKeyTimings", function () {
    jqUnit.expect(1);

    var logFile = gpii.tests.metrics.setLogFile();
    var testData = gpii.tests.metrics.logKeyTimingsTests;
    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    var expectedLines = [];

    fluid.each(testData, function (test) {
        windowsMetrics.model.state.keyboard.times = test.input.times;
        windowsMetrics.model.config.keyboard.maxRecords = test.input.maxRecords;
        gpii.windows.logKeyTimings(windowsMetrics);
        expectedLines.push.apply(expectedLines, fluid.makeArray(test.expect));
    });

    gpii.tests.metrics.expectLogLines(logFile, expectedLines).then(function () {
        jqUnit.assert("All expected lines should be found.");
        jqUnit.start();
    }, function (err) {
        jqUnit.fail(err);
    });
});

/**
 * Test recordKeyTiming
 * @param theTests
 */
gpii.tests.metrics.recordKeyTimingTests = function (theTests) {
    jqUnit.expect(1);
    var logFile = gpii.tests.metrics.setLogFile();

    var testData = theTests.testData;
    var defaultState = theTests.defaultState;
    var defaultConfig = theTests.defaultConfig;

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    var expectedLines = [];

    fluid.each(testData, function (test) {
        var state = fluid.copy(test.state || defaultState);
        state.config = fluid.copy(state.config || defaultConfig);
        windowsMetrics.model.state.keyboard = state;
        windowsMetrics.model.config.keyboard = state.config;

        // "press" the keys
        fluid.each(fluid.makeArray(test.input), function (input) {
            gpii.windows.recordKeyTiming(windowsMetrics, input.timestamp, input.key);
        });

        // flush the log
        gpii.windows.logKeyTimings(windowsMetrics);

        expectedLines.push.apply(expectedLines, fluid.makeArray(test.expect));
    });

    gpii.tests.metrics.expectLogLines(logFile, expectedLines).then(function () {
        jqUnit.assert("All expected lines should be found.");
        jqUnit.start();
    }, function (err) {
        jqUnit.fail(err);
    });
};

jqUnit.asyncTest("Testing keyboard metrics: recordKeyTiming (key presses)", function () {
    gpii.tests.metrics.recordKeyTimingTests(gpii.tests.metrics.recordKeyTimingKeyTests);
});

jqUnit.asyncTest("Testing keyboard metrics: recordKeyTiming (typing sessions)", function () {
    gpii.tests.metrics.recordKeyTimingTests(gpii.tests.metrics.typingSessionTests);
});

jqUnit.asyncTest("Testing keyboard metrics: keyboardHook", function () {
    jqUnit.expect(1);

    var logFile = gpii.tests.metrics.setLogFile();

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    // Disable typing sessions
    windowsMetrics.model.config.keyboard.minSession = windowsMetrics.model.config.keyboard.sessionTimeout = -1 >>> 0;
    windowsMetrics.model.config.keyboard.maxRecords = 1;
    windowsMetrics.startKeyboardMetrics();

    var testData = gpii.tests.metrics.keyboardHookTests;

    var expectedLines = [];
    var currentTest = null;
    var nextHookReturn = 0;

    // Mock CallNextHookEx - this must be called for every call to the hook handler with the same parameters.
    var origCallNextHookEx = gpii.windows.user32.CallNextHookEx;
    gpii.windows.user32.CallNextHookEx = function (hhk, nCode, wParam, lParam) {
        // hhk is ignored by windows, but check it's 0 because that's the code's intended value.
        jqUnit.assertEquals("CallNextHookEx should be called with the correct hhk", 0, hhk);
        jqUnit.assertEquals("CallNextHookEx must be called with the correct nCode", currentTest.nCode, nCode);
        jqUnit.assertEquals("CallNextHookEx must be called with the correct wParam", currentTest.wParam, wParam);
        jqUnit.assertDeepEq("CallNextHookEx must be called with the correct lParam", currentTest.lParam, lParam);
        return ++nextHookReturn;
    };
    teardowns.push(function () {
        gpii.windows.user32.CallNextHookEx = origCallNextHookEx;
    });

    // expect the CallNextHookEx calls (1 assert for each param + the return).
    jqUnit.expect(testData.length * 5);

    fluid.each(testData, function (test) {
        currentTest = test.input;
        var ret = gpii.windows.keyboardHook.call(
            null, windowsMetrics, currentTest.nCode, currentTest.wParam, currentTest.lParam);

        jqUnit.assertEquals("keyboardHook must return the result of CallNextHookEx", nextHookReturn, ret);

        expectedLines.push.apply(expectedLines, fluid.makeArray(test.expect));
    });

    // The keys are put in the log in the next tick (to allow the hook handler to return quickly).
    setImmediate(function () {
        windowsMetrics.stopKeyboardMetrics();
        gpii.tests.metrics.expectLogLines(logFile, expectedLines).then(function () {
            jqUnit.assert("All expected lines should be found.");
            jqUnit.start();
        }, function (err) {
            jqUnit.fail(err);
        });

    });
});

