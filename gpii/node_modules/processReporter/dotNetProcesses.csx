/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string argv = "";
    public string state = "";
}

public class Startup
{
    public async Task<object> Invoke(dynamic input)
    {
        Process[] processes;
        Process aProcess;
        ProcInfo aProcInfo;
        object[] output;
        
        processes = Process.GetProcesses();
        output = new object[processes.Length];
        for (int i = 0; i < processes.Length; i++) {
            aProcess = processes[i];
            aProcInfo = new ProcInfo();
            aProcInfo.pid = aProcess.Id;
            aProcInfo.command = aProcess.ProcessName;

            ProcessThreadCollection threads = aProcess.Threads;
            // Only use the first thread's state.
            // Also, map Windows thread states to Linux-y process states -- may
            // not be correct thing to do.
            //
            switch (aProcess.Threads[0].ThreadState) {
                case ThreadState.Running:
                    aProcInfo.state = "Running";
                    break;
                
                case ThreadState.Wait:
                case ThreadState.Initialized:
                case ThreadState.Ready:
                case ThreadState.Standby:
                case ThreadState.Transition:
                    aProcInfo.state = "Sleeping";
                    break;
            
                case ThreadState.Terminated:
                case ThreadState.Unknown:
                    aProcInfo.state = "Zombie";
                    break;
            }
        
//            foreach (ProcessThread thread in threads) {
//                System.Console.WriteLine(thread.ThreadState);
//            }
//            System.Console.WriteLine("");
            
//            ProcessModuleCollection modules = aProcess.Modules;
            
//            ProcessStartInfo startInfo = aProcess.StartInfo;
//            aProcInfo.argv = startInfo.Arguments;
//            System.Console.WriteLine(startInfo.Arguments);
                        
//           ProcessModule mainModule = aProcess.MainModule;
//            aProcInfo.fullPath = mainModule.FileName;
//            System.Console.WriteLine("**** {0}", mainModule.ModuleName);
            
            output[i] = aProcInfo;
        }
        return output;
    }
}
