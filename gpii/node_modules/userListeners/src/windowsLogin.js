/* Windows Login user listener.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    path = require("path"),
    fs = require("fs"),
    os = require("os"),
    edge = process.versions.electron ? require("electron-edge-js") : require("edge-js");

var gpii = fluid.registerNamespace("gpii");

// The windows-login user listener
fluid.defaults("gpii.windows.userListeners.windowsLogin", {
    gradeNames: ["fluid.component", "gpii.userListener"],
    members: {
        listenerName: "windows-login",
        environmental: true
    },
    invokers: {
        startListener: {
            funcName: "gpii.windows.userListeners.startWindowsLogin",
            args: ["{that}"]
        },
        stopListener: "fluid.identity",
        getGpiiKey: {
            funcName: "gpii.windows.userListeners.getGpiiKey",
            args: ["{that}", "{serviceHandler}.requestSender.sign"]
        },
        getUserId: {
            funcName: "gpii.windows.userListeners.getUserId",
            args: ["{that}.options.config.userIdSource"]
        },
        checkBlockedUser: {
            funcName: "gpii.windows.userListeners.checkBlockedUser",
            args: ["{that}.options.config.blockedUsers", "{arguments}.0"]
        }
    },
    config: {
        // Windows user account names for which auto-login is disabled [GPII-4000]
        blockedUsers: [],
        userIdSource: undefined
    }
});

/**
 * Determines if a given user name matches one of the blocked users, for which auto-login is disabled.
 *
 * @param {Array<String>} blockedUsers The array of blocked users.
 * @param {String} username The user name to check.
 * @return {Boolean} true if the username is blocked, and auto-login should not be performed.
 */
gpii.windows.userListeners.checkBlockedUser = function (blockedUsers, username) {
    var blocked = fluid.makeArray(blockedUsers).some(function (pattern) {
        return gpii.windows.userListeners.wildMatch(username, pattern);
    });

    if (blocked) {
        fluid.log("Local user account '" + username + "' is blocked from using the windows login user listener");
    }

    return blocked;
};

/**
 * Matches text against a pattern with '*' and '?' wildcards.
 * @param {String} text The text to match.
 * @param {String} pattern The pattern to match against.
 * @return {Boolean} true if text matches the pattern.
 */
gpii.windows.userListeners.wildMatch = function (text, pattern) {
    var textOffset = 0;
    var patternOffset = 0;
    var match = true;

    if (text === pattern) {
        textOffset = text.length;
        patternOffset = pattern.length;
    }

    while (match && textOffset < text.length) {
        switch (pattern[patternOffset]) {
        case "?":
            // '?' always matches the current character
            break;
        case "*":
            // Skip multiple *'s
            while (pattern[patternOffset] === "*") {
                patternOffset++;
            }
            if (patternOffset >= pattern.length) {
                // Pattern ends with a *, remainder matches.
                patternOffset = pattern.length - 1;
                textOffset = text.length - 1;
                break;
            }

            // Try to match the remaining text, by skipping to the next character until a match is made.
            while (textOffset < text.length) {
                match = gpii.windows.userListeners.wildMatch(text.substr(textOffset), pattern.substr(patternOffset));
                if (match) {
                    break;
                } else {
                    textOffset++;
                }
            }
            break;
        default:
            // Literal in the pattern must match the one in the text.
            match = pattern[patternOffset] === text[textOffset];
        }

        // Move to the next character
        patternOffset++;
        textOffset++;
    }

    // Ignore *'s at the end, they match zero characters
    while (pattern[patternOffset] === "*") {
        patternOffset++;
    }

    return match && patternOffset === pattern.length;
};

/**
 * Attempts a login, using the current Windows user account.
 *
 * @param {Component} that The gpii.windows.userListeners.windowsLogin instance.
 * @return {Promise} Resolves when the listener has started.
 */
gpii.windows.userListeners.startWindowsLogin = function (that) {
    var promise;
    var username = os.userInfo().username;
    var blocked = that.checkBlockedUser(username);
    if (blocked) {
        promise = fluid.promise().reject("blocked");
    } else {
        promise = that.getGpiiKey().then(function (gpiiKey) {
            that.events.onTokenArrive.fire(that, gpiiKey);
        });
    }
    return promise;
};

/**
 * Function to sign some data.
 *
 * @callback windowsLogin.sign
 * @param {String|Buffer} payload The data to sign.
 * @param {String} keyName Key identifier (field name in the service's secrets file).
 * @return {Promise<String>} Resolves with the signed digest, as a 256bit hex string.
 */

/**
 * Generates a gpiiKey based on either the current Windows user, or a custom registry value or file.
 *
 * The source of the user identifier, userIdSource, is specified in the site-config. This is to cater for deployments
 * where multiple users use the same Windows account (access is granted via membership card, for example).
 *
 * It can be one of:
 *  - "disable": to disable auto-login completely.
 *  - "username" (default): The name of the current user.
 *  - "userid": The current user's SID.
 *  - "reg:..." Path to a registry value containing the user ID.
 *  - "file:..." A path to a file, whose content is the user ID (only the first line is taken).
 *
 * The key is generated using the signed digest of the user's ID. The site's domain (stored in the service's secrets
 * file) is used to ensure gpii keys are unique across different deployments.
 *
 * @param {Component} that The gpii.windows.userListeners.windowsLogin instance.
 * @param {windowsLogin.sign} sign The function used to sign the user id.
 * @return {Promise} Resolves with the gpiiKey for the current user.
 */
gpii.windows.userListeners.getGpiiKey = function (that, sign) {
    var promise = fluid.promise();

    var userId = that.getUserId();

    fluid.log("Auto-login user id: " + userId);

    if (userId && !that.checkBlockedUser(userId)) {
        if (userId.startsWith("gpiiKey:")) {
            promise.resolve(userId.substring(8));
        } else {
            sign(userId, "site").then(function (digest) {
                // Truncate the digest into a guid.
                var result = gpii.windows.userListeners.hexToGuid(digest);
                promise.resolve(result);
            }, promise.reject);
        }
    } else {
        promise.reject("Unable to acquire the current user id");
    }
    return promise;
};

/**
 * Gets the user ID, via the given source.
 *
 * @param {String} userIdSource A string identifying the location from which to retrieve a unique user identifier.
 * @return {String} The user ID - null if unknown.
 */
gpii.windows.userListeners.getUserId = function (userIdSource) {
    var userId;
    var source = (userIdSource || "username").toString().toLowerCase();

    if ((source === "disable") || (source === "disabled")) {
        // Disabled
        fluid.log("auto-login is disabled by the site-config.");
        userId = null;
    } else if (source === "username") {
        // The Windows account name
        userId = os.userInfo().username;
    } else if (source === "userid") {
        // The User's SID
        userId = gpii.windows.getUserSid();
    } else if (source.startsWith("reg:") || source.startsWith("regkey")) {
        // A registry location
        if (source === "regkey") {
            source += ":HKCU\\SOFTWARE\\Morphic\\gpiiKey";
        }
        var match = /^reg(key)?:\\*(HK[A-Z_]+)\\(.*)\\([^\/]+)$/i.exec(userIdSource.replace("/", "\\"));
        var isKey = match[1] === "key";
        var baseKey = match[2];
        var keyPath = match[3];
        var valueName = match[4];
        if (baseKey.length <= 4) {
            baseKey = ({
                HKLM: "HKEY_LOCAL_MACHINE",
                HKCU: "HKEY_CURRENT_USER",
                HKCR: "HKEY_CLASSES_ROOT",
                HKU: "HKEY_USERS"
            })[baseKey];
        }

        userId = gpii.windows.readRegistryKey(baseKey, keyPath, valueName, "REG_SZ").value;
        if (!userId && !(keyPath.startsWith("64:") || keyPath.startsWith("32:"))) {
            // try the other-bit registry
            keyPath = (os.arch() === "x64" ? "32:" : "64:") + keyPath;
            userId = gpii.windows.readRegistryKey(baseKey, keyPath, valueName, "REG_SZ").value;
        }

        if (isKey && userId) {
            userId = "gpiiKey:" + userId;
        }

    } else if (source.startsWith("file:")) {
        // A file
        var path = source.substr(5);
        // Just use the first line of the file.
        try {
            var content = fs.readFileSync(path, "utf8");
            userId = content && content.trim().substr(0, 0xff).split(/[\r\n]/, 1)[0];
        } catch (e) {
            fluid.log("Could not read the auto-login user from " + path + ":", e);
            userId = null;
        }
    } else {
        fluid.log("auto-login has an unknown userId source of '" + userIdSource + "'");
        userId = null;
    }

    return (userId !== "" && userId) || null;

};

/**
 * Mash a hex string (of at least 32 characters) into a GUID.
 * @param {String} hexString The input hex string.
 * @return {String} A guid, based on the given hex string.
 */
gpii.windows.userListeners.hexToGuid = function (hexString) {
    var result;
    if (hexString.length < 32) {
        fluid.fail("hexToGuid wants a longer string");
    } else {
        result = [
            hexString.substr(0, 8),
            hexString.substr(8, 4),
            hexString.substr(12, 4),
            hexString.substr(16, 4),
            hexString.substr(20, 12)
        ].join("-");
    }

    return result;
};

/**
 * Gets the current user's SID (security identifier) as a string. This is the unique identifier of a user on a domain.
 * For example: "S-1-5-21-2284820620-4150533183-3809465755-1001"
 *
 * @return {String} The SID of the currently logged in user.
 */
gpii.windows.getUserSid = function () {
    // Lazily initialise the .NET function, to save having to compile the assembly on start-up as it might not be used.
    if (!gpii.windows.getUserSidImpl) {
        gpii.windows.getUserSidImpl = edge.func({
            source: path.join(__dirname, "windowsLogin.cs"),
            typeName: "WindowsLogin",
            methodName: "GetUserSid",
            references: [
                "System.Runtime.dll"
            ]
        });
    }

    return gpii.windows.getUserSidImpl(null, true);
};
