/*
 * Application Zoom
 *
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    path = require("path");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");
fluid.registerNamespace("gpii.windows.appZoom");

fluid.defaults("gpii.windows.appZoom", {
    gradeNames: ["fluid.component"],
    invokers: {
        startMessages: "{gpii.windows.messages}.start({that})",
        stopMessages: "{gpii.windows.messages}.stop({that})",
        getMessageWindow: "{gpii.windows.messages}.getWindowHandle()",
        windowActivated: {
            funcName: "gpii.windows.appZoom.windowActivated",
            args: ["{that}", "{arguments}.0"] // [hwnd]
        },
        getConfig: {
            funcName: "gpii.windows.appZoom.getConfig",
            args: ["{that}", "{arguments}.0"] // [WindowInfo]
        },
        sendZoom: {
            funcName: "gpii.windows.appZoom.sendZoom",
            args: ["{that}", "{arguments}.0"] // [direction]
        }
    },
    events: {
        // The current window has changed.
        onApplicationActivated: null // [{that}, WindowInfo]
    },
    listeners: {
        "onCreate": "gpii.windows.appZoom.start({that})",
        "{gpii.windows.messages}.events.onMessage": {
            funcName: "gpii.windows.appZoom.windowMessage",
            // that, hwnd, msg, wParam, lParam
            args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3" ]
        }
    },
    members: {
        // The message identifier for the shellhook notification.
        WM_SHELLHOOKMESSAGE: null,
        // The window that should receive the zoom.
        currentWindow: null
    },
    configurations: {
        ignored: {
            // "ignored" means they don't become the current window. Windows owned by this process are included.
            ignore: true,
            match: ["explorer.exe"]
        },
        generic: {
            // All unmatched windows - the wheel message, with simulated ctrl press.
            wheel: {},
            ctrl: true
        },
        wheel: {
            // Well behaved applications, that just require the wheel message (which includes the ctrl key).
            match: ["chrome.exe"],
            wheel: {}
        },
        standardKey: {
            // Presses ctrl + "-" or "="
            match: ["acrord32.exe", "firefox.exe" ],
            ctrl: true,
            key: {
                decrease: "-",
                increase: "="
            }
        },
        word: {
            match: ["winword.exe"],
            wheel: {
                delay: 500
            },
            ctrl: true,
            childWindow: "_WwG"
        },
        edge: {
            match: ["microsoftedgecp.exe"],
            // The active window reported by the shell message is wrong.
            getForegroundWindow: true,
            childWindow: "Windows.UI.Core.CoreWindow",
            ctrl: true,
            wheel: {
                delay: 500,
                simulate: true
            }
        },
        uwp: {
            match: ["applicationframehost.exe"],
            getForegroundWindow: true,
            childWindow: "Windows.UI.Core.CoreWindow",
            ctrl: true,
            wheel: {
                simulate: true
            }
        }

    }
});

/**
 * Information about a window.
 * @typedef {Object} WindowInfo
 * @property {Number} hwnd The window handle.
 * @property {Number} pid The process ID.
 * @property {String} exe The executable name (lower-cased, without the directory)
 * @property {ZoomConfig} config The configuration to use for the zooming.
 */

/**
 * Information about a configuration.
 *
 * @typedef {Object} ZoomConfig
 * @property {String} name Config name.
 * @property {String[]} match The executable files (without the directory) to match against.
 * @property {String} [optional] The class-name of a child window to sent the notifications to.
 * @property {Boolean} getForegroundWindow true to call GetForegroundWindow instead of trusting the handle passed by
 * WM_SHELLHOOKMESSAGE.
 *
 * @property {Boolean} ctrl Explicitly hold the control key down.
 *
 * @property {Object} wheel Use ctrl+mouse wheel.
 * @property {Boolean} wheel.delay Wait a number of milliseconds before and after.
 * @property {Boolean} wheel.simulate Simulate the mouse action by moving the cursor and injecting a wheel movement,
 *  rather than just sending WM_MOUSEWHEEL.
 *
 * @property {Object} keys The keys to send to adjust the zoom level.
 * @property {String|Number} keys.decrease The key (character or virtual key code) to send to reduce the zoom.
 * @property {String|Number} keys.increase The key (character or virtual key code) to send to increase the zoom.
 */

/**
 * Sends the zoom command to the current window.
 *
 * @param {Component} that The gpii.windows.appZoom component.
 * @param {String} direction The direction to zoom, "decrease" "increase".
 */
windows.appZoom.sendZoom = function (that, direction) {

    var window = that.currentWindow;
    var config = window && window.config;

    var increment = direction === "increase" ? 1 : -1;

    if (increment < 0 && direction !== "decrease") {
        fluid.fail("sendZoom: direction should be either 'decrease' or 'increase'");
    }

    var hwnd = 0;
    if (config.childWindow) {
        // Send messages to a child window - find the child.
        var classBuffer = Buffer.alloc(0xff);

        hwnd = windows.enumerateWindows(window.hwnd, function (hwndChild) {
            if (windows.user32.GetClassNameW(hwndChild, classBuffer, classBuffer.length)) {
                var cls = windows.stringFromWideChar(classBuffer);
                return cls === config.childWindow ? hwndChild : undefined;
            }
        });

        if (!hwnd) {
            fluid.log("appZoom: child window '" + config.childWindow + "' not found.");
        }
    }

    if (!hwnd) {
        hwnd = window.hwnd;
    }

    if (config.ctrl) {
        var KEYEVENTF_EXTENDEDKEY = 0x1;
        var KEYEVENTF_KEYUP = 0x2;

        // Even though the WM_MOUSEWHEEL message does provide the modifier key state, some applications will
        // still use GetKeyState/GetAsyncKeyState. For this case, simulate the control key press.
        windows.user32.keybd_event(windows.API_constants.VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
        windows.user32.keybd_event(windows.API_constants.VK_CONTROL, 0, 0, 0);

        // Always release the control key.
        setTimeout(function () {
            windows.user32.keybd_event(windows.API_constants.VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
            windows.user32.keybd_event(windows.API_constants.VK_CONTROL, 0, KEYEVENTF_KEYUP | KEYEVENTF_EXTENDEDKEY, 0);
        }, config.wheel && config.wheel.delay || 10);
    }

    if (config.wheel) {
        // from WinUser.h:
        var MK_CONTROL = 0x8;
        var WHEEL_DELTA = 120;
        var MOUSEEVENTF_WHEEL = 0x800;

        var rect = windows.getWindowRect(hwnd);

        var sendWheel = function () {
            // Say that the mouse cursor is in the middle of the window.
            var x = rect.left + rect.width / 2;
            var y = rect.top + rect.height / 2;
            var distance = WHEEL_DELTA * increment;

            if (config.wheel.simulate) {
                // Move the cursor on the window and simulate wheel movement.
                var point = new windows.POINT();
                windows.user32.GetCursorPos(point.ref());
                windows.user32.SetCursorPos(x, y);
                windows.user32.mouse_event(MOUSEEVENTF_WHEEL, 0, 0, distance, 0);
                // Put it back again.
                windows.user32.SetCursorPos(point.x, point.y);
            } else {
                // Send the wheel message.
                var lParam = windows.makeLong(x, y);
                var wParam = windows.makeLong(MK_CONTROL, distance);
                windows.user32.PostMessageW(hwnd, windows.API_constants.WM_MOUSEWHEEL, wParam, lParam);
            }
        };

        if (rect) {
            if (config.wheel.delay) {
                setTimeout(sendWheel, config.wheel.delay);
            } else {
                sendWheel();
            }
        }

    } else if (config.key) {
        var key = config.key[direction];
        if (key) {
            var keyCode = parseInt(key);
            if (!keyCode) {
                keyCode = windows.user32.VkKeyScanW(key.charCodeAt(0)) & 0xff;
            }
            windows.user32.PostMessageW(hwnd, windows.API_constants.WM_KEYDOWN, keyCode, 0);
            windows.user32.PostMessageW(hwnd, windows.API_constants.WM_KEYUP, keyCode, 1);
        }
    }
};

/**
 * Gets some information about a given window.
 * @param {Number} hwnd The window handle.
 * @return {WindowInfo} Information about the window.
 */
windows.appZoom.getWindowInfo = function (hwnd) {
    var pid = hwnd && windows.getWindowProcessId(hwnd);
    var result;

    if (pid) {
        var processPath = windows.getProcessPath(pid);

        result = {
            hwnd: hwnd,
            pid: pid,
            exe: path.basename(processPath).toLowerCase()
        };
    }
    return result;
};

/**
 * Gets the zoom configuration that should be used for given window.
 *
 * @param {Component} that The gpii.windows.appZoom component.
 * @param {WindowInfo} window The window.
 * @return {ZoomConfig} The configuration.
 */
windows.appZoom.getConfig = function (that, window) {
    if (typeof(window) === "number") {
        window = that.getWindowInfo();
    }

    var config = fluid.find(that.options.configurations, function (config) {
        return fluid.makeArray(config.match).indexOf(window.exe) >= 0 ? config : undefined;
    });

    return config || that.options.configurations.generic;
};

/**
 * A window has been activated.
 * @param {Component} that The gpii.windows.appZoom component.
 * @param {Number} hwnd The handle to the activated window.
 */
windows.appZoom.windowActivated = function (that, hwnd) {
    if (that.activeWindow !== hwnd) {
        that.activeWindow = hwnd;
        var window = windows.appZoom.getWindowInfo(hwnd);
        console.log("active ", window);

        // Get the configuration for the window.
        if (window && (window.pid !== process.pid)) {

            window.config = that.getConfig(window);
            if (!window.config.ignore) {
                that.currentWindow = window;

                if (window.config.getForegroundWindow) {
                    // Edge's edge case. The window reported by the notification isn't the right window.
                    window.hwnd = windows.user32.GetForegroundWindow();
                }
            }
        }

        console.log("currentWindow", that.currentWindow);
        if (that.currentWindow) {
            that.events.onApplicationActivated.fire(that, that.currentWindow);
        }
    }
};

/**
 * Called when an event has been received by the message window.
 *
 * Handles the WM_SHELLHOOKMESSAGE message.
 *
 * @param {Component} that The gpii.windows.appZoom component.
 * @param {Number} hwnd The window handle of the message window.
 * @param {Number} msg The message identifier.
 * @param {Number} wParam Message specific data.
 * @param {void*} lParam Additional message specific data.
 */
gpii.windows.appZoom.windowMessage = function (that, hwnd, msg, wParam, lParam) {
    var HSHELL_WINDOWACTIVATED = 4;
    var HSHELL_RUDEAPPACTIVATED = 0x8004;

    if (msg === that.WM_SHELLHOOKMESSAGE) {
        if (wParam === HSHELL_WINDOWACTIVATED || wParam === HSHELL_RUDEAPPACTIVATED) {
            // Run the code in the next tick so this function can return soon, as it's a window procedure.
            process.nextTick(that.windowActivated, lParam.address());
        }
    }
};

/**
 * Start monitoring window activation.
 *
 * @param {Component} that The gpii.windows.appZoom component.
 */
windows.appZoom.start = function (that) {
    // Get the "dynamic constant" value of the WM_SHELLHOOKMESSAGE message identifier.
    that.WM_SHELLHOOKMESSAGE = windows.user32.RegisterWindowMessageW(windows.stringToWideChar("SHELLHOOK"));

    that.startMessages();
    // Tell Windows to send WM_SHELLHOOKMESSAGE.
    gpii.windows.user32.RegisterShellHookWindow(that.getMessageWindow());
};

