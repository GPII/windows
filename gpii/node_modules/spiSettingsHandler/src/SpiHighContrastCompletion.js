/*
 * SPI High-contrast completion. Waits for the completion of the SPI_SETHIGHCONTRAST call.
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */
"use strict";

if (!process.env.GPII_CHILD_PROCESS) {
    console.error(__filename + " should be executed as a child process");
    return;
}

var windows = require("../../WindowsUtilities/WindowsUtilitiesCore.js").windows;
var ref = require("ref");

/**
 * Waits for a process to terminate, returning when there are no matching processes.
 *
 * A snapshot of the running processes is taken, and if a matching process is found try to
 * open it and wait for it to close.
 *
 *
 * @param filename The executable.
 * @param timeout The timeout (ms).
 */
windows.waitForProcessTermination = function (filename, timeout) {

    var outOfTime = false;
    var found = false;

    var timer = setTimeout(function () {
        outOfTime = true;
    }, timeout);

    // Loop until no matching processes are found.
    do {
        found = false;
        var hSnapShot = windows.kernel32.CreateToolhelp32Snapshot(windows.API_constants.TH32CS_SNAPPROCESS, null);

        try {
            var pEntry = new windows.PROCESSENTRY32();
            pEntry.dwSize = windows.PROCESSENTRY32.size;

            var hRes = windows.kernel32.Process32First(hSnapShot, pEntry.ref());

            while (hRes) {
                var buf = new Buffer(pEntry.szExeFile);
                var processName = ref.readCString(buf, 0);

                if (processName === filename) {
                    var hProcess;
                    found = true;

                    try {
                        // Get a handle to the process, and wait for it to die
                        hProcess = windows.kernel32.OpenProcess(windows.API_constants.SYNCHRONIZE, 0, pEntry.th32ProcessID);
                        var waited = false;

                        if (hProcess !== ref.NULL) {
                            console.log("Waiting for " + filename + " to die");
                            var wait = windows.kernel32.WaitForSingleObject(hProcess, timeout);
                            switch (wait) {
                            case windows.API_constants.WAIT_OBJECT_0:
                                // success
                                waited = true;
                                break;
                            case windows.API_constants.WAIT_TIMEOUT:
                                // timedout
                                waited = true;
                                outOfTime = true;
                                break;
                            default:
                                // failure
                                break;
                            }
                        }

                        if (!waited) {
                            // Unable to wait for the process; fall-back to polling.
                            console.log(filename + " is still running");
                            windows.kernel32.Sleep(800);
                        }
                    } finally {
                        if (hProcess && hProcess !== ref.NULL) {
                            windows.kernel32.CloseHandle(hProcess);
                            hProcess = null;
                        }
                    }

                    // There may be more processes running, but the current snap-shot may be stale.
                    break;
                }

                hRes = windows.kernel32.Process32Next(hSnapShot, pEntry.ref());
            }
        } finally {
            if (hSnapShot && hSnapShot !== ref.NULL) {
                windows.kernel32.CloseHandle(hSnapShot);
                hSnapShot = null;
            }
        }

    } while (found && !outOfTime);

    clearTimeout(timer);
    return outOfTime && found;
};

// Allow the process name to be overridden
var sethcProcess = process.env.GPII_SETHC_EXE || "sethc.exe";

windows.waitForProcessTermination(sethcProcess, 120000);
