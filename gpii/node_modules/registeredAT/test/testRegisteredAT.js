/*
 * Built-in AT Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");

require("../registeredAT.js");
require("../../processHandling/processHandling.js");

fluid.registerNamespace("gpii.tests.windows.registeredAT");

var teardowns = [];

jqUnit.module("gpii.tests.windows.registeredAT", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.windows.registeredAT.atInfoTest = {
    input: {
        appName: "magnifierpane",
        values: ["ATExe", "StartExe", "Description"]
    },
    expectedResult: {
        "ATExe": "Magnify.exe",
        "StartExe": "%SystemRoot%\\System32\\Magnify.exe",
        "Description": "Screen Magnifier"
    }
};

gpii.tests.windows.registeredAT.atEnableTest = {
    input: {
        appName: "gpii-test-" + Math.random(),
        regRoot: "HKEY_CURRENT_USER",
        regPath: "Software\\Microsoft\\Windows NT\\CurrentVersion\\AccessibilityTemp"
    },
    expectedResults: {
        enable: 3,
        disable: 2
    }
};

gpii.tests.windows.registeredAT.atStartStopTest = {
    testData: {
        appName: "gpii-test-" + Math.random(),
        ATExe: "gpii-registered-at-test.exe",
        StartExe: path.join(process.env.TEMP, "gpii-registered-at-test.exe"),
        StartParams: "atTest /T 10 > nul"
    }
};

jqUnit.asyncTest("Testing enableRegisteredAT", function () {
    jqUnit.expect(4);

    var testData = gpii.tests.windows.registeredAT.atEnableTest;

    var removeValue = function () {
        // Remove the temporary value
        gpii.windows.writeRegistryKey(testData.input.regRoot, testData.input.regPath, testData.input.appName,
            undefined, "REG_DWORD");
    };

    teardowns.push(removeValue);
    removeValue();

    // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
    var fakeUtilman = "gpii-test-utilman.exe";
    var fakeUtilmanPath = path.join(process.env.TEMP, fakeUtilman);
    shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), fakeUtilmanPath);
    // Remove it at the end
    teardowns.push(function () {
        gpii.windows.killProcessByName(fakeUtilman);
        shelljs.rm(fakeUtilmanPath);
    });

    var options = {
        configOnly: true,
        utilman: fakeUtilmanPath + " /T 20 gpiiFakeUtilman"
    };

    var enable = function () {
        return gpii.windows.enableRegisteredAT(testData.input.appName, true, options).then(function () {
            var result = gpii.windows.readRegistryKey(
                testData.input.regRoot, testData.input.regPath, testData.input.appName, "REG_DWORD");
            jqUnit.assertEquals("Checking registry for enabled value", testData.expectedResults.enable, result.value);
        });
    };

    var disable = function () {
        return gpii.windows.enableRegisteredAT(testData.input.appName, false, options).then(function () {
            var result = gpii.windows.readRegistryKey(
                testData.input.regRoot, testData.input.regPath, testData.input.appName, "REG_DWORD");
            jqUnit.assertEquals("Checking registry for disabled value", testData.expectedResults.disable, result.value);
        });
    };

    // Ensure (a fake) utilman was started.
    var checkUtilman = function () {
        return gpii.windows.waitForProcessStart(fakeUtilman, {timeout: 3000})
            .then(function () {
                jqUnit.assert("Utilman should have started");
                gpii.windows.killProcessByName(fakeUtilman);
            }, function () {
                jqUnit.fail("Utilman did not start");
            });
    };

    fluid.promise.sequence([
        enable,
        checkUtilman,
        disable,
        checkUtilman,
        function () {
            jqUnit.start();
        }
    ]);
});

jqUnit.test("Testing getATInformation", function () {
    var testData = gpii.tests.windows.registeredAT.atInfoTest;
    var at = gpii.windows.getATInformation(testData.input.appName, testData.input.values);
    jqUnit.assertDeepEq("Checking result of getATInformation", testData.expectedResult, at);
});

jqUnit.asyncTest("Testing AT start and stop", function () {
    jqUnit.expect(3);

    var testData = gpii.tests.windows.registeredAT.atStartStopTest.testData;

    // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
    shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), testData.StartExe);
    // Remove it at the end
    teardowns.push(function () {
        gpii.windows.killProcessByName(testData.ATExe);
        shelljs.rm(testData.StartExe);
    });

    // Make getATInformation return the test data. Override the function instead of dealing with the registry.
    var getATInformationReal = gpii.windows.getATInformation;
    gpii.windows.getATInformation = function (name, values) {
        return name === testData.appName ? testData : getATInformationReal(name, values);
    };
    // Leave it how it was
    teardowns.push(function () {
        gpii.windows.getATInformation = getATInformationReal;
    });

    var pid = gpii.windows.findProcessByName(testData.ATExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    gpii.windows.startRegisteredAT(testData.appName);

    // Timeout waiting for the process start/end after 5 seconds.
    var options = { timeout: 5000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(testData.ATExe, options)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Tell the process to stop now.
            gpii.windows.stopRegisteredAT(testData.appName);

            // Wait for it to die
            gpii.windows.waitForProcessTermination(testData.ATExe, options)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Process should have terminated.");
                });

        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });
});
