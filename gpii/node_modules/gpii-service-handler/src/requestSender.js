/*
 * Handles commands for the Windows Service.
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.windows.service.serviceHandler");

// Sends requests to the service.
fluid.defaults("gpii.windows.service.requestSender", {
    gradeNames: ["fluid.component" ],
    invokers: {
        // Called by the functions in this grade to send the request to the server.
        sendRequest: {
            funcName: "gpii.windows.service.sendRequest",
            args: [ "{serviceHandler}", "{arguments}.0", "{arguments}.1" ] // requestType, requestData
        },
        execute: {
            funcName: "gpii.windows.service.execute",
            args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ] // command, args, options
        },
        // Lets the service know this process is intentionally closing
        closing: {
            func: "{that}.sendRequest",
            args: [ "closing" ]
        },
        getClientCredentials: {
            func: "{that}.sendRequest",
            args: [ "getClientCredentials" ]
        },
        sign: {
            func: "{that}.sendRequest",
            args: [
                "sign",
                {
                    payload: "{arguments}.0",
                    siteSpecific: "{arguments}.1"
                }
            ]
        }
    },
    listeners: {
        "onDestroy.close": {
            // Inform the service that this process is closing intentionally.
            funcName: "gpii.windows.service.sendRequest",
            args: [ "{serviceHandler}", "closing" ]
        }
    }
});

/**
 * Sends a request to the service.
 *
 * @param {Component} service The gpii.serviceHandler instance.
 * @param {String} requestType Type of request for the service.
 * @param {Object} requestData Request data.
 * @return {Promise} Promise resolving with the response.
 */
gpii.windows.service.sendRequest = function (service, requestType, requestData) {
    fluid.log("Service: sending request ", requestType, requestData);
    var promiseTogo;
    if (service.session) {
        var serviceRequest = {
            requestType: requestType,
            requestData: requestData
        };
        promiseTogo = service.session.sendRequest(serviceRequest);
    } else {
        promiseTogo = fluid.promise().reject({
            isError: true,
            message: "Not attached to the Windows service."
        });
    }

    promiseTogo.then(function () {
        fluid.log("Service: Responded");
    }, function (result) {
        fluid.log("Service: Request failed ", result);
    });

    return promiseTogo;
};

/**
 * Sends the "execute" request to the service.
 *
 * @param {Component} that The gpii.windows.service.requestSender instance.
 * @param {String} command The command to run.
 * @param {Array<String>} args Arguments to pass.
 * @param {Object} options The request data.
 * @param {Object} options.options The options argument for child_process.spawn.
 * @param {Boolean} options.wait True to wait for the process to terminate before resolving.
 * @param {Boolean} options.capture True capture output to stdout/stderr members of the response; implies wait=true.
 * @return {Promise} Resolves when the process has started, if wait=false, or when it's terminated.
 */
gpii.windows.service.execute = function (that, command, args, options) {
    var request = Object.assign({
        command: command,
        args: args
    }, options);
    return that.sendRequest("execute", request);
};

fluid.registerNamespace("gpii.launch");

fluid.defaults("gpii.launch.admin", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1,
        options: 2
    }
});

/**
 * Runs a command as administrator, via the service.
 *
 * @param {String} command The command to run.
 * @param {Array<String>} args Arguments to pass.
 * @param {Object} options The request data.
 * @param {Object} options.options The options argument for child_process.spawn.
 * @param {Boolean} options.wait True to wait for the process to terminate before resolving.
 * @param {Boolean} options.capture True capture output to stdout/stderr members of the response; implies wait=true.
 * @return {Promise} Resolves when the process has been started, or if options.wait is set, when finished
 */
gpii.launch.admin = function (command, args, options) {
    var service = fluid.queryIoCSelector(fluid.rootComponent, "gpii.windows.service.serviceHandler")[0];
    return service.requestSender.execute(command, args, options);
};
