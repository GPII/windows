/*
 * Windows Kill Process Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");
var ffi = require("ffi");
var arrayType = require("ref-array");
var Struct = require("ref-struct");

require("../processHandling.js");

fluid.registerNamespace("gpii.tests.windows.processHandling");


var waitExe = "gpii-process-handling-test.exe";
var waitExePath = null;

var teardowns = [];
jqUnit.module("gpii.tests.windows.processHandling", {
    setup: function () {
        // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
        // This command is a glorified "sleep" that is also able to be terminated "nicely".
        waitExePath = path.join(process.env.TEMP, waitExe);
        shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), waitExePath);
    },
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }

        if (waitExePath !== null) {
            gpii.windows.killProcessByName(waitExe);
            shelljs.rm(waitExePath);
        }
    }
});

/*
jqUnit.test("Testing isProcessRunning", function () {
    // Check a PID that isn't running.
    var running = gpii.windows.isProcessRunning(-1);
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check a PID that is running.
    running = gpii.windows.isProcessRunning(process.pid);
    jqUnit.assertTrue("Process should have been found running", running);

    // Check an exe file that isn't running.
    running = gpii.windows.isProcessRunning("a non-matching process.exe");
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check an exe file that is running.
    running = gpii.windows.isProcessRunning("node.exe");
    jqUnit.assertTrue("Process should have been found running", running);

    // Check multiple processes. There's always more than one svchost.exe running on Windows.
    running = gpii.windows.isProcessRunning("svchost.exe", true);
    jqUnit.assertTrue("Process should have been found running (multiple processes)", running);
});

jqUnit.asyncTest("Testing timeout waiting for processes start", function () {
    jqUnit.expect(1);

    var exe = "a non-matching process.exe";
    gpii.windows.waitForProcessStart(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not be running");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing timeout waiting for processes termination", function () {
    jqUnit.expect(1);

    var exe = "node.exe";
    gpii.windows.waitForProcessTermination(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not have terminated");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing waiting for processes start and end", function () {
    jqUnit.expect(3);

    var running = gpii.processReporter.find(waitExe);
    jqUnit.assertFalse("The process should not already be running.", running);

    // Timeout waiting for the process start/end after 10 seconds.
    var options = { timeout: 10000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(waitExe, options)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Wait for it to die
            gpii.windows.waitForProcessTermination(waitExe, options)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Failed to detect process termination.");
                });

            // Tell the process to stop now.
            child_process.execSync("waitfor /SI waitForProcessTerminationTest");
        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });

    // Create the process, with a 5 second timeout
    child_process.exec(waitExePath + " waitForProcessTerminationTest /T 5 > nul");
});

jqUnit.asyncTest("Testing Killing Processes", function () {
    jqUnit.expect(3);

    var running = gpii.processReporter.find(waitExe);
    jqUnit.assertFalse("The process should not already be running.", running);

    // On the call below, async is true because if it is false shelljs will
    // wait around until it is manually killed before continuing with the
    // rest of the tests.
    var command =  waitExePath + " killProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command, function (error, stdout, stderr) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Process should have terminated with code SIGKILL", 9, error.code);
        fluid.log("Program output:", stdout);
        fluid.log("Program stderr:", stderr);
        jqUnit.start();
    });

    // Kill the process when it starts
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("The process has started");
            gpii.windows.killProcessByName(waitExe);
        });
});

jqUnit.asyncTest("Testing closeProcessByName", function () {
    jqUnit.expect(3);
    var exitCode = 5;

    // Start a process that creates a window.
    var exeName = "test-window.exe";
    var exePath = path.join(__dirname, exeName);
    var command =  exePath + " -window";

    fluid.log("Executing " + command);
    var child = child_process.exec(command, function (error) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Exit code", exitCode, error.code);
    });

    child.stdout.on("data", function (data) {
        // Wait for the window to be created
        if (data.match("Window created")) {
            jqUnit.assert("Window is created");

            gpii.windows.closeProcessByName(exeName, {cleanOnly: true, timeout: 1000, exitCode: exitCode})
                .then(function (clean) {
                    jqUnit.assertTrue("Should have closed cleanly", clean);
                    jqUnit.start();
                }, function (e) {
                    fluid.log(e.message);
                    jqUnit.fail("Process should have closed.");
                    gpii.windows.killProcessByName(exeName);
                });
        }
    });
});

jqUnit.asyncTest("Testing closeProcessByName (window-less process)", function () {
    jqUnit.expect(3);

    // Start a process that does not have a window.
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("Process started");

            // The process doesn't have any windows, so this should fail to terminate it.
            gpii.windows.closeProcessByName(waitExe, {cleanOnly: true})
                .then(function () {
                    jqUnit.fail("Process should not have closed.");
                }, function (e) {
                    jqUnit.assert("Process not closed");
                    fluid.log(e.message);
                    // Retry with force
                    gpii.windows.closeProcessByName(waitExe, {cleanOnly: false})
                        .then(function () {
                            jqUnit.assert("Process terminated");
                            jqUnit.start();
                        });
                });
        });

    var command =  waitExePath + " closeProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command);
});

jqUnit.test("Testing getServiceState", function () {
    // Local Session Manager will always be running.
    var state = gpii.windows.getServiceState("LSM");
    jqUnit.assertEquals("LSM service should be running", "running", state);

    // There's a chance it might be running, but who sends faxes anymore?
    state = gpii.windows.getServiceState("Fax");
    jqUnit.assertEquals("Fax service should be stopped", "stopped", state);

    state = gpii.windows.getServiceState("gpii-unknown");
    jqUnit.assertEquals("gpii-unknown service should be unknown", "unknown", state);
});

*/

// Check if getExplorerProcess returns an explorer.exe pid.
jqUnit.test("Testing getExplorerProcess", function () {

    var explorerPid = gpii.windows.getExplorerProcess();

    jqUnit.assertFalse("explorer PID must be a number", isNaN(explorerPid));

    var isRunning = gpii.windows.isProcessRunning(explorerPid);
    jqUnit.assertTrue("explorer pid must be a running process", isRunning);

    var processes = gpii.processes.windows.getProcessList(explorerPid);
    jqUnit.assertEquals("getProcessList should return 1 process", 1, processes.length);
    jqUnit.assertEquals("process name should be explorer.exe", "explorer.exe", processes[0].command.toLowerCase());
});


var t = gpii.windows.types;
// https://msdn.microsoft.com/library/aa373674
var CCH_RM_MAX_SVC_NAME = 63;
var CCH_RM_MAX_APP_NAME = 255;
gpii.tests.windows.processHandling.RM_PROCESS_INFO = new Struct([
    [ gpii.windows.RM_UNIQUE_PROCESS, "Process"],
    [ arrayType("char", (CCH_RM_MAX_APP_NAME + 1) * 2), "strAppName"],
    [ arrayType("char", (CCH_RM_MAX_SVC_NAME + 1) * 2), "strServiceShortName"],
    [ "int32", "ApplicationType"],
    [ "uint32", "AppStatus"],
    [ "uint32", "TSSessionId"],
    [ "int32", "bRestartable"]
]);
gpii.tests.windows.processHandling.RM_PROCESS_INFOS =
    arrayType(gpii.tests.windows.processHandling.RM_PROCESS_INFO);

gpii.tests.windows.processHandling.restartManager = ffi.Library("rstrtmgr", {
    // https://msdn.microsoft.com/library/aa373661
    "RmGetList": [
        t.DWORD, [ t.DWORD, "uint*", "uint*", gpii.tests.windows.processHandling.RM_PROCESS_INFOS, t.LPDWORD ]
    ]
});

/**
 * Check if the restart manager session has been set up correctly by inspecting the result of RmGetList.
 *
 * @param stage {string} The stage of the restart process (for logging).
 * @param sessionHandle {Number} The session handle.
 * @param pids {Number[]} The process ids that are expected to be stopped/restarted.
 */
gpii.tests.windows.processHandling.checkRestartManager = function (stage, sessionHandle, pids) {
    jqUnit.expect(3 + pids.length * 3);

    var messagePrefix = "After " + stage + ": ";

    // RM_APP_STATUS: https://msdn.microsoft.com/library/aa373669
    var RmStatusRunning = 1;

    var procCount = pids.length;
    var procInfoNeededBuf = (new Buffer(4)).fill(0);
    var procInfoCountBuf = new Buffer(4);
    procInfoCountBuf.writeUInt32LE(procCount);

    var procInfos = new gpii.tests.windows.processHandling.RM_PROCESS_INFOS(procCount);

    var rebootReasons = new Buffer(4);

    var result = gpii.tests.windows.processHandling.restartManager.RmGetList(
        sessionHandle, procInfoNeededBuf, procInfoCountBuf, procInfos, rebootReasons);

    jqUnit.assertEquals(messagePrefix + "RmGetList should return 0 (ERROR_SUCCESS)", 0, result);

    var procInfoCount = procInfoCountBuf.readUInt32LE();
    jqUnit.assertEquals(messagePrefix + "Number of procInfos returned by RmGetList should be the same number of pids",
        pids.length, procInfoCount);

    var pidsFound = [];
    for (var n = 0; n < procInfoCount; n++) {
        var p = procInfos[n];
        pidsFound.push(p.Process.dwProcessId);

        var index = pids.indexOf(p.Process.dwProcessId);
        jqUnit.assertTrue(messagePrefix + "RmGetList should only return expected pids", index > -1);

        jqUnit.assertEquals(messagePrefix + "Process should be running (AppStatus = RmStatusRunning)",
            RmStatusRunning, p.AppStatus);
        jqUnit.assertTrue(messagePrefix + "Process should be restartable",
            RmStatusRunning, !!p.bRestartable);
    }

    jqUnit.assertDeepEq(messagePrefix + "RmGetList should return all pids",
        pids.sort(), pidsFound.sort());
};

/**
 * Replaces RmShutdown and RmRestart with an implementation that just checks if they have been called properly.
 *
 * @param expectedPids {Number[]} The processes that should have been restarted.
 * @param restart {boolean} True if a call to RmRestart is expected.
 */
gpii.tests.windows.processHandling.mockRestartManager = function (expectedPids) {
    jqUnit.expect(7);

    expectedPids = fluid.copy(expectedPids);
    var rmShutdown = gpii.windows.restartManager.RmShutdown.async;
    var rmRestart = gpii.windows.restartManager.RmRestart;
    teardowns.push(function () {
        gpii.windows.restartManager.RmShutdown = rmShutdown;
        gpii.windows.restartManager.RmRestart = rmRestart;
    });

    gpii.windows.restartManager.RmShutdown.async = function (dwSessionHandle, lActionFlags, fnStatus, callback) {
        var RmShutdownOnlyRegistered = 10;
        jqUnit.assertFalse("RmShutdown dwSessionHandle must be a number", isNaN(dwSessionHandle));
        jqUnit.assertEquals(
            "RmShutdown lActionFlags must be RmShutdownOnlyRegistered", RmShutdownOnlyRegistered, lActionFlags);
        // For some reason, ref doesn't like being required from this script.
        jqUnit.assertEquals("RmShutdown fnStatus must be ref.NULL", 0, fnStatus && fnStatus.length);
        jqUnit.assertEquals("RmShutdown callback must be a function", "function", typeof(callback));

        gpii.tests.windows.processHandling.checkRestartManager("RmShutdown", dwSessionHandle, expectedPids);

        // Invoke the callback with a successful return.
        callback(gpii.windows.API_constants.returnCodes.ERROR_SUCCESS);
    };
    gpii.windows.restartManager.RmRestart = function (dwSessionHandle, dwRestartFlags, fnStatus) {
        jqUnit.assertFalse("RmShutdown dwSessionHandle must be a number", isNaN(dwSessionHandle));
        // "Reserved. This parameter should be 0."
        jqUnit.assertEquals("RmShutdown dwRestartFlags must be 0", 0, dwRestartFlags);
        jqUnit.assertEquals("RmShutdown fnStatus must be ref.NULL", 0, fnStatus && fnStatus.length);
    };
};

jqUnit.asyncTest("Testing stopExplorer + restartExplorer", function () {

    // Restarting explorer for real isn't a good idea, because it could fail - if it's guaranteed to succeed, then the
    // test is not required.
    // So, the "dangerous" functions (RmShutdown and RmRestart) are mocked to check they're being called correctly.

    jqUnit.expect(3);
    var explorerPid = gpii.windows.getExplorerProcess();

    gpii.tests.windows.processHandling.mockRestartManager([ explorerPid ], true);

    var stopPromise = gpii.windows.stopExplorer();

    jqUnit.assertTrue("stopExplorer must return a promise", fluid.isPromise(stopPromise));

    stopPromise.then(function () {
        jqUnit.assert("restartProcesses promise resolved");

        var restartPromise = gpii.windows.restartExplorer();

        jqUnit.assertTrue("restartExplorer must return a promise", fluid.isPromise(restartPromise));

        restartPromise.then(jqUnit.start, fluid.fail);

    }, jqUnit.fail);

});

jqUnit.asyncTest("Testing restartExplorer", function () {
    jqUnit.expect(1);
    var explorerPid = gpii.windows.getExplorerProcess();

    gpii.tests.windows.processHandling.mockRestartManager([ explorerPid ], true);

    var restartPromise = gpii.windows.restartExplorer();

    jqUnit.assertTrue("restartExplorer must return a promise", fluid.isPromise(restartPromise));

    restartPromise.then(jqUnit.start, fluid.fail);

});
