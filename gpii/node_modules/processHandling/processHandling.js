/*
 * Windows Process Handling.
 * A wrapper to integrate processHandlingCore into GPII.
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal");
var ref = require("ref");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

require("../WindowsUtilities/WindowsUtilities.js");
require("../processReporter/processReporter.js");

var c = windows.API_constants;
var processesBridge = gpii.processes.windows();

/**
 * Kills any windows processes with a given application filename.
 * http://stackoverflow.com/questions/7956519/how-to-kill-processes-by-name-win32-api
 *
 * @param filename {String} The filename of the application. For example, the Windows on
 * screen keyboard is "osk.exe". Other examples include "Magnify.exe" and
 * "firefox.exe".
 */
gpii.windows.killProcessByName = function (filename) {
    var procs = processesBridge.findProcessesByCommand(filename);

    for (var n = 0, len = procs.length; n < len; n++) {
        var hProcess = windows.kernel32.OpenProcess(c.PROCESS_TERMINATE, 0, procs[n].pid);
        if (hProcess !== ref.NULL) {
            windows.kernel32.TerminateProcess(hProcess, 9);
            windows.kernel32.CloseHandle(hProcess);
        }
    }
};

/**
 * Determines if a given process is running, returning true if it is.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @return {boolean} true if the process is running.
 */
gpii.windows.isProcessRunning = function (proc) {
    var togo = false;
    if (isNaN(proc)) {
        togo = gpii.processReporter.find(proc);
    } else {
        try {
            process.kill(proc, 0);
            togo = true;
        } catch (e) {
            togo = false;
        }
    }
    return togo;
};

/**
 * Waits for a process to either start or terminate, returning a promise which will resolve when the existence of a
 * process is in the desired state.
 *
 * The promise will reject if the process has yet to become in the desired state after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param options The options.
 * @param options.start The desired state: true to wait for the process to start, false to wait for the termination.
 * @param options.timeout Approximate milliseconds to wait, or null for infinite.
 * @param options.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when the process is in the desired state, or will reject if after the
 *   timeout the process is still in the same state.
 */
gpii.windows.waitForProcessState = function (proc, options) {
    var defaultOptions = {
        pollDelay: 500,
        timeout: null,
        start: false
    };

    options = fluid.extend(true, defaultOptions, options);

    var waitOptions = {
        argument: proc,
        conditionValue: options.start,
        pollDelay: options.pollDelay,
        timeout: options.timeout,
        error: {
            isError: true,
            message: "Timed out waiting for process " + proc +
            " to " + (options.start ? "start" : "terminate") + " after " + options.timeout + "ms"
        }
    };

    return gpii.windows.waitForCondition(gpii.windows.isProcessRunning, waitOptions);
};

/**
 * Waits for a process to terminate, returning a promise which will resolve when there are no matching processes
 * running. If there are no processes running when the function is called, the promise will already be resolved.
 * The promise will reject if the process is still running after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param userOptions The options.
 * @param userOptions.timeout Approximate milliseconds to wait, or null for infinite.
 * @param userOptions.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when there are no matching processes running, or will reject if a matching
 *  process is still running after the timeout.
 */
gpii.windows.waitForProcessTermination = function (proc, userOptions) {
    var options = fluid.extend(true, {start: false}, userOptions);
    return gpii.windows.waitForProcessState(proc, options);
};

/**
 * Waits for a process to start, returning a promise which will resolve when there there is a matching process running.
 * If there are already processes running when the function is called, the promise will already be resolved.
 * The promise will reject if a matching process is still not running after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param userOptions The options.
 * @param userOptions.timeout Approximate milliseconds to wait, or null for infinite.
 * @param userOptions.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when there is a matching processes running, or will reject if a matching
 *  process is still not running after the timeout.
 */
gpii.windows.waitForProcessStart = function (proc, userOptions) {
    var options = fluid.extend(true, {start: true}, userOptions);
    return gpii.windows.waitForProcessState(proc, options);
};

/**
 * Terminates a process in a kind manner by sending WM_QUIT to the windows it owns. This should allow the process to
 * perform any clean up tasks.
 *
 * If options.gracefulOnly is false (default), and if the process has not shutdown after the timeout or the process
 * does not have any Windows, then the process will be terminated.
 *
 * The returned promise resolves when the process has ended, with a boolean indicating whether a clean shutdown was
 * possible.
 *
 * @param filename
 * @param options The options.
 * @param options.timeout How long to wait for the process to die, in milliseconds.
 * @param options.cleanOnly true to reject if the process can't be closed cleanly; false to force the termination.
 * @param options.exitCode {number} The exit code the application should return.
 * @return {promise}
 */
gpii.windows.closeProcessByName = function (filename, options) {
    var defaultOptions = {
        timeout: 15000,
        cleanOnly: false,
        exitCode: 0
    };

    options = fluid.extend(defaultOptions, options);

    var pids = fluid.transform(processesBridge.findProcessesByCommand(filename), function (proc) {
        return proc.pid;
    });
    if (!pids) {
        // Process is not running.
        return fluid.toPromise(true);
    }

    var foundWindow = false;

    // Enumerate all the top-level windows on the desktop, to see which ones are owned by the process.
    gpii.windows.enumerateWindows(function (hwnd) {
        // Get the process ID that owns the Window.
        var ptr = ref.alloc(windows.types.DWORD);
        gpii.windows.user32.GetWindowThreadProcessId(hwnd, ptr);
        var windowPid = ptr.deref();

        if (pids.indexOf(windowPid) !== -1) {
            // Send WM_QUIT, which tells the thread to terminate.
            gpii.windows.user32.PostMessageW(hwnd, windows.API_constants.WM_QUIT, options.exitCode, 0);
            foundWindow = true;
        }
    });

    var promiseTogo = fluid.promise();

    if (foundWindow) {
        // Wait for the process to die.
        gpii.windows.waitForProcessTermination(filename, { timeout: options.timeout })
            .then(function () {
                promiseTogo.resolve(true);
            }, function (err) {
                // Taking too long to die.
                if (options.cleanOnly) {
                    promiseTogo.reject({
                        isError: true,
                        message: "Process " + filename + " will not close cleanly: " + err.message,
                        error: err
                    });
                } else {
                    // Force it to terminate
                    gpii.windows.killProcessByName(filename);

                    // This promise was rejected but the return promise should resolve as the process is terminated.
                    promiseTogo.resolve(false);
                }
            });
    } else {
        // The process does not have any windows so it can't be shutdown cleanly.
        if (options.cleanOnly) {
            promiseTogo.reject({
                isError: true,
                message: "Process " + filename + " will not close cleanly: No windows belong to the process"
            });
        } else {
            // Force it to terminate.
            gpii.windows.killProcessByName(filename);
            promiseTogo.resolve(false);
        }
    }

    return promiseTogo;
};

/**
 * Determines the current state of a service, which can be one of paused, running, or stopped:
 *
 *
 * @param serviceName {string} The service name (The "service name", not the "display name").
 * @return {String} paused, running, stopped, or unknown.
 */
gpii.windows.getServiceState = function (serviceName) {

    var managerHandle = gpii.windows.advapi32.OpenSCManagerW(0, 0, gpii.windows.API_constants.SC_MANAGER_CONNECT);

    var serviceHandle;
    if (managerHandle) {
        var serviceBuffer = gpii.windows.stringToWideChar(serviceName);
        serviceHandle = gpii.windows.advapi32.OpenServiceW(managerHandle, serviceBuffer,
            gpii.windows.API_constants.SERVICE_QUERY_STATUS);
    }

    var stateNumber;
    if (serviceHandle) {
        var serviceStatus = new gpii.windows.SERVICE_STATUS();
        var success = gpii.windows.advapi32.QueryServiceStatus(serviceHandle, serviceStatus.ref());
        if (success) {
            stateNumber = serviceStatus.dwCurrentState;
        }
        gpii.windows.advapi32.CloseServiceHandle(serviceHandle);
    }

    if (managerHandle) {
        gpii.windows.advapi32.CloseServiceHandle(managerHandle);
    }

    var state;
    switch (stateNumber) {
    case gpii.windows.API_constants.SERVICE_PAUSE_PENDING:
    case gpii.windows.API_constants.SERVICE_PAUSED:
        state = "paused";
        break;
    case gpii.windows.API_constants.SERVICE_CONTINUE_PENDING:
    case gpii.windows.API_constants.SERVICE_START_PENDING:
    case gpii.windows.API_constants.SERVICE_RUNNING:
        state = "running";
        break;
    case gpii.windows.API_constants.SERVICE_STOP_PENDING:
    case gpii.windows.API_constants.SERVICE_STOPPED:
        state = "stopped";
        break;
    default:
        state = "unknown";
    }

    return state;
};

/**
 * Gets the creation time of a process.
 * @param pid {number} The process ID.
 * @return {FILETIME} The creation time.
 */
gpii.windows.getProcessCreationTime = function (pid) {
    var togo = null;
    var hProcess = gpii.windows.kernel32.OpenProcess(
        windows.API_constants.PROCESS_VM_READ | windows.API_constants.PROCESS_QUERY_INFORMATION, 0, pid);

    if (hProcess) {
        var chSize = ref.alloc(windows.types.DWORD);
        chSize.fill(0);

        var creation = new gpii.windows.FILETIME(),
            exit = new gpii.windows.FILETIME(),
            kernel = new gpii.windows.FILETIME(),
            user = new gpii.windows.FILETIME();

        var success = windows.kernel32.GetProcessTimes(
            hProcess, creation.ref(), exit.ref(), kernel.ref(), user.ref());

        if (success) {
            togo = creation;
        }
    }

    return togo;
};

/**
 * Gets the PID of the explorer process that owns the tasktray.
 */
gpii.windows.getExplorerProcess = function () {
    var classname = windows.stringToWideChar("Shell_TrayWnd");
    var trayWindow = windows.user32.FindWindowW(classname, ref.NULL);
    return windows.getWindowProcessId(trayWindow);
};

gpii.windows.currentRestartSession = null;

/**
 * Stops the Windows Explorer shell process.
 *
 * Use restartExplorer() to restart it.
 */
gpii.windows.stopExplorer = function () {
    var promise = fluid.promise();
    var session = null;
    var rm = windows.restartManager;

    // RestartManager.h:
    var CCH_RM_SESSION_KEY = 16 * 2 + 1; // sizeof(GUID) * 2 + 1
    var RmShutdownOnlyRegistered = 10;

    // Get the explorer process that owns the task tray.
    var explorerPid = windows.getExplorerProcess();
    if (explorerPid) {
        var creationTime = gpii.windows.getProcessCreationTime(explorerPid);
        var processArray = new windows.RM_UNIQUE_PROCESSES(1);
        processArray[0].dwProcessId = explorerPid;
        processArray[0].ProcessStartTime = creationTime;

        // Create the "restart session".
        var sessionBuf = ref.alloc(gpii.windows.types.DWORD);
        var sessionKey = new Buffer(CCH_RM_SESSION_KEY * 2);
        sessionKey.fill(0);
        var result = rm.RmStartSession(sessionBuf, 0, sessionKey);

        if (result) {
            promise.reject(windows.win32error("RmStartSession", result));
        } else {
            session = sessionBuf.deref();

            // Close the session upon failure.
            promise.then(null, function () {
                rm.RmEndSession(session);
            });

            // Add the explorer process to the restart list.
            result = rm.RmRegisterResources(session, 0, ref.NULL, processArray.length, processArray, 0, ref.NULL);
            if (result) {
                promise.reject(windows.win32error("RmRegisterResources", result));
            } else {
                // Close the process. This waits for it to shutdown nicely, so it takes a few seconds.
                rm.RmShutdown.async(session, RmShutdownOnlyRegistered, ref.NULL, function (err, ret) {
                    if (err) {
                        promise.reject({
                            isError: true,
                            error: err
                        });
                    } else if (ret) {
                        promise.reject(windows.win32error("RmShutdown", ret));
                    } else {
                        gpii.windows.currentRestartSession = session;
                        promise.resolve(session);
                    }
                });
                // It sometimes fails, so kill it manually after a few seconds.
                windows.waitForProcessTermination(explorerPid, { timeout: 5000 }).then(null, function () {
                    process.kill(explorerPid);
                });
            }
        }
    } else {
        promise.reject({
            isError: true,
            error: "Unable to find the Explorer process"
        });
    }

    return promise;
};

/**
 * Restarts the Windows Explorer shell process.
 *
 * If stopExplorer hasn't been called, then it gets called.
 */
gpii.windows.restartExplorer = function () {
    var promiseTogo = fluid.promise();
    var rm = windows.restartManager;

    // Call stopExplorer if there's no current restart session.
    var shutdownPromise = (gpii.windows.currentRestartSession === null)
        ? gpii.windows.stopExplorer()
        : fluid.toPromise(gpii.windows.currentRestartSession);

    shutdownPromise.then(function (session) {
        try {
            // Re-start the explorer process.
            var result = rm.RmRestart(session, 0, ref.NULL);
            if (result) {
                throw windows.win32error("RmRestart", result);
            }

        } finally {
            rm.RmEndSession(session);
            gpii.windows.currentRestartSession = null;
        }
        promiseTogo.resolve();
    });

    return promiseTogo;
};

fluid.defaults("gpii.windows.stopExplorer", {
    gradeNames: "fluid.function"
});

fluid.defaults("gpii.windows.restartExplorer", {
    gradeNames: "fluid.function"
});

fluid.defaults("gpii.windows.killProcessByName", {
    gradeNames: "fluid.function",
    argumentMap: {
        filename: 0
    }
});

fluid.defaults("gpii.windows.closeProcessByName", {
    gradeNames: "fluid.function",
    argumentMap: {
        filename: 0,
        options: 1
    }
});
