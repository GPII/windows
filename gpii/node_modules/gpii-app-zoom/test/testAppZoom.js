/*
 * Tests for Application Zoom
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

var ffi = require("ffi-napi");

require("../../../../index.js");
fluid.require("%gpii-windows");

require("../src/appZoom.js");

fluid.registerNamespace("gpii.tests.windows.appZoom");

var teardowns = [];
jqUnit.module("gpii.tests.windows.appZoom", {
    setup: function () {
    },
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.windows.appZoom.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms646301
    "GetKeyState": [
        "short", ["int"]
    ]
});

gpii.tests.windows.appZoom.testConfigs = fluid.freezeRecursive([
    {
        id: "mouse wheel",
        config: {
            wheel: {}
        }
    },
    {
        id: "ctrl + mouse wheel",
        config: {
            wheel: {},
            ctrl: true
        }
    },
    {
        id: "keyboard",
        config: {
            key: {
                decrease: "-",
                increase: "="
            }
        }
    },
    {
        id: "ctrl + keyboard",
        config: {
            key: {
                decrease: "A",
                increase: "Z"
            },
            ctrl: true
        }
    },
    {
        id: "mouse wheel, getForegroundWindow",
        config: {
            wheel: {},
            getForegroundWindow: true
        }
    }
]);

gpii.windows.messages.messagePumpDelay = 100;

jqUnit.asyncTest("Send zoom", function () {

    var testData = gpii.tests.windows.appZoom.testConfigs;

    var currentTest;
    var currentTestPromise;
    var testIndex = 0;
    var gotKeyDown = false;
    var appZoom;

    // Expand the tests to test increase and decrease.
    var allTests = [];
    fluid.each(testData, function (test) {
        allTests.push(Object.assign({direction: "increase"}, test));
        allTests.push(Object.assign({direction: "decrease"}, test));
        jqUnit.expect(6 * (test.config.key ? 2 : 1));
    });

    // Start the next test.
    var nextTest = function () {
        currentTest = allTests[testIndex++];
        currentTestPromise = fluid.promise();

        if (currentTest) {
            fluid.log("test: " + currentTest.id);
            gotKeyDown = false;

            appZoom.currentWindow = {
                hwnd: appZoom.getMessageWindow(),
                config: currentTest.config
            };
            // Set control keys to a known state (depressed).
            gpii.windows.user32.keybd_event(gpii.windows.API_constants.virtualKeyCodes.VK_CONTROL, 0, 2, 0);
            gpii.windows.user32.keybd_event(gpii.windows.API_constants.virtualKeyCodes.VK_CONTROL, 0, 3, 0);
            // Send the zoom command.
            fluid.promise.sequence([
                appZoom.sendZoom(currentTest.direction),
                currentTestPromise
            ]).then(nextTest);
        } else {
            appZoom.destroy();
            jqUnit.start();
        }
    };

    appZoom = gpii.windows.appZoom({
        listeners: {
            // The message window is the recipient of the zoom messages.
            "{gpii.windows.messages}.events.onMessage": function (hwnd, msg, wp) {
                var handled = false;
                switch (msg) {
                case gpii.windows.API_constants.WM_MOUSEWHEEL:

                    jqUnit.assertTrue("WM_MOUSEWHEEL should only be received if testing the mouse wheel",
                        !!currentTest.config.wheel);

                    // Extract the scroll amount, and make it a signed short
                    var amount = gpii.windows.hiWord(wp);
                    if (amount & 0x8000) {
                        amount -= 0x10000;
                    }

                    var dir = amount && (amount > 0 ? "increase" : "decrease");
                    jqUnit.assertEquals("WM_MOUSEWHEEL scroll direction should match the test direction.",
                        currentTest.direction, dir);

                    handled = true;
                    break;

                case gpii.windows.API_constants.WM_KEYDOWN:
                    jqUnit.assertTrue("WM_KEYDOWN should only be received if testing keys", !!currentTest.config.key);

                    var expectedChar = currentTest.config.key[currentTest.direction];

                    var charCode = gpii.windows.user32.MapVirtualKeyW(wp, gpii.windows.API_constants.MAPVK_VK_TO_CHAR);
                    var char = String.fromCharCode(charCode);

                    jqUnit.assertEquals("WM_KEYDOWN should be the correct key for the direction", expectedChar, char);
                    gotKeyDown = true;
                    handled = true;
                    break;

                case gpii.windows.API_constants.WM_KEYUP:
                    jqUnit.assertTrue("WM_KEYUP should only be received if testing keys", !!currentTest.config.key);
                    jqUnit.assertTrue("WM_KEYUP should be received after WM_KEYDOWN", gotKeyDown);
                    handled = true;
                    break;

                default:
                    // Ignore anything else.
                    break;
                }

                if (handled) {
                    var ctrlDown = !!(gpii.tests.windows.appZoom.user32.GetKeyState(
                        gpii.windows.API_constants.virtualKeyCodes.VK_CONTROL) & 0x8000);

                    jqUnit.assertEquals("Control key should only be down if configured",
                        !!currentTest.config.ctrl, ctrlDown);

                    if (msg !== gpii.windows.API_constants.WM_KEYDOWN) {
                        currentTestPromise.resolve();
                    }
                }
            }
        }
    });

    nextTest();
});
