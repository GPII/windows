/*
 * Windows Registry Settings Handler
 *
 * Copyright 2012 Raising the Floor - International
 * Copyright 2012 Antranig Basman
 * Copyright 2012 Astea Solutions AD
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

// GPII-3445: Monkey patch the Callback constructor to keep a reference of the callback info buffer, to prevent it from
// being GC'd. Otherwise, callbacks (such as the message window's window procedure) will end up reading a freed or
// reallocated piece of memory. This constructor is used by ffi-napi, so needs to be patched before it's included.
var ffiBindings = require("ffi-napi/lib/bindings.js");
var origCallback = ffiBindings.Callback;
ffiBindings.Callback = function (cif, size, argc, errorReportCallback, fn) {
    var ret = origCallback(cif, size, argc, errorReportCallback, fn);
    // Attach the data onto the returned callback pointer, so it lasts as long as the callback.
    ret["ffi.cif"] = cif;
    return ret;
};

var ffi = require("ffi-napi"),
    child_process = require("child_process"),
    fluid = require("gpii-universal"),
    fs = require("fs"),
    path = require("path"),
    rimraf = require("rimraf");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var ref = require("ref");
var Struct = require("ref-struct");
var arrayType = require("ref-array");
var NULL = ref.NULL;

var os = require("os");
var arch = os.arch();

/**
 * A map between Windows and C types.
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx
 */
windows.types = {
    "BOOL":   "int",
    "PBOOL":   "*int",
    "INT":    "int",
    "PINT":   ref.refType("int"),
    "UINT":   "uint",
    "PUINT":   ref.refType("uint"),
    "ULONG":  "ulong",
    "DWORD":  "ulong",
    "LPDWORD":  "*ulong",
    "HKL":    "void*",
    "ULONG_PTR": arch === "x64" ? "uint64" : "uint32",
    "LONG": "long",
    "HANDLE": arch === "x64" ? "uint64" : "uint32",
    "PVOID": ref.refType("void"),
    "WORD":   "uint16",
    "LUID": "uint64",
    // TODO: TCHAR should support Unicode and Windows code pages. We are just guessing
    // the system is using Unicode (wchar_t == uint16 type). The implementation should
    // support both modes.
    // https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx
    "TCHAR": "uint16",
    "PTCHAR": ref.refType("uint16"),
    "LP":    "void*"
};

var t = windows.types;

windows.kernel32 = ffi.Library("kernel32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd319072(v=vs.85).aspx
    // UINT, DWORD, LPCSTR, INT, LPWSTR, INT
    "MultiByteToWideChar": [
        "int", ["uint", "uint32", "char*", "int", "void*", "int"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130(v=vs.85).aspx
    // UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL
    "WideCharToMultiByte": [
        "int", ["uint", "uint32", "void*", "int", "char*", "int", "char*", "bool*"]
    ],

    "GetLastError": [
        "uint32", []
    ],
    "SetLastError": [
        "void", [ "int32" ]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx
    "CreateToolhelp32Snapshot": [
        t.HANDLE, [t.DWORD, t.DWORD]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834%28v=vs.85%29.aspx
    "Process32First": [
        "bool", [t.DWORD, "pointer"]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx
    "OpenProcess": [
        t.HANDLE, [t.DWORD, t.BOOL, t.DWORD]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.85%29.aspx
    "TerminateProcess": [
        t.BOOL, [t.HANDLE, t.UINT]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx
    "CloseHandle": [
        t.BOOL, [t.HANDLE]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836%28v=vs.85%29.aspx
    "Process32Next": [
        t.BOOL, [t.HANDLE, "pointer"]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684139.aspx
    "IsWow64Process": [
        t.BOOL,  [t.INT, t.PBOOL ]
    ],
    // https://msdn.microsoft.com/library/ms684919.aspx
    "QueryFullProcessImageNameW": [
        t.BOOL, [t.HANDLE, t.DWORD, "char*", t.LPDWORD ]
    ],
    // https://msdn.microsoft.com/library/ms683199
    "GetModuleHandleW": [
        t.HANDLE, ["int"]
    ],
    // https://msdn.microsoft.com/library/ms683223
    "GetProcessTimes": [
        t.BOOL, [ t.HANDLE, "void*", "void*", "void*", "void*" ]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-formatmessage
    "FormatMessageW": [
        t.DWORD, [t.DWORD, t.PVOID, t.DWORD, t.DWORD, t.PTCHAR, t.DWORD, t.PVOID]
    ],
    // https://msdn.microsoft.com/library/ms686227
    "SetProcessShutdownParameters": [
        t.BOOL, [ t.DWORD, t.DWORD ]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-localfree
    "LocalFree": [
        "uint32", [ "int" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreaduilanguage
    "GetThreadUILanguage": [
        t.WORD, [ ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcidtolocalename
    "LCIDToLocaleName": [
        "int", [ t.WORD, "char*", "int", t.DWORD ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlogicaldrivestringsw
    "GetLogicalDriveStringsW": [
        t.DWORD, [ t.DWORD, "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdrivetypew
    "GetDriveTypeW": [
        t.UINT, [ "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol
    "DeviceIoControl": [
        t.BOOL, [
            t.HANDLE,  // hDevice,
            t.DWORD,   // dwIoControlCode,
            t.PVOID,   // lpInBuffer,
            t.DWORD,   // nInBufferSize,
            t.PVOID,   // lpOutBuffer,
            t.DWORD,   // nOutBufferSize,
            t.LPDWORD, // lpBytesReturned,
            "int"      // lpOverlapped
        ]
    ],
    // https://msdn.microsoft.com/library/aa363858
    "CreateFileW": [
        t.HANDLE, [ "char*", t.DWORD, t.DWORD, t.HANDLE, t.DWORD, t.DWORD, t.HANDLE ]
    ],
    // https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw
    "CreateProcessW": [
        t.BOOL, [
            "char*",   // LPCTSTR               lpApplicationName,
            "char*",   // LPTSTR                lpCommandLine,
            t.LP,      // LPSECURITY_ATTRIBUTES lpProcessAttributes,
            t.LP,      // LPSECURITY_ATTRIBUTES lpThreadAttributes,
            t.BOOL,    // BOOL                  bInheritHandles,
            t.DWORD,   // DWORD                 dwCreationFlags,
            t.LP,      // LPVOID                lpEnvironment,
            t.LP,      // LPCTSTR               lpCurrentDirectory,
            t.LP,      // LPSTARTUPINFO         lpStartupInfo,
            t.LP       // LPPROCESS_INFORMATION lpProcessInformation
        ]
    ],
    // https://msdn.microsoft.com/library/ms686211
    "SetEvent": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms724265
    "ExpandEnvironmentStringsW": [
        t.BOOL, [ "char*", "char*", t.UINT ]
    ]
});

windows.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms633497
    "EnumWindows": [
        t.BOOL, ["void*", t.HANDLE]
    ],
    // https://msdn.microsoft.com/library/ms633494
    "EnumChildWindows": [
        t.BOOL, [t.HANDLE, "void*", t.HANDLE]
    ],
    // https://msdn.microsoft.com/library/windows/desktop/ms633522
    "GetWindowThreadProcessId": [
        t.DWORD, [t.HANDLE, t.LPDWORD]
    ],
    // https://msdn.microsoft.com/library/windows/desktop/ms644944
    "PostMessageW": [
        t.BOOL, [t.HANDLE, t.UINT, t.UINT, t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633505
    "GetForegroundWindow": [
        t.HANDLE, []
    ],
    // https://msdn.microsoft.com/library/ms644990
    "SetWindowsHookExW": [
        t.HANDLE, [ t.INT, "void*", t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms644993
    "UnhookWindowsHookEx": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644974
    "CallNextHookEx": [
        t.HANDLE, [ t.HANDLE, "int", t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms646306
    "MapVirtualKeyW": [
        t.UINT, [ t.UINT, t.UINT ]
    ],
    // https://msdn.microsoft.com/en-us/library/dd145064.aspx
    "MonitorFromWindow": [
        t.HANDLE,  [ t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/dd144901
    "GetMonitorInfoW": [
        // HMONITOR, LPMONITORINFO
        t.BOOL, [t.HANDLE, "pointer"]
    ],
    // https://msdn.microsoft.com/library/ms632680
    "CreateWindowExW": [
        t.HANDLE, [
            t.DWORD,    // dwExStyle
            "char*",  // lpClassName
            "char*",  // lpWindowName
            t.DWORD,    // dwStyle
            t.INT,      // X
            t.INT,      // Y
            t.INT,      // nWidth
            t.INT,      // nHeight
            t.HANDLE,   // hWndParent
            t.HANDLE,   // hMenu
            t.HANDLE,   // hInstance
            t.HANDLE    // lpParam
        ]
    ],
    // https://msdn.microsoft.com/library/ms633586
    "RegisterClassW": [
        t.HANDLE, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms633572
    "DefWindowProcW": [
        t.HANDLE, [ t.HANDLE, t.UINT, t.UINT, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms644943
    "PeekMessageW": [
        t.BOOL, [ t.PVOID, t.HANDLE, t.UINT, t.UINT, t.UINT ]
    ],
    // https://msdn.microsoft.com/library/ms644955
    "TranslateMessage": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms644934
    "DispatchMessageW": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms632682
    "DestroyWindow": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644989
    "RegisterShellHookWindow": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms644947
    "RegisterWindowMessageW": [
        t.UINT, [ "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclipboardformatnamew
    "GetClipboardFormatNameW": [
        t.UINT, [ t.UINT, "char*", "int" ]
    ],
    // https://msdn.microsoft.com/library/ms644950
    "SendMessageW": [
        "int", [t.HANDLE, t.UINT, t.UINT, "int" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagew
    "SendNotifyMessageW": [
        "int", [t.HANDLE, t.UINT, t.UINT, "int" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbackw
    "SendMessageCallbackW": [
        "int", [t.HANDLE, t.UINT, t.UINT, "int", "void*", t.ULONG_PTR ]
    ],
    // https://msdn.microsoft.com/library/ms633519
    "GetWindowRect": [
        t.BOOL, [ t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms646304
    "keybd_event": [
        "void", [ "char", "char", t.DWORD, t.ULONG_PTR ]
    ],
    // https://msdn.microsoft.com/library/ms646260
    "mouse_event": [
        "void", [ t.DWORD, t.DWORD, t.DWORD, t.LONG, t.ULONG_PTR ]
    ],
    // https://msdn.microsoft.com/library/ms648394
    "GetCursorPos": [
        t.BOOL, [ t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms648394
    "SetCursorPos": [
        t.BOOL, [ "int", "int" ]
    ],
    // https://msdn.microsoft.com/library/ms633582
    "GetClassNameW": [
        t.INT, [ t.HANDLE, "char*", t.INT ]
    ],
    // https://msdn.microsoft.com/library/ms646329
    "VkKeyScanW": [
        "short", [ t.TCHAR ]
    ],
    // https://msdn.microsoft.com/library/ms633558
    "WindowFromPoint": [
        // Normally defined as WindowFromPoint(POINT)
        t.HANDLE, [ t.LONG, t.LONG ]
    ],
    // https://msdn.microsoft.com/library/ms633548
    "ShowWindow": [
        t.BOOL, [ t.HANDLE, "int" ]
    ],
    // https://msdn.microsoft.com/library/ms633510
    "GetParent": [
        t.HANDLE, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633527
    "IsIconic": [
        t.BOOL, [ t.HANDLE ]
    ],
    // https://msdn.microsoft.com/library/ms633499
    "FindWindowW": [
        gpii.windows.types.HANDLE, ["char*", "char*"]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setsyscolors
    "SetSysColors": [
        t.INT, [t.INT, t.PINT, t.PUINT]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getsyscolor
    "GetSysColor": [
        t.UINT, [t.INT]
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getdoubleclicktime
    "GetDoubleClickTime": [
        "uint32", []
    ],
    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setdoubleclicktime
    "SetDoubleClickTime": [
        "int32", ["uint32"]
    ],
    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics
    "GetSystemMetrics": [
        "int", ["int"]
    ],
    // https://msdn.microsoft.com/library/ms646301
    "GetKeyState": [
        "short", ["int"]
    ],
    // https://docs.microsoft.com/es-es/windows/desktop/api/winuser/nf-winuser-setdisplayconfig
    "SetDisplayConfig": [
        "int32", ["uint32", "void*", "uint32", "void*", "uint32"]
    ],
    // https://docs.microsoft.com/es-es/windows/desktop/api/winuser/nf-winuser-querydisplayconfig
    "QueryDisplayConfig": [
        "int32", ["uint32", "uint32*", t.PVOID, "uint32*", t.PVOID, "uint32*"]
    ],
    "GetDisplayConfigBufferSizes": [
        "int32", ["uint32", "uint32*", "uint32*"]
    ],
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getasynckeystate
    "GetAsyncKeyState": [
        "short", ["int"]
    ],
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-sendinput
    "SendInput": [
        t.UINT, [t.UINT, t.LP, "int"]
    ],
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-oemkeyscan
    "OemKeyScan": [
        t.DWORD, [ t.WORD ]
    ],
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos
    "SetWindowPos": [
        t.BOOL, [ t.HANDLE, t.HANDLE, "int", "int", "int", "int", t.UINT ]
    ]
});

gpii.windows.advapi32 = new ffi.Library("advapi32", {
    // https://msdn.microsoft.com/library/ms684323
    "OpenSCManagerW": [
        t.HANDLE, [ t.HANDLE, t.HANDLE, t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms684323
    "OpenServiceW": [
        t.HANDLE, [ t.HANDLE, "char*", t.DWORD ]
    ],
    // https://msdn.microsoft.com/library/ms684939
    "QueryServiceStatus": [
        t.BOOL,  [ t.HANDLE, t.PVOID ]
    ],
    // https://msdn.microsoft.com/library/ms682028
    "CloseServiceHandle": [
        t.BOOL,  [ t.HANDLE ]
    ]
});

gpii.windows.shlwapi = new ffi.Library("shlwapi", {
    // https://docs.microsoft.com/en-us/windows/desktop/api/shlwapi/nf-shlwapi-shloadindirectstring
    "SHLoadIndirectString": [
        t.HANDLE, [ "char*", "char*", t.UINT, t.PVOID ]
    ]
});

gpii.windows.shcore = new ffi.Library("Shcore", {
    // https://msdn.microsoft.com/library/dn302122
    "SetProcessDpiAwareness": [
        t.HANDLE, [ t.UINT ]
    ]
});

gpii.windows.shell32 = new ffi.Library("shell32", {
    "SHAppBarMessage": [
        t.UINT, [ t.UINT, "void*" ]
    ]
});

// Make the process aware of DPI scaling, so Windows doesn't lie about non-client metrics (and perhaps other things).
// See GPII-3099.
gpii.windows.shcore.SetProcessDpiAwareness(1);

// Make gpii shutdown last, so it doesn't close before the shutdown is cancelled by another process.
gpii.windows.kernel32.SetProcessShutdownParameters(0x100, 0);

/**
 * Gets a function pointer for an EnumWindowsProc callback for EnumWindows.
 *
 * See: https://msdn.microsoft.com/en-us/library/ms633498
 *
 * @param {function} callback The callback.
 * @return {*} Function pointer for the given callback, to be passed to EnumWindows
 */
windows.EnumWindowsProc = function (callback) {
    return ffi.Callback(t.BOOL, [t.HANDLE, t.HANDLE], callback);
};

// Windows API constants delved from the unfathomable deeps of windows.h
windows.API_constants = {
    HKEY_CLASSES_ROOT:   0x80000000,
    HKEY_CURRENT_USER:   0x80000001,
    HKEY_LOCAL_MACHINE:  0x80000002,
    HKEY_USERS:          0x80000003,
    HKEY_CURRENT_CONFIG: 0x80000005,
    CP_UTF8: 65001,
    KEY_QUERY_VALUE: 1,
    KEY_SET_VALUE: 2,
    KEY_ENUMERATE_SUB_KEYS: 0x8,
    KEY_WOW64_32KEY: 0x200,
    KEY_WOW64_64KEY : 0x100,
    returnCodesLookup: {
        0: "ERROR_SUCCESS",
        1: "ERROR_INVALID_FUNCTION",
        2: "FILE_NOT_FOUND",
        3: "PATH_NOT_FOUND",
        6: "ERROR_INVALID_HANDLE",
        259: "ERROR_NO_MORE_ITEMS"
    },
    returnCodes: {},

    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx
    PROCESS_TERMINATE: 0x0001,
    PROCESS_QUERY_LIMITED_INFORMATION: 0x1000,
    PROCESS_QUERY_INFORMATION: 0x0400,
    PROCESS_VM_READ: 0x0010,

    // https://msdn.microsoft.com/library/ms685981
    SC_MANAGER_CONNECT: 0x0001,
    SERVICE_QUERY_STATUS : 0x0004,
    // https://msdn.microsoft.com/library/ms685996
    SERVICE_CONTINUE_PENDING: 0x00000005,
    SERVICE_PAUSE_PENDING: 0x00000006,
    SERVICE_PAUSED: 0x00000007,
    SERVICE_RUNNING: 0x00000004,
    SERVICE_START_PENDING: 0x00000002,
    SERVICE_STOP_PENDING: 0x00000003,
    SERVICE_STOPPED: 0x00000001,

    // http://stackoverflow.com/questions/23452271/is-max-path-always-same-size-even-if-unicode-macro-is-defined
    MAX_PATH: 260,
    MAX_NAME: 32,
    ENUM_CURRENT_SETTINGS: 0xffffffff,   // ((DWORD)-1)
    DISP_CHANGE_SUCCESSFUL: 0,
    DISP_CHANGE_RESTART: 1,
    FALSE:  0,
    TRUE:   1,
    // https://msdn.microsoft.com/library/windows/desktop/ms632641
    WM_QUIT: 0x12,
    // https://docs.microsoft.com/en-us/windows/desktop/winmsg/wm-close
    WM_CLOSE: 0x10,
    // https://docs.microsoft.com/windows/desktop/shutdown/wm-queryendsession
    WM_QUERYENDSESSION: 0x11,
    // https://docs.microsoft.com/windows/desktop/shutdown/wm-endsession
    WM_ENDSESSION: 0x16,
    // https://msdn.microsoft.com/library/ms912654
    WM_KEYDOWN: 0x100,
    // https://msdn.microsoft.com/library/ms646281
    WM_KEYUP: 0x101,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup
    WM_SYSKEYUP: 0x105,
    // https://msdn.microsoft.com/library/ms645616
    WM_MOUSEMOVE: 0x200,
    // https://msdn.microsoft.com/library/ms645608
    WM_LBUTTONUP: 0x202,
    // https://msdn.microsoft.com/library/ms646243
    WM_RBUTTONUP: 0x205,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-mousewheel
    WM_MOUSEWHEEL: 0x20A,

    // https://msdn.microsoft.com/library/aa363480
    WM_DEVICECHANGE: 0x219,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-user
    WM_USER: 0x400,
    // https://docs.microsoft.com/windows/desktop/dataxchg/wm-copydata
    WM_COPYDATA: 0x4a,

    // Registered messages
    WM_SHELLHOOK: "SHELLHOOK",

    HWND_BROADCAST: 0xffff,

    // https://docs.microsoft.com/windows/desktop/winmsg/wm-inputlangchange
    WM_INPUTLANGCHANGE: 0x51,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange
    WM_SETTINGCHANGE: 0x1a,
    // https://docs.microsoft.com/windows/desktop/hidpi/wm-dpichanged
    WM_DPICHANGED: 0x02E0,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-syscolorchange
    WM_SYSCOLORCHANGE: 0x15,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-displaychange
    WM_DISPLAYCHANGE: 0x7e,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-themechanged
    WM_THEMECHANGED: 0x31a,

    // https://docs.microsoft.com/windows/win32/inputdev/wm-activate
    WM_ACTIVATE: 0x0006,
    // https://docs.microsoft.com/windows/win32/winmsg/wm-windowposchanging
    WM_WINDOWPOSCHANGING: 0x0046,
    // https://docs.microsoft.com/windows/win32/winmsg/wm-windowposchanged
    WM_WINDOWPOSCHANGED: 0x0047,


    // https://docs.microsoft.com/windows/win32/winmsg/window-styles
    WS_VISIBLE: 0x10000000,
    // https://docs.microsoft.com/windows/win32/winmsg/extended-window-styles
    WS_EX_TOOLWINDOW: 0x00000080,

    // https://msdn.microsoft.com/library/aa363205
    DBT_DEVNODES_CHANGED: 0x7,
    DBT_DEVICEARRIVAL: 0x8000,
    DBT_DEVICEREMOVEPENDING: 0x8003,
    DBT_DEVICEREMOVECOMPLETE: 0x8004,
    DBT_DEVTYP_VOLUME: 0x2,

    // https://msdn.microsoft.com/library/dd375731
    virtualKeyCodes: {
        VK_LBUTTON: 0x01, // Left mouse button
        VK_RBUTTON: 0x02, // Right mouse button
        VK_CANCEL: 0x03, // Control-break processing
        VK_MBUTTON: 0x04, // Middle mouse button (three-button mouse)
        VK_XBUTTON1: 0x05, // X1 mouse button
        VK_XBUTTON2: 0x06, // X2 mouse button
        VK_BACK: 0x08, // BACKSPACE key
        VK_TAB: 0x09, // TAB key
        VK_CLEAR: 0x0C, // CLEAR key
        VK_RETURN: 0x0D, // ENTER key
        VK_SHIFT: 0x10, // SHIFT key
        VK_CONTROL: 0x11, // CTRL key
        VK_MENU: 0x12, // ALT key
        VK_PAUSE: 0x13, // PAUSE key
        VK_CAPITAL: 0x14, // CAPS LOCK key
        VK_KANA: 0x15, // IME Kana mode
        VK_HANGUL: 0x15, // IME Hangul mode
        VK_HANGUEL: 0x15, // IME Hanguel mode (maintained for compatibility; use VK_HANGUL)
        VK_JUNJA: 0x17, // IME Junja mode
        VK_FINAL: 0x18, // IME final mode
        VK_HANJA: 0x19, // IME Hanja mode
        VK_KANJI: 0x19, // IME Kanji mode
        VK_ESCAPE: 0x1B, // ESC key
        VK_CONVERT: 0x1C, // IME convert
        VK_NONCONVERT: 0x1D, // IME nonconvert
        VK_ACCEPT: 0x1E, // IME accept
        VK_MODECHANGE: 0x1F, // IME mode change request
        VK_SPACE: 0x20, // SPACEBAR
        VK_PAGEUP: 0x21, // PAGE UP key
        VK_PAGEDOWN: 0x22, // PAGE DOWN key
        VK_PRIOR: 0x21, // PAGE UP key
        VK_NEXT: 0x22, // PAGE DOWN key
        VK_END: 0x23, // END key
        VK_HOME: 0x24, // HOME key
        VK_LEFT: 0x25, // LEFT ARROW key
        VK_UP: 0x26, // UP ARROW key
        VK_RIGHT: 0x27, // RIGHT ARROW key
        VK_DOWN: 0x28, // DOWN ARROW key
        VK_SELECT: 0x29, // SELECT key
        VK_PRINT: 0x2A, // PRINT key
        VK_EXECUTE: 0x2B, // EXECUTE key
        VK_SNAPSHOT: 0x2C, // PRINT SCREEN key
        VK_INSERT: 0x2D, // INS key
        VK_DELETE: 0x2E, // DEL key
        VK_HELP: 0x2F, // HELP key
        VK_LWIN: 0x5B, // Left Windows key (Natural keyboard)
        VK_RWIN: 0x5C, // Right Windows key (Natural keyboard)
        VK_APPS: 0x5D, // Applications key (Natural keyboard)
        VK_SLEEP: 0x5F, // Computer Sleep key
        VK_NUMPAD0: 0x60, // Numeric keypad 0 key
        VK_NUMPAD1: 0x61, // Numeric keypad 1 key
        VK_NUMPAD2: 0x62, // Numeric keypad 2 key
        VK_NUMPAD3: 0x63, // Numeric keypad 3 key
        VK_NUMPAD4: 0x64, // Numeric keypad 4 key
        VK_NUMPAD5: 0x65, // Numeric keypad 5 key
        VK_NUMPAD6: 0x66, // Numeric keypad 6 key
        VK_NUMPAD7: 0x67, // Numeric keypad 7 key
        VK_NUMPAD8: 0x68, // Numeric keypad 8 key
        VK_NUMPAD9: 0x69, // Numeric keypad 9 key
        VK_MULTIPLY: 0x6A, // Multiply key
        VK_ADD: 0x6B, // Add key
        VK_SEPARATOR: 0x6C, // Separator key
        VK_SUBTRACT: 0x6D, // Subtract key
        VK_DECIMAL: 0x6E, // Decimal key
        VK_DIVIDE: 0x6F, // Divide key
        VK_F1: 0x70, // F1 key
        VK_F2: 0x71, // F2 key
        VK_F3: 0x72, // F3 key
        VK_F4: 0x73, // F4 key
        VK_F5: 0x74, // F5 key
        VK_F6: 0x75, // F6 key
        VK_F7: 0x76, // F7 key
        VK_F8: 0x77, // F8 key
        VK_F9: 0x78, // F9 key
        VK_F10: 0x79, // F10 key
        VK_F11: 0x7A, // F11 key
        VK_F12: 0x7B, // F12 key
        VK_F13: 0x7C, // F13 key
        VK_F14: 0x7D, // F14 key
        VK_F15: 0x7E, // F15 key
        VK_F16: 0x7F, // F16 key
        VK_F17: 0x80, // F17 key
        VK_F18: 0x81, // F18 key
        VK_F19: 0x82, // F19 key
        VK_F20: 0x83, // F20 key
        VK_F21: 0x84, // F21 key
        VK_F22: 0x85, // F22 key
        VK_F23: 0x86, // F23 key
        VK_F24: 0x87, // F24 key
        VK_NUMLOCK: 0x90, // NUM LOCK key
        VK_SCROLL: 0x91, // SCROLL LOCK key
        VK_LSHIFT: 0xA0, // Left SHIFT key
        VK_RSHIFT: 0xA1, // Right SHIFT key
        VK_LCONTROL: 0xA2, // Left CONTROL key
        VK_RCONTROL: 0xA3, // Right CONTROL key
        VK_LMENU: 0xA4, // Left MENU key
        VK_RMENU: 0xA5, // Right MENU key
        VK_BROWSER_BACK: 0xA6, // Browser Back key
        VK_BROWSER_FORWARD: 0xA7, // Browser Forward key
        VK_BROWSER_REFRESH: 0xA8, // Browser Refresh key
        VK_BROWSER_STOP: 0xA9, // Browser Stop key
        VK_BROWSER_SEARCH: 0xAA, // Browser Search key
        VK_BROWSER_FAVORITES: 0xAB, // Browser Favorites key
        VK_BROWSER_HOME: 0xAC, // Browser Start and Home key
        VK_VOLUME_MUTE: 0xAD, // Volume Mute key
        VK_VOLUME_DOWN: 0xAE, // Volume Down key
        VK_VOLUME_UP: 0xAF, // Volume Up key
        VK_MEDIA_NEXT_TRACK: 0xB0, // Next Track key
        VK_MEDIA_PREV_TRACK: 0xB1, // Previous Track key
        VK_MEDIA_STOP: 0xB2, // Stop Media key
        VK_MEDIA_PLAY_PAUSE: 0xB3, // Play/Pause Media key
        VK_LAUNCH_MAIL: 0xB4, // Start Mail key
        VK_LAUNCH_MEDIA_SELECT: 0xB5, // Select Media key
        VK_LAUNCH_APP1: 0xB6, // Start Application 1 key
        VK_LAUNCH_APP2: 0xB7, // Start Application 2 key
        VK_OEM_1: 0xBA, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ';:' key
        VK_OEM_PLUS: 0xBB, // For any country/region, the '+' key
        VK_OEM_COMMA: 0xBC, // For any country/region, the ',' key
        VK_OEM_MINUS: 0xBD, // For any country/region, the '-' key
        VK_OEM_PERIOD: 0xBE, // For any country/region, the '.' key
        VK_OEM_2: 0xBF, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '/?' key
        VK_OEM_3: 0xC0, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '`~' key
        VK_OEM_4: 0xDB, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '[{' key
        VK_OEM_5: 0xDC, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '\|' key
        VK_OEM_6: 0xDD, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ']}' key
        VK_OEM_7: 0xDE, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the 'single-quote/double-quote' key
        VK_OEM_8: 0xDF, // Used for miscellaneous characters; it can vary by keyboard.
        VK_OEM_102: 0xE2, // Either the angle bracket key or the backslash key on the RT 102-key keyboard
        VK_PROCESSKEY: 0xE5, // IME PROCESS key
        VK_PACKET: 0xE7, // Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP: -, // 0xE8
        VK_ATTN: 0xF6, // Attn key
        VK_CRSEL: 0xF7, // CrSel key
        VK_EXSEL: 0xF8, // ExSel key
        VK_EREOF: 0xF9, // Erase EOF key
        VK_PLAY: 0xFA, // Play key
        VK_ZOOM: 0xFB, // Zoom key
        VK_NONAME: 0xFC, // Reserved
        VK_PA1: 0xFD, // PA1 key
        VK_OEM_CLEAR: 0xFE // Clear key
    },

    // https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-keybdinput
    KEYEVENTF_EXTENDEDKEY: 1,
    KEYEVENTF_KEYUP: 2,
    KEYEVENTF_UNICODE: 4,
    KEYEVENTF_SCANCODE: 8,


    LLKHF_EXTENDED:  0x01,
    LLKHF_INJECTED:  0x10,
    LLKHF_ALTDOWN:   0x20,
    LLKHF_UP:        0x80,
    LLMHF_INJECTED:  0x01,

    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registershellhookwindow
    HSHELL_WINDOWCREATED: 1,
    HSHELL_WINDOWDESTROYED: 2,
    HSHELL_WINDOWACTIVATED: 4,
    HSHELL_RUDEAPPACTIVATED: 0x8004,

    // https://msdn.microsoft.com/library/ms646306
    MAPVK_VK_TO_CHAR: 2,

    // The AccessibilityTemp values; https://msdn.microsoft.com/library/windows/desktop/bb879984.aspx
    disableAT: 2,
    enableAT: 3,

    MONITOR_DEFAULTTOPRIMARY: 1,
    CCHDEVICENAME: 32,
    QDC_ONLY_ACTIVE_PATHS: 2,
    // https://msdn.microsoft.com/en-us/library/windows/hardware/ff554003.aspx
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED: 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED: 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL: 0x80000000,

    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getsyscolor
    COLOR_DESKTOP: 1,
    // https://msdn.microsoft.com/en-us/library/296az74e.aspx
    UINT_MAX: 0xffffffff,

    // https://msdn.microsoft.com/library/ms724947
    SpiFlags: {
        SPIF_UPDATEINIFILE: 0x1,
        SPIF_SENDCHANGE: 0x2
    },

    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics
    SM_CXSCREEN: 0,
    SM_CYSCREEN: 1,
    SM_CXDOUBLECLK: 36,
    SM_CYDOUBLECLK: 37,

    SM_SWAPBUTTON: 23,

    INVALID_HANDLE_VALUE: 0xffffffff,

    // https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/ne-wingdi-displayconfig_topology_id
    DISPLAYCONFIG_TOPOLOGY_INTERNAL: 0,
    DISPLAYCONFIG_TOPOLOGY_CLONE: 1,
    DISPLAYCONFIG_TOPOLOGY_EXTEND: 2,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL: 3,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32: 4,

    // https://docs.microsoft.com/es-es/windows/desktop/api/winuser/nf-winuser-setdisplayconfig
    SDC_TOPOLOGY_INTERNAL:            0x00000001,
    SDC_TOPOLOGY_CLONE:               0x00000002,
    SDC_TOPOLOGY_EXTEND:              0x00000004,
    SDC_TOPOLOGY_EXTERNAL:            0x00000008,
    SDC_TOPOLOGY_SUPPLIED:            0x00000010,

    SDC_VALIDATE:                     0x00000040,
    SDC_APPLY:                        0x00000080,

    // https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa
    STARTF_USESHOWWINDOW: 0x1,
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow
    SW_HIDE: 0,
    SW_SHOWNORMAL: 1,
    SW_SHOWMINIMIZED: 2,
    SW_SHOWMAXIMIZED: 3,
    SW_SHOWNOACTIVATE: 4,

    // https://docs.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shappbarmessage
    ABE_BOTTOM: 3,
    ABN_POSCHANGED: 1,
    ABM_NEW: 0x00000000,
    ABM_REMOVE: 0x00000001,
    ABM_SETPOS: 0x00000003,
    ABM_ACTIVATE: 0x00000006,
    ABM_WINDOWPOSCHANGED: 0x0000009


};

fluid.each(windows.API_constants.returnCodesLookup, function (value, key) {
    windows.API_constants.returnCodes[value] = +key;
});

/*
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682489(v=vs.85).aspx
 * TH32CS_SNAPALL
 */
var TH32CS_SNAPHEAPLIST = 0x00000001;
var TH32CS_SNAPMODULE = 0x00000008;
var TH32CS_SNAPPROCESS = 0x00000002;
var TH32CS_SNAPTHREAD = 0x00000004;

var TH32CS_SNAPALL = TH32CS_SNAPHEAPLIST | TH32CS_SNAPMODULE |
    TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD;

windows.API_constants.TH32CS_SNAPALL = TH32CS_SNAPALL;
windows.API_constants.TH32CS_SNAPPROCESS = TH32CS_SNAPPROCESS;

var c = windows.API_constants;

// https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839%28v=vs.85%29.aspx
windows.PROCESSENTRY32 = new Struct([
    [t.DWORD, "dwSize"],
    [t.DWORD, "cntUsage"],
    [t.DWORD, "th32ProcessID"],
    [t.ULONG_PTR, "th32DefaultHeapID"],
    [t.DWORD, "th32ModuleID"],
    [t.DWORD, "cntThreads"],
    [t.DWORD, "th32ParentProcessID"],
    [t.LONG, "pcPriClassBase"],
    [t.DWORD, "dwFlags"],
    // TODO: This needs refactoring to adopt new type t.TCHAR instead of an array of
    // chars.
    [arrayType("char", c.MAX_PATH), "szExeFile"]
]);

// https://msdn.microsoft.com/library/ms685996
windows.SERVICE_STATUS = new Struct([
    [t.DWORD, "dwServiceType"],
    [t.DWORD, "dwCurrentState"],
    [t.DWORD, "dwControlsAccepted"],
    [t.DWORD, "dwWin32ExitCode"],
    [t.DWORD, "dwServiceSpecificExitCode"],
    [t.DWORD, "dwCheckPoint"],
    [t.DWORD, "dwWaitHint"]
]);


// http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
windows.HighContrast = new Struct({
    "cbSize": "uint32",
    "dwFlags": "int32",
    "lpszDefaultScheme": "pointer"
});
windows.highContrastPointer = ref.refType(windows.HighContrast);

// https://msdn.microsoft.com/en-us/library/windows/desktop/aa379651(v=vs.85).aspx
windows.AudioDescription = new Struct({
    "cbSize": "uint32",
    "Enabled": "int32",
    "Locale": "uint32"
});
windows.audioDescriptionPointer = ref.refType(windows.AudioDescription);

// http://msdn.microsoft.com/en-us/library/windows/desktop/dd145037(v=vs.85).aspx
windows.LogFont = new Struct([
    ["int32",  "lfHeight"],
    ["int32",  "lfWidth"],
    ["int32",  "lfEscapement"],
    ["int32",  "lfOrientation"],
    ["int32",  "lfWeight"],
    ["uchar",  "lfItalic"],
    ["uchar",  "lfUnderline"],
    ["uchar",  "lfStrikeOut"],
    ["uchar",  "lfCharSet"],
    ["uchar",  "lfOutPrecision"],
    ["uchar",  "lfClipPrecision"],
    ["uchar",  "lfQuality"],
    ["uchar",  "lfPitchAndFamily"],
    [arrayType(t.TCHAR, c.MAX_NAME), "lfFaceName"]
]);
windows.logFontPointer = ref.refType(windows.LogFont);

// http://msdn.microsoft.com/en-us/library/windows/desktop/ff729175(v=vs.85).aspx
windows.NonClientMetrics = new Struct([
    ["uint32",   "cbSize"],
    ["int32",    "iBorderWidth"],
    ["int32",    "iScrollWidth"],
    ["int32",    "iScrollHeight"],
    ["int32",    "iCaptionWidth"],
    ["int32",    "iCaptionHeight"],
    [windows.LogFont,  "lfCaptionFont"],
    ["int32",    "iSmCaptionWidth"],
    ["int32",    "iSmCaptionHeight"],
    [windows.LogFont,  "lfSmCaptionFont"],
    ["int32",    "iMenuWidth"],
    ["int32",    "iMenuHeight"],
    [windows.LogFont,  "lfMenuFont"],
    [windows.LogFont,  "lfStatusFont"],
    [windows.LogFont,  "lfMessageFont"],
    ["int32", "iPaddedBorderWidth"]
]);
windows.nonClientMetricsPointer = ref.refType(windows.NonClientMetrics);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd373652(v=vs.85).aspx
windows.StickyKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"]
]);
windows.StickyKeysPointer = ref.refType(windows.StickyKeys);

// https://docs.microsoft.com/es-es/windows/desktop/api/winuser/ns-winuser-tagtogglekeys
windows.ToggleKeys = new Struct({
    "cbSize": "uint32",
    "dwFlags": "int32"
});
windows.ToggleKeysPointer = ref.refType(windows.ToggleKeys);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd318079(v=vs.85).aspx
windows.FilterKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"],
    ["uint32",   "iWaitMSec"],
    ["uint32",   "iDelayMSec"],
    ["uint32",   "iRepeatMSec"],
    ["uint32",   "iBounceMSec"]
]);
windows.FilterKeysPointer = ref.refType(windows.FilterKeys);

// https://msdn.microsoft.com/en-us/library/windows/desktop/dd373593(v=vs.85).aspx
windows.MouseKeys = new Struct([
    ["uint32",   "cbSize"],
    ["uint32",   "dwFlags"],
    ["uint32",   "iMaxSpeed"],
    ["uint32",   "iTimeToMaxSpeed"],
    ["uint32",   "iCtrlSpeed"],
    ["uint32",   "dwReserved1"],
    ["uint32",   "dwReserved2"]
]);
windows.MouseKeysPointer = ref.refType(windows.MouseKeys);

// TODO Define additional structures used in calls to SystemParametersInfo here.

// https://msdn.microsoft.com/library/ms644967
windows.KBDLLHookStruct = new Struct([
    [t.DWORD,     "vkCode"],
    [t.DWORD,     "scanCode"],
    [t.DWORD,     "flags"],
    [t.DWORD,     "time"],
    [t.ULONG_PTR, "dwExtraInfo"]
]);
windows.KBDLLHookStructPointer = ref.refType(windows.KBDLLHookStruct);

// https://msdn.microsoft.com/library/ms644970
windows.MSDLLHookStruct = new Struct([
    [t.LONG,      "ptX"],
    [t.LONG,      "ptY"],
    [t.DWORD,     "mouseData"],
    [t.DWORD,     "flags"],
    [t.DWORD,     "time"],
    [t.ULONG_PTR, "dwExtraInfo"]
]);
windows.MSDLLHookStructPointer = ref.refType(windows.MSDLLHookStruct);

// https://msdn.microsoft.com/library/ms633576
windows.WNDCLASSW = new Struct([
    [t.UINT,      "style"],
    ["void*",     "lpfnWndProc"],
    [t.INT,       "cbClsExtra"],
    [t.INT,       "cbWndExtra"],
    [t.HANDLE,    "hInstance"],
    [t.HANDLE,    "hIcon"],
    [t.HANDLE,    "hCursor"],
    [t.HANDLE,    "hbrBackground"],
    [t.PVOID,     "lpszMenuName"],
    ["char*",     "lpszClassName"]
]);

// https://msdn.microsoft.com/library/aa363246
windows.DEV_BROADCAST_HDR = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"]
]);

// https://msdn.microsoft.com/library/aa363249
windows.DEV_BROADCAST_VOLUME = new Struct([
    [t.DWORD, "size"],
    [t.DWORD, "deviceType"],
    [t.DWORD, "reserved"],
    [t.DWORD, "unitMask"],
    [t.DWORD, "flags"]
]);

// https://msdn.microsoft.com/library/dd162897
windows.RECT = new Struct([
    [t.LONG, "left"],
    [t.LONG, "top"],
    [t.LONG, "right"],
    [t.LONG, "bottom"]
]);

// https://msdn.microsoft.com/library/dd162805
windows.POINT = new Struct([
    [t.LONG, "x"],
    [t.LONG, "y"]
]);

// https://docs.microsoft.com/windows/desktop/api/Winuser/ns-winuser-tagcopydatastruct
windows.COPYDATASTRUCT = new Struct([
    ["int", "dwData"],
    [t.DWORD, "cbData"],
    ["void*", "lpData"]
]);

// https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa
windows.STARTUPINFO = new Struct([
    [t.DWORD, "cb"],
    ["char*", "lpReserved"],
    ["char*", "lpDesktop"],
    ["char*", "lpTitle"],
    [t.DWORD, "dwX"],
    [t.DWORD, "dwY"],
    [t.DWORD, "dwXSize"],
    [t.DWORD, "dwYSize"],
    [t.DWORD, "dwXCountChars"],
    [t.DWORD, "dwYCountChars"],
    [t.DWORD, "dwFillAttribute"],
    [t.DWORD, "dwFlags"],
    [t.WORD, "wShowWindow"],
    [t.WORD, "cbReserved2"],
    [t.LP, "lpReserved2"],
    [t.HANDLE, "hStdInput"],
    [t.HANDLE, "hStdOutput"],
    [t.HANDLE, "hStdError"]
]);

// https://msdn.microsoft.com/library/ms684873
windows.PROCESS_INFORMATION = new Struct([
    [t.HANDLE, "hProcess"],
    [t.HANDLE, "hThread"],
    [t.DWORD, "dwProcessId"],
    [t.DWORD, "dwThreadId"]
]);

// https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-input
// INPUT struct using the ki:KEYBDINPUT union field.
windows.KEY_INPUT = new Struct([
    [t.DWORD, "type"],
    // KEYBDINPUT https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-keybdinput
    [t.WORD, "wVk"],
    [t.WORD, "wScan"],
    [t.DWORD, "dwFlags"],
    [t.DWORD, "time"],
    [t.ULONG_PTR, "dwExtraInfo"]
]);

// https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-windowpos
windows.WINDOWPOS = new Struct([
    [t.HANDLE, "hwndInsertAfter"],
    [t.HANDLE, "hwnd"],
    [t.INT,  "x"],
    [t.INT,  "y"],
    [t.INT,  "cx"],
    [t.INT,  "cy"],
    [t.UINT, "flags"]
]);

// https://docs.microsoft.com/windows/win32/api/shellapi/ns-shellapi-appbardata
windows.APPBARDATA = new Struct([
    [t.DWORD, "cbSize"],
    [t.HANDLE, "hWnd"],
    [t.UINT, "uCallbackMessage"],
    [t.UINT, "uEdge"],
    [windows.RECT, "rc"],
    [t.UINT, "lParam"]
]);

/**
 * Contains flags used in the "dwFlags" field of various structures
 * that are used in calls to the SystemParametersInfo function.
 */
windows.flagConstants = {
    // HIGHCONTRAST flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
    "HCF_AVAILABLE":       0x00000002,
    "HCF_CONFIRMHOTKEY":   0x00000008,
    "HCF_HIGHCONTRASTON":  0x00000001,
    "HCF_HOTKEYACTIVE":    0x00000004,
    "HCF_HOTKEYAVAILABLE": 0x00000040,
    "HCF_HOTKEYSOUND":     0x00000010,
    "HCF_INDICATOR":       0x00000020,

    // STICKYKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd373652%28v=vs.85%29.aspx
    "SKF_AUDIBLEFEEDBACK": 0x00000040,
    "SKF_AVAILABLE":       0x00000002,
    "SKF_HOTKEYACTIVE":    0x00000004,
    "SKF_STICKYKEYSON":    0x00000001,

    // FILTERKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318079%28v=vs.85%29.aspx
    "FKF_AVAILABLE":       0x00000002,
    "FKF_CLICKON":         0x00000040,
    "FKF_CONFIRMHOTKEY":   0x00000008,
    "FKF_FILTERKEYSON":    0x00000001,
    "FKF_HOTKEYACTIVE":    0x00000004,
    "FKF_HOTKEYSOUND":     0x00000010,
    "FKF_INDICATOR":       0x00000020,

    // MOUSEKEYS flags
    // https://msdn.microsoft.com/en-us/library/windows/desktop/dd373593(v=vs.85).aspx
    "MKF_AVAILABLE":       0x00000002,
    "MKF_CONFIRMHOTKEY":   0x00000008,
    "MKF_HOTKEYACTIVE":    0x00000004,
    "MKF_HOTKEYSOUND":     0x00000010,
    "MKF_INDICATOR":       0x00000020,
    "MKF_LEFTBUTTONDOWN":  0x01000000,
    "MKF_LEFTBUTTONSEL":   0x10000000,
    "MKF_MODIFIERS":       0x00000040,
    "MKF_MOUSEKEYSON":     0x00000001,
    "MKF_MOUSEMODE":       0x80000000,
    "MKF_REPLACENUMBERS":  0x00000080,
    "MKF_RIGHTBUTTONDOWN": 0x02000000,
    "MKF_RIGHTBUTTONSEL":  0x20000000,

    // TOGGLEKEYS flags
    // https://docs.microsoft.com/es-es/windows/desktop/api/winuser/ns-winuser-tagtogglekeys
    "TKF_AVAILABLE":       0x00000002,
    "TKF_CONFIRMHOTKEY":   0x00000008,
    "TKF_HOTKEYACTIVE":    0x00000004,
    "TKF_HOTKEYSOUND":     0x00000010,
    "TKF_INDICATOR":       0x00000020,
    "TKF_TOGGLEKEYSON":    0x00000001,

    // FORMATMESSAGE flags
    // https://docs.microsoft.com/es-es/windows/desktop/Debug/retrieving-the-last-error-code
    "FORMAT_MESSAGE_ALLOCATE_BUFFER":   0x00000100,
    "FORMAT_MESSAGE_FROM_SYSTEM":       0x00001000,
    "FORMAT_MESSAGE_IGNORE_INSERTS":    0x00000200,

    // LANGUAGE Identifiers flags
    "LANG_NEUTRAL": 0x00,
    "SUBLANG_DEFAULT": 0x01

    // TODO Define additional flags used across various structures here.
};

// ACCESS TYPES
// https://docs.microsoft.com/en-us/windows/desktop/secauthz/standard-access-rights
windows.accessTypes = {
    "DELETE":                     0x00010000,
    "READ_CONTROL":               0x00020000,
    "WRITE_DAC":                  0x00040000,
    "WRITE_OWNER":                0x00080000,
    "SYNCHRONIZE":                0x00100000,

    "STANDARD_RIGHTS_REQUIRED":   0x000F0000,

    "STANDARD_RIGHTS_READ":       0x00020000,
    "STANDARD_RIGHTS_WRITE":      0x00020000,
    "STANDARD_RIGHTS_EXECUTE":    0x00020000,
    "STANDARD_RIGHTS_ALL":        0x001F0000,
    "SPECIFIC_RIGHTS_ALL":        0x0000FFFF,

    "GENERIC_READ":               0x80000000,
    "GENERIC_WRITE":              0x40000000,
    "GENERIC_EXECUTE":            0x20000000,
    "GENERIC_ALL":                0x10000000
};

// _ACCESS_MODE enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_access_mode
windows.accessMode = {
    "NOT_USED_ACCESS":      0,
    "GRANT_ACCESS":         1,
    "SET_ACCESS":           2,
    "DENY_ACCESS":          3,
    "REVOKE_ACCESS":        4,
    "SET_AUDIT_SUCCESS":    5,
    "SET_AUDIT_FAILURE":    6
};

// _TRUSTEE_FORM enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_trustee_form
windows.trusteeForm = {
    "TRUSTEE_IS_SID":              0,
    "TRUSTEE_IS_NAME":             1,
    "TRUSTEE_BAD_FORM":            2,
    "TRUSTEE_IS_OBJECTS_AND_SID":  3,
    "TRUSTEE_IS_OBJECTS_AND_NAME": 4
};

// _TRUSTEE_TYPE enum
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ne-accctrl-_trustee_type
windows.trusteeType = {
    "TRUSTEE_IS_UNKNOWN":          0,
    "TRUSTEE_IS_USER":             1,
    "TRUSTEE_IS_GROUP":            2,
    "TRUSTEE_IS_DOMAIN":           3,
    "TRUSTEE_IS_ALIAS":            4,
    "TRUSTEE_IS_WELL_KNOWN_GROUP": 5,
    "TRUSTEE_IS_DELETED":          6,
    "TRUSTEE_IS_INVALID":          7,
    "TRUSTEE_IS_COMPUTER":         8
};

// https://docs.microsoft.com/en-us/windows/desktop/secauthz/security-information
windows.securityInformation = {
    "OWNER_SECURITY_INFORMATION":               0x00000001,
    "GROUP_SECURITY_INFORMATION":               0x00000002,
    "DACL_SECURITY_INFORMATION":                0x00000004,
    "SACL_SECURITY_INFORMATION":                0x00000008,
    "LABEL_SECURITY_INFORMATION":               0x00000010,
    "ATTRIBUTE_SECURITY_INFORMATION":           0x00000020,
    "SCOPE_SECURITY_INFORMATION":               0x00000040,
    "PROCESS_TRUST_LABEL_SECURITY_INFORMATION": 0x00000080,
    "ACCESS_FILTER_SECURITY_INFORMATION":       0x00000100,
    "BACKUP_SECURITY_INFORMATION":              0x00010000,

    "PROTECTED_DACL_SECURITY_INFORMATION":      0x80000000,
    "PROTECTED_SACL_SECURITY_INFORMATION":      0x40000000,
    "UNPROTECTED_DACL_SECURITY_INFORMATION":    0x20000000,
    "UNPROTECTED_SACL_SECURITY_INFORMATION":    0x10000000
};

// Inheritance flags for primary ACE object
// https://docs.microsoft.com/en-us/windows/desktop/api/accctrl/ns-accctrl-_explicit_access_a
windows.inheritanceFlags = {
    "NO_INHERITANCE":                       0x0,
    "SUB_OBJECTS_ONLY_INHERIT":             0x1,
    "SUB_CONTAINERS_ONLY_INHERIT":          0x2,
    "SUB_CONTAINERS_AND_OBJECTS_INHERIT":   0x3,
    "INHERIT_NO_PROPAGATE":                 0x4,
    "INHERIT_ONLY":                         0x8
};

/**
 * The MAKELONG win32 macro. Combines two 16-bit numbers into a 32-bit unsigned number.
 *
 * https://msdn.microsoft.com/library/ms632660
 *
 * @param {Number} low The low-order word of the new value.
 * @param {Number} high The high-order word of the new value.
 * @return {Number} A 32-bit number consisting of the two 16-bit numbers, low and high.
 */
windows.makeLong = function (low, high) {
    return ((low & 0xffff) | ((high & 0xffff) << 16)) >>> 0;
};

/**
 * The LOWORD win32 macro. Gets the low 16-bit number from a 32-bit number.
 *
 * https://msdn.microsoft.com/library/ms632659
 *
 * @param {Number} value The 32-bit number from which the low 16 bits are retrieved.
 * @return {Number} A number consisting of the lower 16 bits of value.
 */
windows.loWord = function (value) {
    return value & 0xffff;
};

/**
 * The HIWORD win32 macro. Gets the high 16-bit number from a 32-bit number.
 *
 * https://msdn.microsoft.com/library/ms632657
 *
 * @param {Number} value The 32-bit number from which the high 16 bits are retrieved.
 * @return {Number} A number consisting of the higher 16 bits of value.
 */
windows.hiWord = function (value) {
    return (value >> 16) & 0xffff;
};

/**
 * Contains structures that are used in calls to the SystemParametersInfo function,
 * accessible by their names. Used to dynamically instantiate the appropriate structure.
 */
windows.structures = {
    "HIGHCONTRAST":     windows.HighContrast,
    "NONCLIENTMETRICS": windows.NonClientMetrics,
    "LOGFONT":          windows.LogFont,
    "STICKYKEYS":       windows.StickyKeys,
    "FILTERKEYS":       windows.FilterKeys,
    "MOUSEKEYS":        windows.MouseKeys,
    "AUDIODESCRIPTION": windows.AudioDescription,
    "TOGGLEKEYS":       windows.ToggleKeys
    // TODO Add additional structures that we need to instantiate here.
};

gpii.pointerToHex = function (pointer, count) {
    var togo = "";
    for (var i = 0; i < count; ++i) {
        var nbyte = pointer.readUInt8(i);
        togo += (nbyte < 16 ? "0" : "") + nbyte.toString(16);
        if (i !== count - 1) {
            togo += " ";
        }
    }
    return togo;
};

// Slow but short method to parse very forgiving hex streams - any non-hex characters will be ignored. Digits
// forming a single byte must be adjacent
gpii.hexToPointer = function (hexString) {
    var buffer = [];
    var i;
    for (i = 0; i < hexString.length; ++i) {
        var c = hexString.charAt(i);
        var digit = parseInt(c, 16);
        if (!isNaN(digit)) {
            buffer.push(digit);
        }
    }
    if ((buffer.length % 2) === 1) {
        fluid.fail("Odd number of hex digits in buffer " + hexString);
    }

    var togo = new Buffer(buffer.length / 2);

    for (i = 0; i < buffer.length; i += 2) {
        togo.writeUInt8(buffer[i] * 16 + buffer[i + 1], i / 2);
    }
    return {
        pointer: togo,
        length: buffer.length / 2
    };
};

windows.convertReturnCode = function (code) {
    return "Return code " + code + ": " + c.returnCodesLookup[code];
};

windows.checkReturnCode = function (code) {
    if (code !== 0) {
        fluid.fail(windows.convertReturnCode(code));
    }
};

windows.toWideChar = function (string) {
    var stringBuffer = new Buffer(string);

    var chars = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, NULL, 0);

    var buffer = new Buffer(chars * 2 + 2); // 2 extra bytes for the null character

    var chars2 = windows.kernel32.MultiByteToWideChar(c.CP_UTF8, 0, stringBuffer, stringBuffer.length, buffer, chars);
    if (chars2 !== chars) {
        fluid.fail("Expected to write " + chars + " characters, only wrote " + chars2);
    }

    buffer.writeInt16BE(0, chars * 2);  // add the null character at the end
    return {
        pointer: buffer,
        length: chars * 2 + 2
    };
};

windows.fromWideChar = function (buffer) {
    buffer = ref.reinterpretUntilZeros(buffer, 2, 0);

    var bytes = windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, NULL, 0, NULL, NULL);

    var convertBuffer = new Buffer(bytes);

    windows.kernel32.WideCharToMultiByte(c.CP_UTF8, 0, buffer, buffer.length / 2, convertBuffer, bytes, NULL, NULL);

    return convertBuffer.toString();
};

/**
 * Create a buffer containing the wide-character representation of string.
 * Used to convert strings to a buffer usable by the Windows API.
 *
 * @param {String} string The original string.
 * @return {Buffer} The buffer containing the UTF-16 string.
 */
windows.stringToWideChar = function (string) {
    return new Buffer(string + "\u0000", "ucs2"); // add null at the end
};

/**
 * Reads a buffer containing the wide-character representation of string.
 * Used to convert strings from a buffer used by the Windows API, into a node UTF-8 string.
 *
 * @param {Buffer} buffer The buffer containing the UTF-16 string.
 * @return {String} The UTF-8 node string.
 */
windows.stringFromWideChar = function (buffer) {
    return ref.reinterpretUntilZeros(buffer, 2, 0).toString("ucs2");
};

/**
 * Convert an array of strings into a wide-character C-style array of the array elements.
 * That is, the items of the array seperated by null and terminated by double null.
 *
 * @param {Array<String>} array The array.
 * @return {Buffer} The buffer containing the UTF-16 string array.
 */
windows.stringToWideCharArray = function (array) {
    // A null at the end of each item.
    var string = fluid.makeArray(array).join("\u0000") + "\u0000";
    // Also add the double-null at the end
    return new Buffer(string + "\u0000\u0000", "ucs2");
};


/**
 * Convert a buffer containing an array of wide-char strings, to an array of strings.
 *
 * The input array is a C style string array, where the values are separated by null characters. The array is terminated
 * by an additional 2 null characters.
 *
 * @param {Buffer} buffer The buffer to convert.
 * @return {Array<String>} An array of string.
 */
windows.stringFromWideCharArray = function (buffer) {
    var togo = [];
    var offset = 0;
    var current;
    do {
        current = ref.reinterpretUntilZeros(buffer, 2, offset);
        if (current.length) {
            togo.push(current.toString("ucs2"));
            offset += current.length + 2; // Extra 2 bytes is to skip the (wide) null separator
        }
    } while (current.length > 0);

    return togo;
};

/**
 * Ensures the bytes of a buffer begin on an even address.
 *
 * Unicode registry functions need the string pointers aligned on 16bit boundary.
 *
 * @param {Buffer} buffer The buffer to align.
 * @return {Buffer} The original buffer, or a copy.
 */
windows.ensureAlignment = function (buffer) {
    if (ref.address(buffer) & 1) { // not aligned
        var alignedBuffer = new Buffer(buffer.length + 1);

        if (ref.address(alignedBuffer) & 1) { // the new buffer is not aligned as well
            buffer.copy(alignedBuffer, 1);
            return alignedBuffer.slice(1);

        } else { // the new buffer is OK
            buffer.copy(alignedBuffer);
            return alignedBuffer.slice(0, alignedBuffer.length - 1);
        }
    }

    return buffer;
};

/**
 * If a structure is not already defined, creates it by using the structure template in the payload.
 * If such is not provided, throws an exception.
 *
 * @param {Object} payload Settings handler payload.
 */
windows.defineStruct = function (payload) {
    if (payload.options.pvParam.type === "struct" && !windows.structures[payload.options.pvParam.name]) {
        if (!payload.options.pvParam.template) {
            throw "Cannot create structure " + payload.options.pvParam.name + " - payload.options.pvParam.template not found!";
        }

        windows.structures[payload.options.pvParam.name] = new Struct(payload.options.pvParam.template);
    }
};

/**
 * Creates an empty structure with a given name. It should be registered in the
 * <code>windows.structures</code> map with that name. If the structure has a <code>cbSize</code>
 * member, the function sets that member to the size of the structure using <code>ffi.sizeof</code>.
 *
 * @param {String} structName The name of the structure to create. Should be registered in the
 *                 <code>windows.structures</code> map.
 * @return {Object} The newly created structure with its <code>cbSize</code> member initialized.
 */
windows.createEmptyStructure = function (structName) {
    var struct = new windows.structures[structName]();

    if (struct.cbSize !== undefined) {
        struct.cbSize = windows.structures[structName].size;
        // TODO: This needs to be dropped. It's duplicated in SpiSettingsHandler too,
        // creating a poison dependency. It should be in the struct definition or
        // let it pass because it only applies on Windows Server 2003 and
        // Windows XP/2000
        if (structName === "NONCLIENTMETRICS" && os.release() < "6") {
            struct.cbSize -= 4; // do not unclude NONCLIENTMETRICS.iPaddedBorderWidth
        }
    }

    return struct;
};

/**
 * Takes an array of flag names, applies binary OR among them and returns the result.
 * Used to supply the "dwFlags" argument of some structures.
 *
 * @param {Array} flagNamesArray An array of flag names, which must be in allFlags.
 * @param {Object} allFlags [optional] An object of all possible flags and their value. Defaults to windows.flagConstants.
 * @param {String} op [optional] The operation, either "or" (default) or "and".
 * @return {Number} The values of the array items OR'd together.
 */
windows.combineFlags = function (flagNamesArray, allFlags, op) {
    allFlags = allFlags || windows.flagConstants;
    var or = op !== "and" && op !== "&";

    var combine = or
        ? function (left, right) { return left | right; }
        : function (left, right) { return left & right; };

    var combinedFlags = or
        ? 0 : 1;

    if (!fluid.isArrayable(flagNamesArray)) {
        fluid.log("GPII Windows SpiSettingsHandler combineFlags: array expected!");
        return 0;
    }
    for (var index in flagNamesArray) {
        combinedFlags = combine(combinedFlags, allFlags[flagNamesArray[index]]);
    }
    return combinedFlags;
};

/**
 * Resolves a list of flags into the numeric value. Flags can either be a string, with the delimiter of either
 * "|" or "&" specifying the operation:
 *
 * Ex: "F1 | F2 | F3" || "F1 & F2 & F3".
 *
 * Or an array of flag strings (in which case the operation is binary OR).
 *
 * Ex: ["F1", "F2", "F3"].
 *
 * The value of each possible flag is specified in allFlags.
 *
 * @param {String|Array} flags The list of flags to resolve.
 * @param {Object} allFlags An associative object of every flag. In which keys are flag names and values
 *  are flag values.
 * @return {Number} The numeric value of flags.
 */
windows.resolveFlags = function (flags, allFlags) {
    var togo = 0;

    var op = "or";
    // Split a string into an array.
    if (typeof(flags) === "string") {
        var or = flags.indexOf("&") < 0;
        op = or ? "or" : "and";
        flags = flags.split(/ *[&|,]+ */);
    }
    if (fluid.isArrayable(flags)) {
        togo = gpii.windows.combineFlags(flags, allFlags, op);
    } else {
        fluid.fail("windows.resolveFlags was passed an unknown type of flags");
    }

    return togo;
};

/**
 * Gets the value of a given flag name.
 *
 * @param {String} flagName The name of the flag whose value we need.
 * @return {Number} The value of the flag.
 */
windows.getFlagValue = function (flagName) {
    var flagValue = windows.flagConstants[flagName];
    if (flagValue === undefined) {
        fluid.fail("Unknown flag name " + flagName);
    }
    return flagValue;
};

/**
 * Accesses consecutive fields of an object.
 *
 * @param {Object} object The object to be accessed.
 * @param {String} path A string containing the consecutive field names, separated by '.'
 * @param {Object} setValue <optional> A new value to be stored in the field.
 * @return {Object} The value stored in the field.
 */
windows.resolvePath = function (object, path, setValue) {
    var flagsIndex = path.indexOf("dwFlags");
    if (flagsIndex !== -1) {
        var path1 = path.substr(0, flagsIndex - 1);
        var flagName = path.substr(path.lastIndexOf(".") + 1);
        return windows.accessFlag(fluid.get(object, path1), flagName, setValue);

    } else {
        if (setValue !== undefined) {
            if (typeof setValue === "string") {
                setValue = windows.stringToWideChar(setValue);
            }
            fluid.set(object, path, setValue);
        }

        var value = fluid.get(object, path);
        return Buffer.isBuffer(value) ? windows.stringFromWideChar(value) : value;
    }
};

/**
 * Accesses a single flag in a flags field of an object.
 *
 * @param {Object} object The object to be accessed.
 * @param {String} flagName A string containing the flag name according to the Windows API.
 * @param {Object} setValue <optional> A new value for the flag.
 * @return {Object} The value of the flag.
 */
windows.accessFlag = function (object, flagName, setValue) {
    var flagValue = windows.getFlagValue(flagName);

    if (setValue !== undefined) {
        setValue = Boolean(setValue);
        // The '>>>' operator is needed to convert the number back to an unsigned 32-bit int.
        if (setValue) {
            object.dwFlags = (object.dwFlags | flagValue) >>> 0;
        } else {
            object.dwFlags = (object.dwFlags & ~flagValue) >>> 0;
        }
    }

    return Boolean(object.dwFlags & flagValue);
};

/**
 * Converts an array to a buffer.
 *
 * @param {Array} array The array to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Buffer} A buffer representing the raw memory allocated for the array.
 */
windows.arrayToBuffer = function (array, type) {
    var size = ref.coerceType(windows.types[type]).size;
    var buf = new Buffer(array.length * size);

    for (var i = 0; i < array.length; ++i) {
        ref.set(buf, i * size, array[i], windows.types[type]);
    }

    return buf;
};

/**
 * Converts a buffer to an array.
 *
 * @param {Buffer} buffer The buffer to be converted.
 * @param {String} type The type of the array according to the Windows API.
 * @return {Array|String} An array containing the values stored in the buffer, or a string if the buffer is has type "TCHAR".
 */
windows.bufferToArray = function (buffer, type) {
    var result;

    if (type === "TCHAR") {
        var sBuf = buffer.toString("utf16le");
        var nullPos = sBuf.indexOf("\0");

        result = sBuf.substring(0, nullPos);
    } else {
        var array = [];
        var size = ref.coerceType(windows.types[type]).size;

        for (var i = 0; i < buffer.length / size; ++i) {
            array[i] = ref.get(buffer, i * size, windows.types[type]);
        }

        result = array;
    }

    return result;
};

/**
 * Enumerates all top-level windows on the desktop, or all child windows (and their descendants) of a given window,
 * invoking the callback for each one.
 *
 * @param {Number} hwndParent [optional] The handle of the window whose child windows are to be enumerated.
 * @param {Function} callback Called for each Window, returning a value other than undefined to break the enumeration.
 * @return {Mixed} The last return value of callback.
 */
windows.enumerateWindows = function (hwndParent, callback) {
    if (!callback && typeof(hwndParent) === "function") {
        callback = hwndParent;
        hwndParent = null;
    }

    var result;
    // Suppress "no-unused-vars" - lparam argument is required for EnumWindowsProc.
    // eslint-disable-next-line no-unused-vars
    var proc = gpii.windows.EnumWindowsProc(function (hwnd, lparam) {
        result = callback(hwnd);
        return result === undefined;
    });

    if (hwndParent) {
        gpii.windows.user32.EnumChildWindows(hwndParent, proc, 0);
    } else {
        gpii.windows.user32.EnumWindows(proc, 0);
    }

    return result;
};

/**
 * Determines whether this process is running under WoW64. That is, 32-bit node on 64-bit Windows.
 *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa384249(v=vs.85).aspx
 *
 * @return {Boolean} true if this process is 32-bit, and the OS is 64-bit otherwise false.
 */
windows.isWow64 = function () {
    var ptr = ref.alloc(windows.types.DWORD);
    gpii.windows.kernel32.IsWow64Process(-1, ptr);
    return !!ptr.deref();
};

/**
 * Get the process ID that owns the given window.
 *
 * @param {Number} hwnd The window handle.
 * @return {Number} The process ID.
 */
windows.getWindowProcessId = function (hwnd) {
    var pid = null;
    if (hwnd) {
        var buf = ref.alloc(windows.types.DWORD);
        windows.user32.GetWindowThreadProcessId(hwnd, buf);
        pid = buf.deref();
    }

    return pid;
};

/**
 * Returns a given window's rectangle.
 *
 * @param {Number} hwnd The window handle.
 * @return {Object} Contains the left, top, right, bottom, width, and height values of the window.
 */
windows.getWindowRect = function (hwnd) {
    var rect = new windows.RECT();
    var success = windows.user32.GetWindowRect(hwnd, rect.ref());
    var result;
    if (success) {
        result = {
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom
        };
        result.width = result.right - result.left;
        result.height = result.bottom - result.top;
    }
    return result;
};

/**
 * Gets the top-level window that's a parent of a given window.
 *
 * @param {Number} hwnd Handle of the child window.
 * @return {Number} Handle of the top-level window that's a parent of a given window.
 */
windows.getTopParent = function (hwnd) {
    var parent = hwnd;
    var togo;
    while (parent !== 0) {
        togo = parent;
        parent = windows.user32.GetParent(parent);
    }

    return togo;
};

/**
 * Finds all windows with the given class name.
 *
 * @param {String|Array<String>} className The window class, or an array describing the path to a class (starting at the
 * top-level parent), used to find child windows.
 * @param {Number} parent [optional] The parent handle from which the search begins.
 * @return {Array<String>} The window handles of the matching windows.
 */
windows.findWindows = function (className, parent) {
    var path = fluid.makeArray(className);

    var windowClass = path.shift();

    var classBuffer = Buffer.alloc(0xff);
    classBuffer.ref().fill(0);

    // Get the window that has the specified class
    var matches = [];
    windows.enumerateWindows(parent, function (hwndFound) {
        if (windows.user32.GetClassNameW(hwndFound, classBuffer, classBuffer.length)) {
            var cls = windows.stringFromWideChar(classBuffer);
            if (cls === windowClass) {
                if (path.length > 0) {
                    var child = windows.findWindows(path, hwndFound);
                    matches.push.apply(matches, child);
                } else {
                    matches.push(hwndFound);
                }
            }
        }
    });

    return matches;
};

/**
 * Gets a localised resource string from an executable.
 *
 * @param {String} dll The dll name that contains the string.
 * @param {Number} resourceID The numeric resource identifier of the string.
 * @param {String} defaultValue [optional] The string to return if no string was found.
 * @return {String} The localised string, or defaultValue.
 */
windows.getResourceString = function (dll, resourceID, defaultValue) {
    // "@filename,-resId"
    return fluid.firstDefined(windows.getIndirectString("@" + dll + ",-" + resourceID), defaultValue);
};

/**
 * Wrapper for SHLoadIndirectString:
 * "Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins
 * with the '@' symbol)."
 *
 * This function accepts a string in the form of "@dllname,-resourceID". This will load the resource string identified
 * by the numeric resourceID, from the specified dll. Strings that do not begin with "@" will be returned as-is.
 *
 * See: https://docs.microsoft.com/en-gb/windows/desktop/api/shlwapi/nf-shlwapi-shloadindirectstring
 *
 * @param {String} indirectString A string in the form of "@dllname,-resourceID" (consult MSDN for other forms).
 * @return {String} The localised resource string which the indirectString resolves do, or undefined on error.
 */
windows.getIndirectString = function (indirectString) {
    var ret;
    if (indirectString.startsWith("@")) {
        var src = windows.stringToWideChar(indirectString);
        var buf = Buffer.alloc(0xfff);
        if (gpii.windows.shlwapi.SHLoadIndirectString(src, buf, buf.length, ref.NULL) === 0) {
            ret = gpii.windows.stringFromWideChar(buf);
        } else {
            ret = undefined;
        }
    } else {
        ret = indirectString;
    }

    return ret;
};

/**
 * Waits for a condition, by polling a given function. A promise is returned, resolving when the condition is met or
 * rejecting upon timeout. If the condition is already met, then the returned promise will be resolved.
 *
 * The function is called repeatedly (with a delay) until it returns a truthful value, or a period of time has elapsed.
 *
 * @param {Function} func The function to call which checks the condition.
 * @param {Object} [options] Options
 * @param {Number|Boolean|Object} options.conditionValue The value that the function will return to indicate the condition is met.
 *  This is compared using '===', but the default is to match any truthy value.
 * @param {Number} options.argument An argument to pass to the function.
 * @param {Number} options.timeout How long to wait (ms) before timing out, or null (default) for no timeout.
 * @param {Number} options.pollDelay The delay (ms) between each poll. 500ms by default.
 * @param {Boolean} options.dontReject If true, then resolve the promise with "timeout" instead of rejecting.
 * @param {Object} options.error The error object used when rejecting.
 * @return {Promise} Promise resolving when the condition is met, rejecting upon timeout.
 *
 * @todo A better place for this should be found/created, as it's not even specific to Windows.
 */
windows.waitForCondition = function (func, options) {
    var defaultOptions = {
        timeout: null,
        pollDelay: 500,
        dontReject: false
    };
    options = fluid.extend(defaultOptions, options);

    var promise = fluid.promise();
    var startTime = process.hrtime();

    var checkCondition = function () {
        // See if the condition has been met.
        var returnValue = func(options.argument);
        var conditionMet;
        if (options.conditionValue === undefined) {
            conditionMet = !!returnValue;
        } else {
            conditionMet = (returnValue === options.conditionValue);
        }

        if (conditionMet) {
            promise.resolve();
        } else {
            // Check the time.
            var timedout = false;
            if (typeof(options.timeout) === "number") {
                var hr = process.hrtime(startTime);
                // combine seconds + nanoseconds into milliseconds
                var timeTakenMs = (hr[0] * 1000) + (hr[1] / 1e6);

                if (timeTakenMs >= options.timeout) {
                    timedout = true;
                    if (options.dontReject) {
                        promise.resolve("timeout");
                    } else {
                        promise.reject(options.error);
                    }
                }
            }

            if (!timedout) {
                setTimeout(checkCondition, options.pollDelay);
            }
        }
    };

    checkCondition();
    return promise;
};

/**
 * Returns an Error containing the arguments.
 *
 * @param {String} message The message.
 * @param {String|Number} returnCode [optional] The return code of the function causing the error.
 * @param {String|Number} errorCode [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error.
 */
windows.win32error = function (message, returnCode, errorCode) {
    var err = new Error(windows.win32errorText(message, returnCode, errorCode));
    err.returnCode = returnCode;
    err.errorCode = errorCode;
    err.isError = true;
    return err;
};

/**
 * Creates an error message for a win32 error.
 *
 * @param {String} message The message.
 * @param {String|Number} returnCode [optional] The return code of the function causing the error.
 * @param {String|Number} errorCode [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error message.
 */
windows.win32errorText = function (message, returnCode, errorCode) {
    var text = "win32 error: " + message;
    text += (returnCode === undefined) ? "" : (" return:" + returnCode);
    text += " win32:" + (errorCode || windows.kernel32.GetLastError());
    return text;
};

/**
 * Copy of the macro to create a language identifier from a primary language identifier and
 * a sublanguage identifier.
 *
 * https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-makelangid
 *
 * @param {Number} p Primary language identifier.
 * @param {Number} s Sublanguage identifier.
 * @return {Number} A language identifier which is the combination of the primary language identifier,
 *  and the sublanguage identifier.
 */
windows.makeLangId = function (p, s) {
    var uintS = s >>> 0;
    var uintP = p >>> 0;

    return ((uintS << 10) | uintP);
};

/**
 * Get the last system error in human readable format.
 *
 * @param {Number} dw The system error code to be translated.
 * @return {String} A message with the string representation of the system error code.
 */
windows.translateLastError = function (dw) {
    var maxOutputBuf = 64 * 1024;
    var buffer = new Buffer(maxOutputBuf);

    var formatFlags =
        windows.flagConstants.FORMAT_MESSAGE_FROM_SYSTEM |
        windows.flagConstants.FORMAT_MESSAGE_IGNORE_INSERTS;
    var langId = windows.makeLangId(windows.flagConstants.LANG_NEUTRAL, windows.flagConstants.SUBLANG_DEFAULT);

    var formatRes = windows.kernel32.FormatMessageW(
        formatFlags,
        null,
        dw,
        langId,
        buffer,
        maxOutputBuf,
        null
    );

    if (formatRes === 0) {
        var errCode = windows.kernel32.GetLastError();
        fluid.fail("windows.translateLastError: Error translating system error code - '" + errCode + "'");
    }

    return windows.fromWideChar(buffer);
};

/**
 * Execute a command, ensuring it uses the native System32 directory instead of the 32-bit version.
 *
 * When running as a 32-bit process on a 64-bit OS, in order make sure the native version is executed the 64-bit
 * cmd.exe will be used to perform the invocation.
 *
 * @param {String} command The command to execute.
 * @param {Object} [options] The options for child_process.exec.
 * @param {function} [callback] Called when the process terminates.
 * @return {Object} Returns what child_process.exec returns.
 */
gpii.windows.nativeExec = function (command, options, callback) {
    var execOptions = fluid.extend({}, options);
    if (gpii.windows.isWow64()) {
        execOptions.shell = process.env.SYSTEMROOT + "\\Sysnative\\cmd.exe";
    }
    return child_process.exec(command, execOptions, callback);
};

/**
 * Gets a list of all drives on the system.
 * @return {Array<String>} Array of paths to each drive on the system (eg, "c:\")
 */
gpii.windows.getAllDrives = function () {
    var drivesBuffer = Buffer.alloc(0xff);
    windows.kernel32.GetLogicalDriveStringsW(drivesBuffer.length, drivesBuffer);

    var drives = windows.stringFromWideCharArray(drivesBuffer);

    return drives;
};

/**
 * Gets the USB drives that are available.
 *
 * @param {Array<String>} drivePaths [optional] Array of drives to check. Omit to check all drives on the system.
 * @return {Array<String>} Array of paths to each USB drive.
 */
gpii.windows.getUsbDrives = function (drivePaths) {
    var DRIVE_REMOVABLE = 2, DRIVE_FIXED = 3;
    var FILE_SHARE_READ = 1, FILE_SHARE_WRITE = 2;
    var OPEN_EXISTING = 3;
    var IOCTL_STORAGE_QUERY_PROPERTY = 0x2d1400;
    var BusTypeUsb = 7; // STORAGE_BUS_TYPE.BusTypeUsb

    // Get all the drives.
    var drives = drivePaths || gpii.windows.getAllDrives();

    drives = drives.filter(function (drivePath) {
        var busType = 0;
        var driveHandle = null;

        try {
            // GetDriveType is used to get a basic list of drives. This doesn't discriminate internal drives from usb
            // drives, but it does eliminate things like CD-ROM and network drives.
            var type = gpii.windows.kernel32.GetDriveTypeW(gpii.windows.stringToWideChar(drivePath));
            if (type === DRIVE_FIXED || type === DRIVE_REMOVABLE) {
                // Get a handle to the volume. Volume path is in the form of "\\.\A:"
                var volumePath = "\\\\.\\" + drivePath.substr(0, 2);
                driveHandle = gpii.windows.kernel32.CreateFileW(
                    gpii.windows.stringToWideChar(volumePath), 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);

                if (driveHandle === windows.API_constants.INVALID_HANDLE_VALUE) {
                    fluid.log("Unable to open the volume " + drivePath + ": "
                        + gpii.windows.win32errorText("CreateFileW", driveHandle));
                    driveHandle = null;
                }
            }

            if (driveHandle !== null) {
                // PropertyStandardQuery and StorageDeviceProperty is used for the query - both zeroes so just pass a buffer of
                // zeroes.
                var querySize = 12; // sizeof(STORAGE_PROPERTY_QUERY)
                var query = Buffer.alloc(querySize);
                query.fill(0);

                // Stores the resulting device descriptor
                var devDescSize = 40; // sizeof(STORAGE_DEVICE_DESCRIPTOR)
                var devDesc = Buffer.alloc(devDescSize);
                devDesc.fill(0);
                // Unused, but required.
                var byteCountBuffer = ref.alloc(gpii.windows.types.DWORD);

                // Get the device descriptor for the volume.
                var success = gpii.windows.kernel32.DeviceIoControl(
                    driveHandle,
                    IOCTL_STORAGE_QUERY_PROPERTY,
                    query, querySize,
                    devDesc, devDescSize,
                    byteCountBuffer.ref(), 0);

                if (success) {
                    // Get the busType from the device descriptor.
                    var busTypeOffset = 28;
                    busType = devDesc.readInt32LE(busTypeOffset);
                } else {
                    fluid.log("Unable to determine the bus type for drive " + drivePath + ": "
                        + gpii.windows.win32errorText("DeviceIoControl", success));
                }
            }

        } finally {
            if (driveHandle !== null) {
                gpii.windows.kernel32.CloseHandle(driveHandle);
            }
        }

        return busType === BusTypeUsb;
    });

    return drives;
};

/**
 * Used by the "Open USB" button. Gets the user's USB drives. That is, those without a token file.
 * If all drives have a token file, then all are returned.
 *
 * @param {Array<String>} usbDrives [optional] The root paths to the usb drives to check, omit to check all USB drives
 * on the system.
 * @return {Array<String>} Array of paths to each drive.
 */
gpii.windows.getUserUsbDrives = function (usbDrives) {
    usbDrives = usbDrives || gpii.windows.getUsbDrives();
    var tokenFile = ".gpii-user-token.txt";
    var promiseTogo = fluid.promise();

    if (usbDrives.length < 1) {
        // Always return the single drive.
        promiseTogo.resolve(usbDrives);
    } else {
        var promises = [];
        var result = [];

        // Check each drive for the token file.
        fluid.each(usbDrives, function (drivePath) {
            var tokenPath = path.join(drivePath, tokenFile);
            var promise = fluid.promise();
            promises.push(promise);

            fs.access(tokenPath, function (err) {
                if (err) {
                    // No token file found, so add it to the result.
                    result.push(drivePath);
                }
                promise.resolve(!err);
            });
        });

        fluid.promise.sequence(promises).then(function () {
            if (result.length === 0) {
                // No drives where added (they all had a token file), then return all of them.
                promiseTogo.resolve(usbDrives);
            } else {
                promiseTogo.resolve(result);
            }
        });
    }

    return promiseTogo;

};

/**
 * Utility function to remove files or folders.
 *
 * TODO: Ideally this operation should be async, but right now we don't support
 * async 'lifecycle actions'. Since we pretend to use this function there, we
 * will keep the sync version for now.
 *
 * More info: https://issues.gpii.net/browse/GPII-434
 *
 * @param {String} path The path of the element to be removed.
 * @param {Object} [options] Options
 * @param {Boolean} options.recursive Flag indicating if the element is a directory and should be removed recursively.
 * @param {Boolean} options.silent Flag for a silent fail in case the element doesn't exist.
 * @return {Promise} A promise that resolves on success or rejects on failure holding a object with the error
 *  information.
 */
gpii.windows.rm = function (path, options) {
    var defaultOptions = {
        recursive: false,
        silent: false
    };
    options = fluid.extend(defaultOptions, options);
    var result = fluid.promise();

    if (fs.existsSync(path)) {
        if (options.recursive) {
            try {
                rimraf.sync(path);
                result.resolve();
            } catch (err) {
                result.reject({
                    code: err.code,
                    message: "Removing dir failed with error '" + err + "'"
                });
            }
        } else {
            try {
                fs.unlinkSync(path);
                result.resolve();
            } catch (err) {
                result.reject({
                    code: err.code,
                    message: "Removing file failed with error '" + err + "'"
                });
            }
        }
    } else {
        if (options.silent) {
            result.resolve();
            fluid.log("Warning: Trying to remove non-existent element.");
        } else {
            result.reject({code: "ENOENT", message: "Invalid path '" + path + "'."});
        }
    }

    return result;
};

fluid.defaults("gpii.windows.rm", {
    gradeNames: "fluid.function",
    argumentMap: {
        path: 0,
        options: 1
    }
});

/**
 * Expands the environment variables in a string, which are surrounded by '%'.
 * For example, the input string of "%SystemRoot%\System32" returns "C:\Windows\System32".
 *
 * @param {String} input The input string.
 * @return {String} The input string with the environment variables expanded.
 */
windows.expandEnvironmentStrings = function (input) {
    var result;
    if (input && input.length > 0) {
        var inputBuffer = gpii.windows.stringToWideChar(input);
        // Initial buffer of MAX_PATH should be big enough for most cases (assuming this function is called for paths).
        var len = Math.max(gpii.windows.API_constants.MAX_PATH + 1, input.length + 20);
        var outputBuffer = Buffer.alloc((len + 1) * 2);
        // Expand the variables
        var requiredSize = gpii.windows.kernel32.ExpandEnvironmentStringsW(inputBuffer, outputBuffer, len);
        if (requiredSize > len) {
            // Initial buffer is too small - call again with the correct size.
            len = requiredSize;
            outputBuffer = Buffer.alloc((len + 1) * 2);
            requiredSize = gpii.windows.kernel32.ExpandEnvironmentStringsW(inputBuffer, outputBuffer, len);
        }
        if (requiredSize === 0) {
            throw gpii.windows.win32Error("ExpandEnvironmentStringsW", requiredSize);
        }

        result = gpii.windows.stringFromWideChar(outputBuffer);
    } else {
        result = "";
    }

    return result;
};

exports.windows = windows;
