/*
 * Windows Kill Process Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");
var child_process = require("child_process");

var ffi = require("ffi");
var arrayType = require("ref-array");
var Struct = require("ref-struct");

require("../processHandling.js");

fluid.registerNamespace("gpii.tests.windows.processHandling");

var waitExe = "gpii-process-handling-test.exe";
var waitExePath = null;
gpii.tests.windows.processHandling.teardowns = [];

jqUnit.module("gpii.tests.windows.processHandling", {
    setup: function () {
        // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
        // This command is a glorified "sleep" that is also able to be terminated "nicely".
        waitExePath = path.join(process.env.TEMP, waitExe);
        shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), waitExePath);
    },
    teardown: function () {
        while (gpii.tests.windows.processHandling.teardowns.length) {
            gpii.tests.windows.processHandling.teardowns.pop()();
        }
        if (waitExePath !== null) {
            gpii.windows.killProcessByName(waitExe);
            shelljs.rm(waitExePath);
        }
    }
});

/**
 * Starts test-window.exe, returning a promise that resolves with an object containing the window handle, pid, and
 * the ChildProcess returned from cp.spawn.
 * @param {Array} output {Optional} Empty array to contain the output lines.
 * @return {Promise} Resolves with {hwnd, pid, child} when ready.
 */
gpii.tests.windows.processHandling.startTestProcess = function (output) {
    var promise = fluid.promise();
    output = output || [];

    // Starts a process which is known to create a window.
    var exeName = "test-window.exe";
    var exePath = path.join(__dirname, exeName);
    var args = " -window";

    fluid.log("Executing ", exePath, args);
    var child = child_process.exec(exePath + args);

    child.stdout.on("data", function (buf) {
        var data = buf.toString();
        output.push.apply(output, data.split(/[\r\n]+/));
        // Wait for the window to be created
        var match = data.match(/Window created.*\bhwnd:([0-9]+).*\bpid:([0-9]+)/);
        if (match) {
            var value = {
                hwnd: parseInt(match[1]),
                pid: parseInt(match[2]),
                child: child
            };
            promise.resolve(value);
        }
    });
    return promise;
};


jqUnit.test("Testing findProcessByName", function () {
    // Find a process that isn't running.
    var pid = gpii.windows.findProcessByName("a non-matching process.exe");
    jqUnit.assertEquals("Process should not have been found running", null, pid);

    // Find a process that is running.
    pid = gpii.windows.findProcessByName("node.exe");
    jqUnit.assertNotEquals("Process should have been found running", null, pid);

    // Find a process that is running, full details
    var details = gpii.windows.findProcessByName("node.exe", false, true);
    jqUnit.assertNotEquals("Process should have been found running (fullInfo)", null, details);
    jqUnit.assertTrue("pid should be a number", typeof(details.pid) === "number");
    jqUnit.assertTrue("ppid should be a number", typeof(details.ppid) === "number");
    jqUnit.assertEquals("exeFile should be node.exe", "node.exe", details.exeFile.toLowerCase());

    // Find multiple processes. There's always more than one svchost.exe running on Windows.
    var pids = gpii.windows.findProcessByName("svchost.exe", true);
    jqUnit.assertTrue("Should have found several matching process.", pids.length > 1);

    // Find all processes.
    var allPids = gpii.windows.findProcessByName(null, true);
    jqUnit.assertTrue("Should be several running processes.", allPids.length > 1);
    jqUnit.assertTrue("Should be more processes than svchost.", allPids.length > pids.length);

});

jqUnit.test("Testing isProcessRunning", function () {
    // Check a PID that isn't running.
    var running = gpii.windows.isProcessRunning(-1);
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check a PID that is running.
    running = gpii.windows.isProcessRunning(process.pid);
    jqUnit.assertTrue("Process should have been found running", running);

    // Check an exe file that isn't running.
    running = gpii.windows.isProcessRunning("a non-matching process.exe");
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check an exe file that is running.
    running = gpii.windows.isProcessRunning("node.exe");
    jqUnit.assertTrue("Process should have been found running", running);

    // Check multiple processes. There's always more than one svchost.exe running on Windows.
    running = gpii.windows.isProcessRunning("svchost.exe", true);
    jqUnit.assertTrue("Process should have been found running (multiple processes)", running);
});

jqUnit.asyncTest("Testing timeout waiting for processes start", function () {
    jqUnit.expect(1);

    var exe = "a non-matching process.exe";
    gpii.windows.waitForProcessStart(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not be running");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing timeout waiting for processes termination", function () {
    jqUnit.expect(1);

    var exe = "node.exe";
    gpii.windows.waitForProcessTermination(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not have terminated");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing waiting for processes start and end", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // Timeout waiting for the process start/end after 10 seconds.
    var options = { timeout: 10000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(waitExe, options)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Wait for it to die
            gpii.windows.waitForProcessTermination(waitExe, options)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Failed to detect process termination.");
                });

            // Tell the process to stop now.
            child_process.execSync("waitfor /SI waitForProcessTerminationTest");
        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });

    // Create the process, with a 5 second timeout
    child_process.exec(waitExePath + " waitForProcessTerminationTest /T 5 > nul");
});

jqUnit.asyncTest("Testing Killing Processes", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // On the call below, async is true because if it is false shelljs will
    // wait around until it is manually killed before continuing with the
    // rest of the tests.
    var command =  waitExePath + " killProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command, function (error, stdout, stderr) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Process should have terminated with code SIGKILL", 9, error.code);
        fluid.log("Program output:", stdout);
        fluid.log("Program stderr:", stderr);
        jqUnit.start();
    });

    // Kill the process when it starts
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("The process has started");
            gpii.windows.killProcessByName(waitExe);
        });
});

jqUnit.asyncTest("Testing closeProcessByName", function () {
    jqUnit.expect(3);
    var exitCode = 5;

    // Start a process that creates a window.
    var exeName = "test-window.exe";
    var exePath = path.join(__dirname, exeName);
    var command =  exePath + " -window";

    fluid.log("Executing " + command);
    var child = child_process.exec(command, function (error) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Exit code", exitCode, error.code);
    });

    child.stdout.on("data", function (data) {
        // Wait for the window to be created
        if (data.match("Window created")) {
            jqUnit.assert("Window is created");

            gpii.windows.closeProcessByName(exeName, {cleanOnly: true, timeout: 1000, exitCode: exitCode})
                .then(function (clean) {
                    jqUnit.assertTrue("Should have closed cleanly", clean);
                    jqUnit.start();
                }, function (e) {
                    fluid.log(e.message);
                    jqUnit.fail("Process should have closed.");
                    gpii.windows.killProcessByName(exeName);
                });
        }
    });
});

jqUnit.asyncTest("Testing closeProcessByName (window-less process)", function () {
    jqUnit.expect(3);

    // Start a process that does not have a window.
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("Process started");

            // The process doesn't have any windows, so this should fail to terminate it.
            gpii.windows.closeProcessByName(waitExe, {cleanOnly: true})
                .then(function () {
                    jqUnit.fail("Process should not have closed.");
                }, function (e) {
                    jqUnit.assert("Process not closed");
                    fluid.log(e.message);
                    // Retry with force
                    gpii.windows.closeProcessByName(waitExe, {cleanOnly: false})
                        .then(function () {
                            jqUnit.assert("Process terminated");
                            jqUnit.start();
                        });
                });
        });

    var command =  waitExePath + " closeProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command);
});

jqUnit.asyncTest("Testing getProcessPath", function () {
    jqUnit.expect(3);

    var exeName = waitExe;
    var exePath = waitExePath;
    var args = [ "getProcessPathTest", "/T", "30"];

    fluid.log("Executing " + exePath);
    var child = child_process.spawn(exePath, args);

    gpii.windows.waitForProcessStart(exeName)
        .then(function () {
            jqUnit.assert("Process started");

            // Test with the PID.
            var result1 = gpii.windows.getProcessPath(child.pid);
            jqUnit.assertEquals("The exe path should be correct (pid)", exePath, result1);

            // Test with the process handle.
            var hProcess = gpii.windows.kernel32.OpenProcess(
                gpii.windows.API_constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, child.pid);

            try {
                var result2 = gpii.windows.getProcessPath(null, hProcess);
                jqUnit.assertEquals("The exe path should be correct (processHandle)", exePath, result2);
            } finally {
                gpii.windows.kernel32.CloseHandle(hProcess);
            }

            child.kill();
        });
    child.on("close", jqUnit.start);
});

jqUnit.asyncTest("Test getProcessWindows", function () {

    gpii.tests.windows.processHandling.startTestProcess().then(function (child) {

        var runningPids = gpii.windows.findProcessByName(null, true);
        var processWindows = gpii.windows.getProcessWindows();

        jqUnit.assertNotNull("processWindows should not be null", processWindows);
        jqUnit.assertNotEquals("processWindows should return something", 0, processWindows.length);

        var pids = fluid.keys(processWindows);
        fluid.each(pids, function (pid) {
            pid = parseInt(pid);
            jqUnit.assertFalse("processWindows should only contain numeric keys", isNaN(pid));

            var isRunning = runningPids.indexOf(pid) > -1;
            jqUnit.assertTrue("processWindows should only contain running processes", isRunning);
        });

        // Assumes this node process doesn't create a window.
        jqUnit.assertFalse("processWindows should only return processes with a window",
            processWindows.hasOwnProperty(process.pid));

        var testProcess = processWindows[child.pid];
        jqUnit.assertTrue("processWindows should contain the test process", !!testProcess);
        jqUnit.assertTrue("The test process should have a window", testProcess.length > 0);
        jqUnit.assertEquals("The test process window should be returned", child.hwnd, testProcess[0]);

        child.child.kill();
        jqUnit.start();
    });
});

jqUnit.test("Test getRestartableProcesses", function () {

    var procs = gpii.windows.getRestartableProcesses();

    // Find windows explorer (at least one is restartable)
    var explorerPids = gpii.windows.findProcessByName("explorer.exe", true);
    var found = fluid.find(procs,function (p) {
        if (explorerPids.indexOf(p.pid) > -1) {
            return true;
        }
    });

    jqUnit.assertTrue("Explorer should be restartable", found);

    // Don't find this process
    found = fluid.find(procs,function (p) {
        return p.pid === process.pid;
    });

    jqUnit.assertFalse("This process should not be restartable", found);
});

var t = gpii.windows.types;

// https://msdn.microsoft.com/library/aa373674
var CCH_RM_MAX_SVC_NAME = 63;
var CCH_RM_MAX_APP_NAME = 255;
gpii.tests.windows.processHandling.RM_PROCESS_INFO = new Struct([
    [ gpii.windows.RM_UNIQUE_PROCESS, "Process"],
    [ arrayType("char", (CCH_RM_MAX_APP_NAME + 1) * 2), "strAppName"],
    [ arrayType("char", (CCH_RM_MAX_SVC_NAME + 1) * 2), "strServiceShortName"],
    [ "int32", "ApplicationType"],
    [ "uint32", "AppStatus"],
    [ "uint32", "TSSessionId"],
    [ "int32", "bRestartable"]
]);
gpii.tests.windows.processHandling.RM_PROCESS_INFOS =
    arrayType(gpii.tests.windows.processHandling.RM_PROCESS_INFO);

gpii.tests.windows.processHandling.restartManager = ffi.Library("rstrtmgr", {
    // https://msdn.microsoft.com/library/aa373661
    "RmGetList": [
        t.DWORD, [ t.DWORD, "uint*", "uint*", gpii.tests.windows.processHandling.RM_PROCESS_INFOS, t.LPDWORD ]
    ]
});

/**
 * Check if the restart manager session has been set up correctly by inspecting the result of RmGetList.
 *
 * @param sessionHandle {Number} The session handle.
 * @return {boolean} true if it has.
 */
gpii.tests.windows.processHandling.checkRestartManager = function (stage, sessionHandle, pids) {
    jqUnit.expect(6);

    var messagePrefix = "After " + stage + ": ";

    // RM_APP_STATUS: https://msdn.microsoft.com/library/aa373669
    var RmStatusRunning = 1;

    var procCount = pids.length;
    var procInfoNeededBuf = (new Buffer(4)).fill(0);
    var procInfoCountBuf = new Buffer(4);
    procInfoCountBuf.writeUInt32LE(procCount);

    var procInfos = new gpii.tests.windows.processHandling.RM_PROCESS_INFOS(procCount);

    var rebootReasons = new Buffer(4);

    var result = gpii.tests.windows.processHandling.restartManager.RmGetList(
        sessionHandle, procInfoNeededBuf, procInfoCountBuf, procInfos, rebootReasons);

    jqUnit.assertEquals(messagePrefix + "RmGetList should return 0 (ERROR_SUCCESS)", 0, result);

    var procInfoCount = procInfoCountBuf.readUInt32LE();
    jqUnit.assertEquals(messagePrefix + "Number of procInfos returned by RmGetList should be the same number of pids",
        pids.length, procInfoCount);

    var pidsFound = [];
    for (var n = 0; n < procInfoCount; n++) {
        var p = procInfos[n];
        pidsFound.push(p.Process.dwProcessId);

        var index = pids.indexOf(p.Process.dwProcessId);
        jqUnit.assertTrue(messagePrefix + "RmGetList should only return expected pids", index > -1);

        jqUnit.assertEquals(messagePrefix + "Process should be running (AppStatus = RmStatusRunning)",
            RmStatusRunning, p.AppStatus);
        jqUnit.assertTrue(messagePrefix + "Process should be restartable",
            RmStatusRunning, !!p.bRestartable);
    }

    jqUnit.assertDeepEq(messagePrefix + "RmGetList should return all pids",
        pids.sort(), pidsFound.sort());
};

/**
 * Replaces RmShutdown and RmRestart with an implementation that just checks if they have been called properly.
 *
 * @param expectedPids {Number[]} The processes that should have been restarted.
 * @param restart {boolean} True if a call to RmRestart is expected.
 */
gpii.tests.windows.processHandling.mockRestartManager = function (expectedPids, restart) {
    jqUnit.expect(4);
    if (restart) {
        jqUnit.expect(3);
    }

    expectedPids = fluid.copy(expectedPids);

    var rmShutdown = gpii.windows.restartManager.RmShutdown.async;
    var rmRestart = gpii.windows.restartManager.RmRestart;
    gpii.tests.windows.processHandling.teardowns.push(function () {
        gpii.windows.restartManager.RmShutdown.async = rmShutdown;
        gpii.windows.restartManager.RmRestart = rmRestart;
    });

    gpii.windows.restartManager.RmShutdown.async = function (dwSessionHandle, lActionFlags, fnStatus, callback) {
        var RmShutdownOnlyRegistered = 10;
        jqUnit.assertFalse("RmShutdown dwSessionHandle must be a number", isNaN(dwSessionHandle));
        jqUnit.assertEquals(
            "RmShutdown lActionFlags must be RmShutdownOnlyRegistered", RmShutdownOnlyRegistered, lActionFlags);
        // For some reason, ref doesn't like being required from this script.
        jqUnit.assertEquals("RmShutdown fnStatus must be ref.NULL", 0, fnStatus && fnStatus.length);
        jqUnit.assertEquals("RmShutdown callback must be a function", "function", typeof(callback));

        gpii.tests.windows.processHandling.checkRestartManager("RmShutdown", dwSessionHandle, expectedPids);

        // Invoke the callback with a successful return.
        callback(gpii.windows.API_constants.returnCodes.ERROR_SUCCESS);
    };
    gpii.windows.restartManager.RmRestart = function (dwSessionHandle, dwRestartFlags, fnStatus) {
        if (restart) {
            jqUnit.assertFalse("RmShutdown dwSessionHandle must be a number", isNaN(dwSessionHandle));
            // "Reserved. This parameter should be 0."
            jqUnit.assertEquals("RmShutdown dwRestartFlags must be 0", 0, dwRestartFlags);
            jqUnit.assertEquals("RmShutdown fnStatus must be ref.NULL", 0, fnStatus && fnStatus.length);

            gpii.tests.windows.processHandling.checkRestartManager("RmRestart", dwSessionHandle, expectedPids);
        } else {
            jqUnit.fail("Call to RmRestart was not expected.");
        }
    };
};

jqUnit.asyncTest("Test restartProcesses", function () {
    jqUnit.expect(2);

    // Windows explorer does register as restartable, but restarting it (and potentially failing, because it's a test)
    // doesn't feel right. Adding /s to explorer.exe opens an explorer window in a separate process however that process
    // doesn't register itself as restartable.
    // An attempt was made to make test-window.c register for auto-restart, but for some unknown reason the the call to
    // RmShutdown timed out when the process was started by this one (via spawn or exec).
    // So, the RmShutdown and RmRestart functions are mocked to check they're being called correctly.

    var exeFile = "explorer.exe";
    var pids = gpii.windows.findProcessByName(exeFile, true);
    var explorerPids = fluid.transform(gpii.windows.getRestartableProcesses(pids), function (proc) {
        return proc.pid;
    });

    gpii.tests.windows.processHandling.mockRestartManager(explorerPids, true);

    var promise = gpii.windows.restartProcesses(explorerPids);
    jqUnit.assertTrue("restartProcesses must return a promise", fluid.isPromise(promise));

    promise.then(function () {
        jqUnit.assert("restartProcesses promise resolved");
        jqUnit.start();
    }, function (e) {
        fluid.log(e);
        jqUnit.fail("restartProcesses promise rejected");
    });
});

jqUnit.asyncTest("Test closeApplications", function () {

    // Get the restartable explorer process(es)
    var explorerPids = gpii.windows.findProcessByName("explorer.exe", true);
    explorerPids = fluid.transform(gpii.windows.getRestartableProcesses(explorerPids), function (proc) {
        return proc.pid;
    });

    var tests = [
        {
            level: "low",
            restart: true,
            expectedMessages: []
        },
        {
            level: "low",
            restart: false,
            expectedMessages: []
        },
        {
            level: "medium",
            restart: true,
            expectedMessages: [
                "WM_QUERYENDSESSION",
                "WM_ENDSESSION"
            ]
        },
        {
            level: "medium",
            restart: false,
            expectedMessages: [
                "WM_QUERYENDSESSION",
                "WM_ENDSESSION"
            ]
        },
        {
            level: "high",
            restart: true,
            expectedMessages: [
                // medium:
                "WM_QUERYENDSESSION",
                "WM_ENDSESSION",
                // high:
                "WM_QUIT"
            ]
        },
        {
            level: "high",
            restart: false,
            expectedMessages: [
                // medium:
                "WM_QUERYENDSESSION",
                "WM_ENDSESSION",
                // high:
                "WM_QUIT"
            ]
        }
    ];

    jqUnit.expect(tests.length);

    var currentTest;
    var runTest = function (testIndex) {
        if (testIndex >= tests.length) {
            jqUnit.start();
            return;
        }

        currentTest = tests[testIndex];
        var output = [];
        gpii.tests.windows.processHandling.startTestProcess(output).then(function (child) {
            child.child.on("exit", function () {
                var messages = fluid.transform(output, function (line) {
                    var m = line.match(/^message: (WM_((QUERY)?ENDSESSION|QUIT))$/);
                    return m && m[1];
                }).filter(fluid.identity);

                jqUnit.assertDeepEq("test: " + currentTest.level + ": Expected messages must be received",
                    currentTest.expectedMessages, messages);

                runTest(testIndex + 1);
            });

            // Expect only explorer to be restarted by restart manager.
            gpii.tests.windows.processHandling.mockRestartManager(explorerPids, currentTest.restart);

            var restartPids = [child.pid];
            restartPids.push.apply(restartPids, explorerPids);

            gpii.windows.closeApplications(currentTest.level, {
                pids: restartPids, quitDelay: 1, restart: currentTest.restart
            }).then(function () {
                setTimeout(function () {
                    child.child.kill();
                }, 500);
            }, jqUnit.fail);

        }, jqUnit.fail);

    };

    runTest(0);
});

jqUnit.asyncTest("Testing execWaitAndClose", function () {
    jqUnit.expect(1);

    gpii.tests.windows.processHandling.startTestProcess().then(function () {
        gpii.windows.execWaitAndClose(
            "cmd.exe",
            ["dir"],
            "test-window.exe",
            {
                processToWait: "test-window.exe",
                processToWaitState: "Open",
                timeout: 1000,
                commandTimeout: 1000
            }
        ).then(
            function () {
                jqUnit.assert("execWaitAndClose promise resolved.");
                jqUnit.start();
            },
            function (err) {
                jqUnit.fail(err);
            }
        );
    });
});

gpii.tests.windows.processHandling.mockCloseApplications = function () {

    var closeApplications = gpii.windows.closeApplications;
    gpii.tests.windows.processHandling.teardowns.push(function () {
        gpii.windows.closeApplications = closeApplications;
    });

    gpii.windows.closeApplications = function (level) {
        var levels = {
            low: 1,
            medium: 2,
            high: 3
        };

        var levelNum = levels[level] || levels.low;

        var promise = fluid.promise();

        if (level === "low") {
            jqUnit.assertDeepEq("test: First call should be done with level 0",
                levelNum, 1);
        } else {
            jqUnit.fail("mockCloseApplications: Called with incorrect level '" + level + "'");
        }

        promise.reject({
            isError: true,
            message: "gpii.windows.closeApplications: Failed to close application with force level '" + level + "'"
        });

        return promise;
    };
};

/**
 * Check if all properties of expected are also in subject and are equal, ignoring any extra ones in subject.
 *
 * A property's value in the expected object can be the expected value, fluid.VALUE to match any value (just check if
 * the property exists), or fluid.NO_VALUE to check the property doesn't exist.
 *
 * @param subject {Object} The object to check against
 * @param expected {Object} The object containing the values to check for.
 * @param maxDepth {Number} [Optional] How deep to check.
 */
gpii.tests.windows.processHandling.deepMatch = function (subject, expected, maxDepth) {
    var match = false;
    if (maxDepth < 0) {
        return false;
    } else if (!maxDepth && maxDepth !== 0) {
        maxDepth = fluid.strategyRecursionBailout;
    }

    if (!subject) {
        return subject === expected;
    }

    for (var prop in expected) {
        if (expected.hasOwnProperty(prop)) {
            var exp = expected[prop];
            if (fluid.isPrimitive(exp)) {
                match = subject[prop] === exp;
            } else {
                match = gpii.tests.metrics.deepMatch(subject[prop], exp, maxDepth - 1);
            }
            if (!match) {
                break;
            }
        }
    }

    return match;
};

gpii.tests.windows.processHandling.mockCloseProcessByName = function (nameToCheck, optionsToCheck) {
    var closeProcessByName = gpii.windows.closeProcessByName;

    gpii.tests.windows.processHandling.teardowns.push(function () {
        gpii.windows.closeProcessByName = closeProcessByName;
    });

    gpii.windows.closeProcessByName = function (name, options) {
        var promise = fluid.promise();

        var equalOptions = gpii.tests.windows.processHandling.deepMatch(options, optionsToCheck);

        if (name === nameToCheck && equalOptions) {
            jqUnit.assert("closeProcessByName: Correct arguments.");
            promise.resolve();
        } else {
            jqUnit.fail("closeProcessByName: Incorrect arguments.");
            promise.reject({
                isError: true,
                message: "gpii.windows.closeProcessByName: Incorrect arguments."
            });
        }

        return promise;
    };
};

jqUnit.asyncTest("Testing closeAppWithMinForce", function () {
    jqUnit.expect(2);

    // Get the restartable explorer process(es)
    var explorerPids = gpii.windows.findProcessByName("explorer.exe", true);
    explorerPids = fluid.transform(gpii.windows.getRestartableProcesses(explorerPids), function (proc) {
        return proc.pid;
    });

    gpii.tests.windows.processHandling.mockCloseApplications();
    gpii.tests.windows.processHandling.mockCloseProcessByName("explorer.exe", {timeout: 1000, restart: true, quitDelay: 100});
    gpii.windows.closeAppWithMinForce("explorer.exe", {restart: true, quitDelay: 100, timeout: 1000})
        .then(
            function () {
                jqUnit.start();
            },
            function () {
                jqUnit.fail();
            }
        );
});
