/*
 * Debug logging.
 * Writes some information about the process/system that could aid in debugging problems found during the Hardware
 * Sensitivity Tests.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");
var ref = require("ref");
var fs = require("fs");

require("../WindowsUtilities/WindowsUtilities.js");
require("../processHandling/processHandling.js");
require("../registrySettingsHandler");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var debugLogLevel = fluid.logLevel.IMPORTANT;

gpii.windows.logDebugInfo = function () {
    var funcs = [ "logVersion", "logEnvironment", "logAdministrator", "logArchitecture", "logRunningProcesses" ];

    var origLogSize = fluid.logObjectRenderChars;
    fluid.logObjectRenderChars = 0xffff;

    for (var n = 0, len = funcs.length; n < len; n++) {
        gpii.windows[funcs[n]]();
    }

    fluid.logObjectRenderChars = origLogSize;
};

/**
 * Logs the GPII version and revision.
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logVersion = function (options) {
    options = options || {};

    var root = fluid.module.resolvePath("%gpii-windows")

    // package.json version
    var content = fs.readFileSync(root + "/package.json");
    var pkg = JSON.parse(content);
    var output = "GPII Version " + pkg.version;

    try {
        // "real" version
        content = fs.readFileSync(root + "/.version");
        output += " " + content;
    } catch (e) {
        // Doesn't matter
    }

    if (!options.quiet) {
        fluid.log(debugLogLevel, output);
    }

    return output;
};
/**
 * Logs the environment variables.
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logEnvironment = function (options) {
    options = options || {};

    var output = "";
    fluid.each(process.env, function (value, name) {
        output += name + "=" + value + "\n";
    });

    if (!options.quiet) {
        fluid.log(debugLogLevel, "Environment variables", output);
    }

    return output;
};

/**
 * Logs whether or not the process is being run as an administrator, and whether UAC is on.
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logAdministrator = function (options) {
    options = options || {};

    // Note: it is possible to be running as a non-admin even though UAC is off, if the user is a non-admin user.
    var isAdmin = windows.isUserAdmin();
    var uacEnabled = windows.readRegistryKey("HKEY_LOCAL_MACHINE",
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "EnableLUA", "REG_DWORD");
    var output = "Running as admin: " + (isAdmin ? "YES" : "NO") + ", UAC is " + (uacEnabled ? "ON" : "OFF");

    if (!options.quiet) {
        fluid.log(debugLogLevel, output);
    }

    return output;
};

/**
 * Logs the CPU architecture the process is running on.
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logArchitecture = function (options) {
    options = options || {};

    var output = "Architecture: " + process.arch;
    if (windows.isWow64()) {
        output += " (on 64-bit OS)";
    }

    if (!options.quiet) {
        fluid.log(debugLogLevel, output);
    }

    return output;
};

/**
 * Logs the currently running processes.
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logRunningProcesses = function (options) {
    options = options || {};

    var procs = windows.getRunningProcesses();

    var outputLines = fluid.transform(procs, function (proc) {
        // Get the full path of the executable
        var exePath = proc.exeFile;
        var hProcess = windows.kernel32.OpenProcess(windows.API_constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, proc.pid);
        if (hProcess) {
            var size = ref.alloc(windows.types.DWORD);
            size.writeUInt32LE(windows.API_constants.MAX_PATH, 0);
            var path = new Buffer(windows.API_constants.MAX_PATH);

            var success = windows.kernel32.QueryFullProcessImageNameW(hProcess, 0, path, size);
            if (success) {
                exePath = windows.fromWideChar(path);
            }
            windows.kernel32.CloseHandle(hProcess);
        }

        return exePath;
    });

    var output = outputLines.join("\n");

    if (!options.quiet) {
        fluid.log(debugLogLevel, output);
    }

    return output;
};

/**
 * Logs the version of GPII
 *
 * @param [options] Options
 * @param {String} options.quiet Set to true to create no output.
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.logArchitecture = function (options) {
    options = options || {};

    var output = "Architecture: " + process.arch;
    if (windows.isWow64()) {
        output += " (on 64-bit OS)";
    }

    if (!options.quiet) {
        fluid.log(debugLogLevel, output);
    }

    return output;
};


gpii.windows.logDebugInfo();
