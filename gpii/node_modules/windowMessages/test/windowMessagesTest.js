/*
 * Window message tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("infusion"),
    ffi = require("ffi");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.windowMessages");

require("../index.js");

jqUnit.module("gpii.tests.windowMessages");

gpii.tests.windowMessages.user32 = ffi.Library("user32", {
    // https://msdn.microsoft.com/library/ms633499
    "FindWindowW": [
        gpii.windows.types.HANDLE, ["char*", "int"]
    ],
    // https://msdn.microsoft.com/library/ms644950
    "SendMessageW": [
        "int", [gpii.windows.types.HANDLE, gpii.windows.types.UINT, gpii.windows.types.UINT, gpii.windows.types.UINT ]
    ]
});

fluid.defaults("gpii.tests.windowMessages.wrapper", {
    gradeNames: ["fluid.component"],
    invokers: {
        start: "{gpii.windows.messages}.start({that})",
        stop: {
            func: "{gpii.windows.messages}.stop",
            args: "{that}"
        },
        getWindowHandle: "{gpii.windows.messages}.getWindowHandle"
    },
    listeners: {
        "{gpii.windows.messages}.events.onMessage": "{that}.events.onMessage.fire"
    },
    events: {
        onMessage :null
    }
});

/**
 * Finds a window, based on the classname.
 * @param className {String} The window class name.
 * @return {number} The window handle, or null if not found.
 */
gpii.tests.windowMessages.findWindow = function (className) {
    var classNameBuffer = gpii.windows.stringToWideChar(className);
    var handle = gpii.tests.windowMessages.user32.FindWindowW(classNameBuffer, 0);
    return handle || null;
};

// Test that the message window gets created and destroyed.
jqUnit.asyncTest("Window Messages - Window creation and destruction", function () {
    jqUnit.expect(1);

    var instances = fluid.queryIoCSelector(fluid.rootComponent, "gpii.windows.messages");
    var messages = (instances.length > 0) ? instances[0] : gpii.windows.messages();

    var windowExists = function () {
        return !!gpii.tests.windowMessages.findWindow(messages.windowClassname);
    };

    if (windowExists()) {
        gpii.windows.messages.destroyMessageWindow(messages);
    }

    jqUnit.assertFalse("Message window shouldn't exist before start", windowExists());

    var work = [
        function () {
            messages.start(messages);

            return gpii.windows.waitForCondition(windowExists, {
                timeout: 5000,
                error: "Message window should be created (first start)"
            });
        },
        function () {
            messages.stop(messages);

            return gpii.windows.waitForCondition(windowExists, {
                timeout: 5000,
                error: "Message window should be destroyed (stop)",
                conditionValue: false
            });
        },
        function () {
            messages.start(messages);

            return gpii.windows.waitForCondition(windowExists, {
                timeout: 5000,
                error: "Message window should be created (second start)"
            });
        },
        function () {
            messages.stop();

            return gpii.windows.waitForCondition(windowExists, {
                timeout: 5000,
                error: "Message window should be destroyed (after stop)",
                conditionValue: false
            });
        }
    ];

    fluid.promise.sequence(work).then(jqUnit.start, jqUnit.fail);

});

// Test that the message window handles a message and fires the event, and can cope with more than one instance.
jqUnit.test("Window Messages - Message receipt", function () {

    var WM_USER = 0x400;

    var messages = [
        {
            msg: WM_USER,
            wParam: 1234,
            lParam: 5678
        },
        {
            msg: WM_USER + 1,
            wParam: 42,
            lParam: 0
        }
    ];

    var instance1 = gpii.tests.windowMessages.wrapper();
    var instance2 = gpii.tests.windowMessages.wrapper();

    instance1.events.onMessage.addListener(function (hwnd, msg, wParam, lParam) {
        var index = null;
        if (msg === WM_USER) {
            index = 0;
        } else if (msg === WM_USER + 1) {
            index = 1;
        }
        if (index !== null) {
            jqUnit.assertEquals("wParam, instance1, message " + index, messages[index].wParam, wParam);
            jqUnit.assertEquals("lParam, instance1, message " + index, messages[index].lParam, lParam.address());
        }
    });

    instance2.events.onMessage.addListener(function (hwnd, msg, wParam, lParam) {
        // Only the first message is expected for this instance. The second message will be received, but it's not
        // required to have.
        if (msg === WM_USER) {
            jqUnit.assertEquals("wParam, instance2", messages[0].wParam, wParam);
            jqUnit.assertEquals("lParam, instance2", messages[0].lParam, lParam.address());
        }
    });

    // Start listening for messages.
    instance1.start();
    instance2.start();

    var window = instance1.getWindowHandle();
    jqUnit.assertFalse("getWindowHandle should return a number", isNaN(window));
    jqUnit.assertEquals("Both instances should point to the same window", window, instance2.getWindowHandle());

    // Send a message to the window
    gpii.tests.windowMessages.user32.SendMessageW(window, messages[0].msg, messages[0].wParam, messages[0].lParam);

    // Stop one instance from listening
    instance2.stop();

    // Send second message
    gpii.tests.windowMessages.user32.SendMessageW(window, messages[1].msg, messages[1].wParam, messages[1].lParam);

    instance1.stop();

    window = instance1.getWindowHandle();
    jqUnit.assertFalse("getWindowHandle should return a zero", 0);
});

// Test that the "sendWindowMessage" function actually sends the message.
jqUnit.asyncTest("Window Messages - Message sent", function () {

    jqUnit.expect(1);
    var messageName = "WM_SETTINGCHANGE";

    var message = {
        msg: messageName,
        wparam: 0,
        lparam: "intl"
    };

    var windowMessages = gpii.tests.windowMessages.wrapper();

    var timeout = setTimeout(jqUnit.fail, 2000, "timeout waiting for message");

    windowMessages.events.onMessage.addListener(function (hwnd, msg) {
        if (msg === gpii.windows.API_constants[messageName]) {
            clearTimeout(timeout);
            jqUnit.assert("WM_SETTINGCHANGE received");
            windowMessages.stop();
            jqUnit.start();
        }
    });

    // Start listening for messages.
    windowMessages.start();

    // Send a message to the window
    gpii.windows.sendWindowMessage(message);

});
