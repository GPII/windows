/* Things related to the operating system.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var ref = require("ref"),
    Promise = require("bluebird"),
    logging = require("./logging.js"),
    winapi = require("./winapi.js"),
    path = require("path");

var windows = {
    winapi: winapi,
    NULL: ref.NULL
};


/**
 * Determine if this process is running as a service.
 *
 * @return {Boolean} true if running as a service.
 */
windows.isService = function () {
    // Windows services don't have stdin or out
    var stdin = winapi.kernel32.GetStdHandle(winapi.constants.STD_INPUT_HANDLE);
    var stdout = winapi.kernel32.GetStdHandle(winapi.constants.STD_OUTPUT_HANDLE);
    return stdin === 0 && stdout === 0;
};

/**
 * Returns an Error containing the arguments.
 *
 * @param message {String} The message.
 * @param returnCode {String|Number} [optional] The return code.
 * @param errorCode {String|Number} [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error.
 */
windows.win32Error = function (message, returnCode, errorCode) {
    return winapi.error(message, returnCode, errorCode);
};

/**
 * Get the user token for the current process.
 *
 * This token must be closed with closeToken when no longer needed.
 *
 * @return {Number} The token.
 */
windows.getOwnUserToken = function () {
    // It's possible to just call GetCurrentProcessToken, but that returns a pseudo handle that doesn't have the
    // required permission to start a process as that user.

    // A pseudo handle - doesn't need to be closed;
    var processHandle = winapi.kernel32.GetCurrentProcess();
    // Enough for CreateProcessAsUser
    var access = winapi.constants.TOKEN_ASSIGN_PRIMARY | winapi.constants.TOKEN_DUPLICATE
        | winapi.constants.TOKEN_QUERY;
    var tokenBuf = ref.alloc(winapi.types.HANDLE);
    var success = winapi.advapi32.OpenProcessToken(processHandle, access, tokenBuf);

    if (!success) {
        throw winapi.error("OpenProcessToken failed");
    }

    return tokenBuf.deref();
};

/**
 * Closes a user token.
 * @param userToken {Number} The user token.
 */
windows.closeToken = function (userToken) {
    if (userToken) {
        winapi.kernel32.CloseHandle(userToken);
    }
};

/**
 * Gets the user token for the active desktop session.
 *
 * This token must be closed with closeToken when no longer needed.
 *
 * @return {Number} The token
 */
windows.getDesktopUser = function () {

    var userToken;

    if (windows.isService()) {
        // Get the session ID of the console session.
        var sessionId = winapi.kernel32.WTSGetActiveConsoleSessionId();
        logging.debug("session id:", sessionId);


        if (sessionId === 0xffffffff) {
            // There isn't a session.
            userToken = 0;
        } else {
            // Get the access token of the user logged into the session.
            var tokenBuf = ref.alloc(winapi.types.HANDLE);
            var success = winapi.wtsapi32.WTSQueryUserToken(sessionId, tokenBuf);

            if (success) {
                userToken = tokenBuf.deref();
            } else {
                var errorCode = winapi.kernel32.GetLastError();
                logging.warn("WTSQueryUserToken failed (win32=" + errorCode + ")");

                switch (errorCode) {
                case winapi.errorCodes.ERROR_NO_TOKEN:
                case winapi.errorCodes.ERROR_SUCCESS:
                    // There is no user on this session.
                    userToken = 0;
                    break;
                case winapi.errorCodes.ERROR_ACCESS_DENIED:
                case winapi.errorCodes.ERROR_PRIVILEGE_NOT_HELD:
                    // Not running as a service?
                    throw winapi.error("WTSQueryUserToken (isService may be wrong)", errorCode);
                    break;
                default:
                    throw winapi.error("WTSQueryUserToken", errorCode);
                    break;
                }
            }
        }
    } else {
        // If not running as a service, then assume the current user is the desktop user.
        userToken = windows.getOwnUserToken();
    }

    return userToken;
};

/**
 * Determines if the active console session is a user logged on.
 */
windows.isUserLoggedOn = function () {
    var token = windows.getDesktopUser();
    var loggedOn = !!token;
    if (token) {
        windows.closeToken(token);
    }

    return loggedOn;
};

/**
 * Gets the environment variables for the specified user.
 *
 * @param token {Number} Token handle for the user.
 * @return {Array} An array of strings for each variable, in the format of "name=value"
 */
windows.getEnv = function (token) {
    var envPtr = ref.alloc(winapi.types.LP);
    var success = winapi.userenv.CreateEnvironmentBlock(envPtr, token, false);
    if (!success) {
        throw winapi.error("CreateEnvironmentBlock");
    }
    return winapi.stringFromWideCharArray(envPtr.deref(), true);
};

/**
 * Gets the GPII data directory for the specified user (identified by token).
 *
 * When running as a service, this process's "APPDATA" value will not point to the current user's.
 *
 * @param userToken {Number} Token handle for the user.
 */
windows.getUserDataDir = function (userToken) {
    // Search the environment block for the APPDATA value. (A better way would be to use SHGetKnownFolderPath)
    var env = windows.getEnv(userToken);
    var appData = null;
    for (var n = 0, len = env.length; n < len; n++) {
        var match = env[n].match(/^APPDATA=(.*)/i);
        if (match) {
            appData = match[1];
            break;
        }
    }

    return appData && path.join(appData, "GPII");
};

/**
 * Returns a promise that resolves when a process has terminated.
 *
 * @param pid {Number} The process ID.
 * @param timeout {Number} Milliseconds to wait before timing out. (default: infinate)
 * @return {promise} Resolves when the process has terminated, or when timed out (with a value of "timeout"). Rejects
 * upon failure.
 */
windows.waitForProcessTermination = function (pid, timeout) {

    return new Promise(function (resolve, reject) {
        var hProcess = winapi.kernel32.OpenProcess(winapi.constants.SYNCHRONIZE, 0, pid);
        if (hProcess === windows.NULL) {
            reject(windows.win32Error("OpenProcess"));
        } else {
            if (!timeout && timeout !== 0) {
                timeout = winapi.constants.INFINITE;
            }
            winapi.kernel32.WaitForSingleObject.async(hProcess, timeout, function (err, ret) {
                winapi.kernel32.CloseHandle(hProcess);

                switch (ret) {
                case winapi.constants.WAIT_OBJECT_0:
                    resolve();
                    break;
                case winapi.constants.WAIT_TIMEOUT:
                    resolve("timeout");
                    break;
                case winapi.constants.WAIT_FAILED:
                default:
                    reject(windows.win32Error("WaitForSingleObject", ret));
                    break;
                }
            });
        }
    });
};

module.exports = windows;
