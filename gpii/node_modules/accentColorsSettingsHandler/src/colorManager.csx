/*
 * GPII Windows 10 Accent Colors Settings Handler
 *
 * Copyright 2018 Raising the Floor - US
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

using System;
using System.Collections;
using System.Threading.Tasks;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
public struct DwmColorParams {
    public uint ColorizationColor;
    public uint ColorizationAfterglow;
    public uint ColorizationColorBalance;
    public uint ColorizationAfterglowBalance;
    public uint ColorizationBlurBalance;
    public uint ColorizationGlassReflectionIntensity;
    public uint ColorizationOpaqueBlend;
};

[StructLayout(LayoutKind.Sequential)]
public struct ImmersiveColorPreference {
    public uint crStartColor;
    public uint crAccentColor;
}

public static class ColorManager {
    // Functions for changing Windows window border colors
    [DllImport("dwmapi.dll", EntryPoint = "#131", CallingConvention = CallingConvention.StdCall)]
    private static extern int DwmpSetColorizationParameters(ref DwmColorParams dcpParams, bool alwaysTrue);
    [DllImport("dwmapi.dll", EntryPoint = "#123")]
    private static extern int DwmGetColorizationColor(out uint color, out bool blend);
    [DllImport("dwmapi.dll", EntryPoint = "#127", CallingConvention = CallingConvention.StdCall)]
    private static extern int DwmpGetColorizationParameters(out DwmColorParams dcpParams);

    private static byte LowByte(UInt32 number) {
        UInt32 mask = 0xFF;
        UInt32 resNum = number & mask;

        return (byte)resNum;
    }

    private static byte GetRValue(UInt32 number) {
        byte rByte = LowByte(number);
        return rByte;
    }

    private static byte GetGValue(UInt32 number) {
        UInt32 shiftedUInt = number >> 8;
        byte rByte = LowByte(shiftedUInt);

        return rByte;
    }

    private static byte GetBValue(UInt32 number) {
        UInt32 shiftedUInt = number >> 16;
        byte rByte = LowByte(shiftedUInt);

        return rByte;
    }

    public static UInt32 RGB(byte r, byte g, byte b) {
        byte rVal = r;
        UInt32 gVal = ((UInt32)g) << 8;
        UInt32 bVal = ((UInt32)b) << 16;

        UInt32 finalColor = r | gVal | bVal;

        return finalColor;
    }

    public static int GetWindowBorderColors(out UInt32 color) {
        DwmColorParams colorParams = new DwmColorParams {
            ColorizationColor = 0,
            ColorizationAfterglow = 0,
            ColorizationColorBalance = 0,
            ColorizationAfterglowBalance = 0,
            ColorizationBlurBalance = 0,
            ColorizationGlassReflectionIntensity = 0,
            ColorizationOpaqueBlend = 0
        };

        var getRes = DwmpGetColorizationParameters(out colorParams);
        UInt32 revColor = colorParams.ColorizationColor & 0x00FFFFFF;
        UInt32 curColor = RGB(GetBValue(revColor), GetGValue(revColor), GetRValue(revColor));

        color = curColor;

        return getRes;
    }

    public static int SetWindowBorderColors(UInt32 color) {
        DwmColorParams colorParams = new DwmColorParams {
            ColorizationColor = 0,
            ColorizationAfterglow = 0x00007fff,
            ColorizationColorBalance = 0xedd816c5,
            ColorizationAfterglowBalance = 0x0000002b,
            ColorizationBlurBalance = 0x6987bf01,
            ColorizationGlassReflectionIntensity = 0,
            ColorizationOpaqueBlend = 0
        };

        var getRes = DwmpGetColorizationParameters(out colorParams);
        if (getRes != 0) {
            return getRes;
        }

        UInt32 rByte = (UInt32)GetRValue(color) << 16;
        UInt32 gByte = (UInt32)GetGValue(color) << 8;
        UInt32 bByte = GetBValue(color);

        UInt32 dwNewColor = (UInt32)((((UInt32)0xC4) << 24) | (rByte | gByte | bByte));
        colorParams.ColorizationColor = dwNewColor;
        colorParams.ColorizationAfterglow = dwNewColor;
        var setRes = DwmpSetColorizationParameters(ref colorParams, false);

        return setRes;
    }

    // Functions for changing Windows accent colors
    [DllImport("uxtheme.dll", CallingConvention = CallingConvention.StdCall)]
    private static extern int GetUserColorPreference(out ImmersiveColorPreference cpcpPreference, bool fForceReload);
    [DllImport("uxtheme.dll", EntryPoint = "#122", CallingConvention = CallingConvention.StdCall)]
    private static extern int SetUserColorPreference(ref ImmersiveColorPreference cpcpPrefere, bool fForceCommit);

    public static int GetAccentColor(out UInt32 color) {
        ImmersiveColorPreference colorPreference = new ImmersiveColorPreference { crStartColor = 0, crAccentColor = 0 };
        var res = GetUserColorPreference(out colorPreference, false);
        color = colorPreference.crAccentColor & 0x00FFFFFF;

        return res;
    }

    public static int SetAccentColor(UInt32 color) {
        ImmersiveColorPreference colorPreference = new ImmersiveColorPreference { crStartColor = 0, crAccentColor = 0 };

        color &= 0x00FFFFFF;
        colorPreference.crAccentColor = color;
        var res = SetUserColorPreference(ref colorPreference, true);

        return res;
    }
}

public class Startup {
    public static bool isGet(Object[] input) {
        if (input.Length == 1) {
            bool isString = input[0].GetType() == typeof(System.String);

            return isString && ((String)input[0]) == "get";
        } else {
            return false;
        }
    }

    public static bool isSet(Object[] input) {
        if (input.Length == 2) {
            bool isString = input[0].GetType() == typeof(System.String);
            bool isNumber = input[1].GetType() == typeof(System.Int32);

            bool isSet = ((String)input[0]) == "set";

            return isString && isNumber && isSet;
        } else {
            return false;
        }
    }

    public static bool checkInput(Object[] input) {

        return isGet(input) || isSet(input);
    }

    /*
     * Input parameter should be an array with two possible payload styles:
     *  - Get payload: ["get"]
     *  - Set payload: ["set", "value"]
     *
     * Returns:
     *  - Get: The value that is being queried, or negative error code in case of failing.
     *  - Set: The code of the result of the operation.
     *  - InvalidPayload: -1.
     */
    public async Task<object> Invoke(dynamic input) {
        try {
            if (isGet(input)) {
                UInt32 curColor = 0;

                var getResCode = ColorManager.GetAccentColor(out curColor);
                if (getResCode == 0) {
                    return curColor;
                } else {
                    return getResCode;
                }
            } else if (isSet(input)) {
                UInt32 desiredColor = (UInt32) input[1];
                var setResCode = ColorManager.SetAccentColor(desiredColor);

                return setResCode;
            } else {
                return -1;
            }
        } catch (Exception) {
            return -10;
        }
    }
}
