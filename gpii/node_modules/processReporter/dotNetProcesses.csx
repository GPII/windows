/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

#r "System.Management.dll"

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;
using System.Management;

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string[] argv;
    public string state = "";
}

public class Startup
{
    public async Task<object> Invoke(dynamic input)
    {
        Process[] processes = null;
        Process aProcess;
        ProcessModule mainModule;
        ProcInfo aProcInfo;
        ArrayList result;

        // Either get a list of processes with the given id or name, or a list
        // of all processes.
        aProcess = null;
        bool foundProcess = false;
        if (input != null) {
            if (input.GetType() == typeof(System.Int32)) {
                try {
                    aProcess = Process.GetProcessById(input);
                    processes = new Process[1];
                    processes[0] = aProcess;
                    foundProcess = true;
                }
                catch (Exception e) {
                    aProcess = null;
                    foundProcess = false;
                }
            }
            else {
                processes = Process.GetProcessesByName(input);
                foundProcess = true;
            }
        }
        if (!foundProcess) {
            processes = Process.GetProcesses();
        }

        result = new ArrayList(processes.Length);
        for (int i = 0; i < processes.Length; i++) {
            aProcess = processes[i];
            aProcInfo = new ProcInfo();
            aProcInfo.pid = aProcess.Id;
            aProcInfo.command = aProcess.ProcessName;

            // Get the command line and its arguments.  Based on:
            // https://stackoverflow.com/questions/2633628/can-i-get-command-line-arguments-of-other-processes-from-net-c
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(
                "SELECT CommandLine FROM Win32_Process WHERE ProcessId = " +
                aProcess.Id
            );
            StringBuilder commandLine = new StringBuilder();
            foreach (ManagementObject mo in searcher.Get()) {
                commandLine.Append(mo["CommandLine"]);
                commandLine.Append(" ");
            }
            aProcInfo.argv = makeArgv(commandLine.ToString());

            // Get full path via the process's MainModule.  If that fails, use
            // aProcInfo.argv[0].  If it succeeds, insure that argv[0] is the
            // full path.
            try {
                mainModule = aProcess.MainModule;
                aProcInfo.fullPath = mainModule.FileName;
                aProcInfo.argv[0] = aProcInfo.fullPath;
            }
            catch (Exception e) {
                mainModule = null;
                if (aProcInfo.argv.Length > 0) {
                    aProcInfo.fullPath = aProcInfo.argv[0];
                }
            }
            // Use only the main thread's state (the first one).
            // Also, map Windows thread states to Linux-y process states
            // This may not be correct thing to do:  revisit.
            ProcessThreadCollection threads = aProcess.Threads;
            switch (aProcess.Threads[0].ThreadState) {
                case ThreadState.Running:
                case ThreadState.Wait:
                    aProcInfo.state = "Running";
                    break;

                case ThreadState.Initialized:
                case ThreadState.Ready:
                case ThreadState.Standby:
                case ThreadState.Transition:
                    aProcInfo.state = "Sleeping";
                    break;

                case ThreadState.Terminated:
                case ThreadState.Unknown:
                    aProcInfo.state = "Zombie";
                    break;
            }
            result.Add(aProcInfo);
        }
        return result.ToArray();
    }

    public static String[] makeArgv(String commandLine)
    {
        List<String> arguments = new List<String>();

        for (int c = 0; c < commandLine.Length; c++) {
            // Handle quoted strings.
            if (commandLine[c] == '"') {
                int firstChar = c + 1;
                int endQuoteIndex = commandLine.IndexOf('"', firstChar);
                arguments.Add(commandLine.Substring(firstChar, endQuoteIndex - firstChar));
                c = endQuoteIndex;
            }
            // Skip spaces outside of quoted strings.
            else if (commandLine[c] == ' ') {
                continue;
            }
            // Handle non-quoted string.
            else {
                int firstChar = c;
                int endStringIndex = commandLine.IndexOf(' ', firstChar);
                arguments.Add(commandLine.Substring(firstChar, endStringIndex - firstChar));
                c = endStringIndex;
            }
        }
        return arguments.ToArray();
    }
}
