/*!
GPII Process Reporter processes bridge -- gpii.processes.

Copyright 2016 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/
using System;
using System.Collections;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Dynamic;

public class ProcInfo
{
    public string command = "";
    public int pid = -1;
    public string fullPath = "";
    public string argv = "";
    public string state = "";
}

public class Startup
{
    public async Task<object> Invoke(dynamic input)
    {
        Process[] processes;
        Process aProcess;
        ProcessModule mainModule;
        ProcInfo aProcInfo;
        ArrayList result;

        processes = Process.GetProcesses();
        result = new ArrayList(processes.Length);
        for (int i = 0; i < processes.Length; i++) {
            aProcess = processes[i];
            aProcInfo = new ProcInfo();
            aProcInfo.pid = aProcess.Id;
            aProcInfo.command = aProcess.ProcessName;

            // Check that we have permission to look at the Modules of
            // the process.  If not, do not try to get the full path
            // to the process.
            try {
                mainModule = aProcess.MainModule;
                aProcInfo.fullPath = mainModule.FileName;
            }
            catch (Exception e) {
                mainModule = null;
            }
            // Only use the main thread's state (the first one).
            // Also, map Windows thread states to Linux-y process states
            // This may not be correct thing to do:  revisit.
            ProcessThreadCollection threads = aProcess.Threads;
            switch (aProcess.Threads[0].ThreadState) {
                case ThreadState.Running:
                case ThreadState.Wait:
                    aProcInfo.state = "Running";
                    break;

                case ThreadState.Initialized:
                case ThreadState.Ready:
                case ThreadState.Standby:
                case ThreadState.Transition:
                    aProcInfo.state = "Sleeping";
                    break;

                case ThreadState.Terminated:
                case ThreadState.Unknown:
                    aProcInfo.state = "Zombie";
                    break;
            }
            result.Add(aProcInfo);
        }
        return result.ToArray();
    }
}
