/*
 * eventLog Tests
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    fs = require("fs"),
    os = require("os"),
    readline = require("readline");

require("../../processHandling/processHandling.js");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.tests.metrics");

require("../index.js");

var teardowns = [];

jqUnit.module("gpii.tests.metrics", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

// Wrap the gpii.windowsMetrics to disable auto-starting the metrics capturing.
fluid.defaults("gpii.tests.metrics.windowsMetricsWrapper", {
    gradeNames: ["fluid.component", "gpii.windowsMetrics", "gpii.eventLog", "gpii.lifecycleManager"],
    listeners: {
        "onStartMetrics.application": null,
        "onStartMetrics.input": null,
        "onStopMetrics.application": null,
        "onStopMetrics.input": null
    }
});

gpii.tests.metrics.defaultKeyboardConfig = fluid.freezeRecursive();

// Tests for recordKeyTiming: key presses
gpii.tests.metrics.recordKeyTimingKeyTests = fluid.freezeRecursive({
    defaultState: {
        times: []
    },
    defaultConfig: {
        minSession: 0xffffff,
        sessionTimeout: 0xffffff,
        maxRecords: 1000
    },
    testData: [
        {   // Normal key press
            state: {},
            input: {
                timestamp: 1,
                key: undefined
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0}
            }
        },
        {   // special key
            state: null,
            input: {
                key: "BS"
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: "BS"}
            }
        },
        // Test that non-special keys don't get leaked.
        {   // not a special key (letter)
            state: null,
            input: {
                key: "A"
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE }
            }
        },
        {   // not a special key (symbol)
            state: null,
            input: {
                key: "!"
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE}
            }
        },
        {   // not a special key (numeric string)
            state: null,
            input: {
                key: "1"
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE}
            }
        },
        {   // not a special key (number)
            state: null,
            input: {
                key: 0x41
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE}
            }
        },
        {   // not a special key (string)
            state: null,
            input: {
                key: "ABC"
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE}
            }
        },
        {   // not a special key (virtual key code of a special key)
            state: null,
            input: {
                key: gpii.windows.API_constants.VK_ESCAPE
            },
            expect: {
                module: "metrics",
                event: "key-time",
                data: {keyTime: 0, key: fluid.NO_VALUE}
            }
        }
    ]
});

// Tests for recordKeyTiming: typing sessions
gpii.tests.metrics.typingSessionTests = fluid.freezeRecursive({
    defaultState: {
        times: []
    },
    defaultConfig: {
        minSession: 30000,
        sessionTimeout: 60000,
        minSessionKeys: 3
    },
    testData: [
        {   // Single session (3 keys, 1 minute)
            state: {},
            input: [
                { timestamp: 1 },
                { timestamp: 20000 },
                { timestamp: 60001 },
                { timestamp: 200000 }
            ],
            expect: [{
                module: "metrics",
                event: "typing-session",
                data: {
                    duration: 60000,
                    count: 3,
                    corrections: 0,
                    rate: 3
                }
            }]
        },
        {   // Single session (10 keys, 5 minutes)
            state: {},
            input: [
                { timestamp: 1 },
                { timestamp: 60000 },
                { timestamp: 90000 },
                { timestamp: 120000 },
                { timestamp: 150000 },
                { timestamp: 180000 },
                { timestamp: 210000 },
                { timestamp: 240000 },
                { timestamp: 270000 },
                { timestamp: 300001 },
                { timestamp: 9000000 }
            ],
            expect: [{
                module: "metrics",
                event: "typing-session",
                data: {
                    duration: 300000,
                    count: 10,
                    corrections: 0,
                    rate: 2
                }
            }]
        },
        {   // Two sessions
            state: {},
            input: [
                // 1st
                { timestamp: 1 },
                { timestamp: 20000 },
                { timestamp: 60001 },
                // 2nd
                { timestamp: 200000 },
                { timestamp: 250000 },
                { timestamp: 300000 },
                { timestamp: 350000 },
                { timestamp: 9000000 }
            ],
            expect: [{
                module: "metrics",
                event: "typing-session",
                data: {
                    duration: 60000,
                    count: 3,
                    corrections: 0,
                    rate: 3
                }
            }, {
                module: "metrics",
                event: "typing-session",
                data: {
                    duration: 150000,
                    count: 4,
                    corrections: 0,
                    rate: 2
                }
            }]
        }
    ]
});

// Tests for inputHook.
gpii.tests.metrics.inputHookTests = fluid.freezeRecursive([
    {   // Invalid nCode.
        input: {
            nCode: -1,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 1,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // First key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 150,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: fluid.NO_VALUE }
        }
    },
    {   // Next key (50ms later).
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "A".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 50, key: fluid.NO_VALUE }
        }
    },
    {   // Non-special non-input key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_HOME,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // Special key: back space.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_BACK,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: "BS" }
        }
    },
    {   // Special key: delete.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_DELETE,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: "DEL" }
        }
    },
    {   // Special key: escape.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_ESCAPE,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: "ESC" }
        }
    },
    {   // Special key: left arrow. Expect nothing, because this only logs if hit after a character key.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_LEFT,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: []
    },
    {   // Normal key: 'X'
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: "X".charCodeAt(),
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: fluid.NO_VALUE }
        }
    },
    {   // Special key: left arrow.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_KEYUP,
            lParam: {
                vkCode: gpii.windows.API_constants.VK_LEFT,
                scanCode: 0,
                flags: 0,
                time: 200,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "key-time",
            data: { keyTime: 0, key: "LEFT" }
        }
    },
    // Mouse events
    {   // Click
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_LBUTTONUP,
            lParam: {
                ptX: 0,
                ptY: 0,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "mouse",
            data: { button: 1, distance: 0 }
        }
    },
    {   // Right click
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_RBUTTONUP,
            lParam: {
                ptX: 0,
                ptY: 0,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "mouse",
            data: { button: 2, distance: 0 }
        }
    },
    {   // Click with movement
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_LBUTTONUP,
            lParam: {
                ptX: 100,
                ptY: 200,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "mouse",
            data: { button: 1, distance: 224 }
        }
    },
    {   // Click with movement again - distance should be from the last coordinate.
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_RBUTTONUP,
            lParam: {
                ptX: 100 + 50,
                ptY: 200 + 60,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "mouse",
            // sqrt(50^2 + 60^2) = 78
            data: { button: 2, distance: 78 }
        }
    },
    {   // Just movement
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_MOUSEMOVE,
            lParam: {
                ptX: 150 - 25,
                ptY: 260 - 30,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        // Shouldn't produce anything
        expect: []
    },
    {   // Click + more movement
        input: {
            nCode: 0,
            wParam: gpii.windows.API_constants.WM_LBUTTONUP,
            lParam: {
                ptX: 125 + 10,
                ptY: 230 + 20,
                mouseData: 0,
                flags: 0,
                time: 0,
                dwExtraInfo: 0
            }
        },
        expect: {
            module: "metrics",
            event: "mouse",
            // (-25,-30) + (10,20) => 39 + 22 = 61
            data: { button: 1, distance: 61 }
        }
    }
]);

/**
 * Configure a log file that's just used for testing.
 * The file will be deleted automatically after the current test completes.
 *
 * @return {String} The path of the log file.
 */
gpii.tests.metrics.setLogFile = function () {
    var previousLogFile = gpii.eventLog.logFilePath;
    var logFile = os.tmpdir() + "/gpii-test-metrics-" + Date.now();
    teardowns.push(function () {
        gpii.eventLog.logFilePath = previousLogFile;
        try {
            fs.unlinkSync(logFile);
        } catch (e) {
            // Ignored.
        }
    });
    gpii.eventLog.logFilePath = logFile;
    return logFile;
};

/**
 * Check if all properties of expected are also in subject and are equal, ignoring any extra ones in subject.
 *
 * A property's value in the expected object can be the expected value, fluid.VALUE to match any value (just check if
 * the property exists), or fluid.NO_VALUE to check the property doesn't exist.
 *
 * @param subject {Object} The object to check against
 * @param expected {Object} The object containing the values to check for.
 * @param maxDepth {Number} [Optional] How deep to check.
 */
gpii.tests.metrics.deepMatch = function (subject, expected, maxDepth) {
    var match = false;
    if (maxDepth < 0) {
        return false;
    } else if (!maxDepth && maxDepth !== 0) {
        maxDepth = fluid.strategyRecursionBailout;
    }

    if (!subject) {
        return subject === expected;
    }

    for (var prop in expected) {
        if (expected.hasOwnProperty(prop)) {
            var exp = expected[prop];
            if (fluid.isMarker(exp, fluid.VALUE)) {
                // match any value
                match = subject.hasOwnProperty(prop);
            } else if (fluid.isMarker(exp, fluid.NO_VALUE)) {
                // match no value
                match = !subject.hasOwnProperty(prop);
            } else if (fluid.isPrimitive(exp)) {
                match = subject[prop] === exp;
            } else {
                match = gpii.tests.metrics.deepMatch(subject[prop], exp, maxDepth - 1);
            }
            if (!match) {
                break;
            }
        }
    }

    return match;
};

/**
 * Checks the log file for some lines that are expected. (see deepMatch for the matching rules)
 *
 * @param logFile {String} The file to read.
 * @param expected {Object[]} An array of log items to search for (in order of how they should be found).
 * @returns {Promise} Resolves when all expected lines where found, or rejects if the end of the log is reached first.
 */
gpii.tests.metrics.expectLogLines = function (logFile, expected) {
    jqUnit.expect(expected.length);
    var promise = fluid.promise();
    var reader = readline.createInterface({
        input: fs.createReadStream(logFile)
    });

    var remainingLines = [];

    var index = 0;
    var currentExpected = expected[index];
    var complete = false;

    reader.input.on("error", function (err) {
        jqUnit.fail(err);
    });

    reader.on("line", function (line) {
        if (complete) {
            return;
        }

        var obj = JSON.parse(line);
        remainingLines.push(obj);

        if (gpii.tests.metrics.deepMatch(obj, currentExpected)) {
            jqUnit.assert("Found a matching line");
            index++;
            remainingLines = [];
            if (index >= expected.length) {
                complete = true;
                reader.close();
            } else {
                currentExpected = expected[index];
            }
        }
    });

    reader.on("close", function () {
        reader.input.close();
        if (complete) {
            promise.resolve();
        } else {
            fluid.log("No matching line (index=" + index + "):", currentExpected);
            fluid.log("Remaining log lines:", remainingLines);
            promise.reject("Unable to find matching log entry " + index);
        }
    });

    return promise;
};

/**
 * Completes a test of logging, by checking if the given log file contains the expected lines.
 *
 * @param logFile {String} The log file.
 * @param expectedLines {Object[]} An array of log items to search for (in order of how they should be found).
 */
gpii.tests.metrics.completeLogTest = function (logFile, expectedLines) {
    gpii.tests.metrics.expectLogLines(logFile, expectedLines).then(function () {
        jqUnit.assert("All expected lines should be found.");
        jqUnit.start();
    }, function (err) {
        jqUnit.fail(err);
    });
};
/**
 * Test the application metrics - app launches and window times.
 */
jqUnit.asyncTest("Testing application metrics", function () {
    jqUnit.expect(1);

    var logFile = gpii.tests.metrics.setLogFile();

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    windowsMetrics.config.application.precision = 1;

    var processesBridge = gpii.processes.windows();

    // Pick three windows (owned by different processes) that already exist, and pretend they've became active by
    // mocking GetForegroundWindow.
    var windows = [];
    var exes = {};
    gpii.windows.enumerateWindows(function (hwnd) {
        if (windows.length < 3) {

            var exe = processesBridge.getProcessPath(gpii.windows.getWindowProcessId(hwnd));
            if (!exes[exe]) {
                exes[exe] = true;
                windows.push({
                    exe: exe,
                    hwnd: hwnd
                });
            }
        }
    });

    // Mock GetForegroundWindow
    var activeWindowIndex = 0;
    var oldGetForegroundWindow = gpii.windows.user32.GetForegroundWindow;
    gpii.windows.user32.GetForegroundWindow = function () {
        return windows[activeWindowIndex].hwnd;
    };
    teardowns.push(function () {
        gpii.windows.user32.GetForegroundWindow = oldGetForegroundWindow;
    });

    var expectedLines = [];

    // Activate the windows a few times.
    var activateWindow = function (count) {
        activeWindowIndex = (activeWindowIndex + 1) % windows.length;

        if (count > 0) {

            if (!windows[activeWindowIndex].done) {
                expectedLines.push({
                    module: "metrics",
                    event: "app-launch",
                    data: {
                        exe: windows[activeWindowIndex].exe
                    }
                });
                windows[activeWindowIndex].done = true;
            }
            expectedLines.push({
                module: "metrics",
                event: "app-active",
                data: {
                    exe: windows[activeWindowIndex].exe,
                    duration: fluid.VALUE
                }
            });

            setTimeout(activateWindow, 200, count - 1);
        } else {
            windowsMetrics.stopApplicationMetrics();
            gpii.tests.metrics.completeLogTest(logFile, expectedLines);
        }
    };

    activateWindow(windows.length * 2);

    // Start monitoring.
    windowsMetrics.startApplicationMetrics();
});

/**
 * Test recordKeyTiming
 * @param theTests
 */
gpii.tests.metrics.recordKeyTimingTests = function (theTests) {
    jqUnit.expect(1);
    var logFile = gpii.tests.metrics.setLogFile();

    var testData = theTests.testData;
    var defaultState = theTests.defaultState;
    var defaultConfig = theTests.defaultConfig;

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    var expectedLines = [];

    fluid.each(testData, function (test) {
        var state = fluid.copy(test.state || defaultState);
        state.config = fluid.copy(state.config || defaultConfig);
        windowsMetrics.state.input = state;
        windowsMetrics.config.input = state.config;

        // "press" the keys
        fluid.each(fluid.makeArray(test.input), function (input) {
            gpii.windows.recordKeyTiming(windowsMetrics, input.timestamp, input.key);
        });

        expectedLines.push.apply(expectedLines, fluid.makeArray(test.expect));
    });

    gpii.tests.metrics.completeLogTest(logFile, expectedLines);
};

jqUnit.asyncTest("Testing keyboard metrics: recordKeyTiming (key presses)", function () {
    gpii.tests.metrics.recordKeyTimingTests(gpii.tests.metrics.recordKeyTimingKeyTests);
});

jqUnit.asyncTest("Testing keyboard metrics: recordKeyTiming (typing sessions)", function () {
    gpii.tests.metrics.recordKeyTimingTests(gpii.tests.metrics.typingSessionTests);
});

// This also tests recordMouseEvent (indirectly)
jqUnit.asyncTest("Testing input metrics: inputHook", function () {
    jqUnit.expect(1);

    var logFile = gpii.tests.metrics.setLogFile();

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    // Disable typing sessions
    windowsMetrics.config.input.minSession = windowsMetrics.config.input.sessionTimeout = -1 >>> 0;
    windowsMetrics.config.input.maxRecords = 1;
    windowsMetrics.startInputMetrics();

    var testData = gpii.tests.metrics.inputHookTests;

    var expectedLines = [];
    var currentTest = null;

    fluid.each(testData, function (test) {
        currentTest = test.input;
        gpii.windows.inputHook(windowsMetrics, currentTest.nCode, currentTest.wParam, currentTest.lParam);

        expectedLines.push.apply(expectedLines, fluid.makeArray(test.expect));
    });

    // The events are put in the log in the next tick (to allow the hook handler to return quickly).
    setImmediate(function () {
        windowsMetrics.stopInputMetrics();
        gpii.tests.metrics.completeLogTest(logFile, expectedLines);
    });
});

jqUnit.asyncTest("Testing input metrics: inactivity", function () {
    jqUnit.expect(4);
    var logFile = gpii.tests.metrics.setLogFile();

    var windowsMetrics = gpii.tests.metrics.windowsMetricsWrapper({
        members: {
            logFilePath: logFile
        }
    });

    // Make the inactivity timeout very quick
    windowsMetrics.config.input.inactiveTime = 1;
    windowsMetrics.startInputMetrics();
    var state = windowsMetrics.state.input;

    jqUnit.assertFalse("Should not be inactive at start", state.inactive);

    gpii.windows.userInput(windowsMetrics);

    jqUnit.assertFalse("Should not be inactive after first input", state.inactive);

    setTimeout(function () {
        jqUnit.assertTrue("Should be inactive after timer", state.inactive);
        gpii.windows.userInput(windowsMetrics);
        jqUnit.assertFalse("Should not be inactive after last input", state.inactive);

        windowsMetrics.stopInputMetrics();
        jqUnit.start();
    }, 10);
});
