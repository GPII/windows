/*
 * Windows Process Handling.
 * A wrapper to integrate processHandlingCore into GPII.
 *
 * Copyright 2016 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");
var ref = require("ref");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

require("../WindowsUtilities/WindowsUtilities.js");

var c = windows.API_constants;

/**
 * Kills any windows processes with a given application filename.
 * http://stackoverflow.com/questions/7956519/how-to-kill-processes-by-name-win32-api
 *
 * @param {String} The filename of the application. For example, the Windows on
 * screen keyboard is "osk.exe". Other examples include "Magnify.exe" and
 * "firefox.exe".
 */
gpii.windows.killProcessByName = function (filename) {
    var pids = gpii.windows.findProcessByName(filename, true);
    if (pids) {
        for (var n = 0, len = pids.length; n < len; n++) {
            var hProcess = windows.kernel32.OpenProcess(c.PROCESS_TERMINATE, 0, pids[n]);
            if (hProcess !== ref.NULL) {
                windows.kernel32.TerminateProcess(hProcess, 9);
                windows.kernel32.CloseHandle(hProcess);
            }
        }
    }
};

/**
 * Finds a running process with the given pid.
 *
 * @param pid The process pid to search for, null to match any.
 * @return {Object} The process information of matching process, otherwise null.
 */
gpii.windows.findProcessByPid = function (pid) {
    var hSnapShot = windows.kernel32.CreateToolhelp32Snapshot(windows.API_constants.TH32CS_SNAPPROCESS, null);
    if (hSnapShot === windows.API_constants.INVALID_HANDLE_VALUE) {
        console.error("CreateToolhelp32Snapshot failed. Win32 error: " + windows.GetLastError());
        return null;
    }

    try {
        // Create the structure for the return parameter of Process32First/Next.
        var pEntry = new windows.PROCESSENTRY32();
        pEntry.dwSize = windows.PROCESSENTRY32.size;

        // Enumerate the processes.
        var hRes = windows.kernel32.Process32First(hSnapShot, pEntry.ref());
        while (hRes) {
            var buf = new Buffer(pEntry.szExeFile);
            var processName = ref.readCString(buf, 0);

            if (pid === pEntry.th32ProcessID) {
                var processInfo = {
                    pid: pEntry.th32ProcessID,
                    ppid: pEntry.th32ParentProcessID,
                    exeFile: processName
                };
                // Only want the first one - return it.
                return processInfo;
            }

            hRes = windows.kernel32.Process32Next(hSnapShot, pEntry.ref());
        }
    } finally {
        // Make sure the snapshot is closed.
        if (hSnapShot) {
            windows.kernel32.CloseHandle(hSnapShot);
        }
    }

    return null;
};

/**
 * Finds a running process with the given name.
 *
 * The CreateToolhelp32Snapshot Windows API call captures the running processes, and the Process32First/Next
 * functions are used to enumerate them.
 *
 * @param filename The exe file name to search for, null to match any.
 * @param all {boolean?} Set to true to return an array containing all matching processes.
 * @param fullInfo {boolean?} Set to true to return the pid, ppid, and exe name of matching processes.
 * @returns {?number|number[]} The Process ID of the matching processes, otherwise null.
 */
gpii.windows.findProcessByName = function (filename, all, fullInfo) {

    // Get a snapshot of the processes.
    var hSnapShot = windows.kernel32.CreateToolhelp32Snapshot(windows.API_constants.TH32CS_SNAPPROCESS, null);
    if (hSnapShot === windows.API_constants.INVALID_HANDLE_VALUE) {
        console.error("CreateToolhelp32Snapshot failed. Win32 error: " + windows.GetLastError());
        return null;
    }

    var matches = [];
    var filenameLower = filename && filename.toLowerCase();

    try {
        // Create the structure for the return parameter of Process32First/Next.
        var pEntry = new windows.PROCESSENTRY32();
        pEntry.dwSize = windows.PROCESSENTRY32.size;

        // Enumerate the processes.
        var hRes = windows.kernel32.Process32First(hSnapShot, pEntry.ref());
        while (hRes) {
            var buf = new Buffer(pEntry.szExeFile);
            var processName = ref.readCString(buf, 0);

            if (!filename || processName.toLowerCase() === filenameLower) {
                var proc;
                if (fullInfo) {
                    proc = {
                        pid: pEntry.th32ProcessID,
                        ppid: pEntry.th32ParentProcessID,
                        exeFile: processName
                    };
                } else {
                    proc = pEntry.th32ProcessID;
                }
                if (all) {
                    // Add it to the array of matches.
                    matches.push(proc);
                } else {
                    // Only want the first one - return it.
                    return proc;
                }
            }

            hRes = windows.kernel32.Process32Next(hSnapShot, pEntry.ref());
        }
    } finally {
        // Make sure the snapshot is closed.
        if (hSnapShot) {
            windows.kernel32.CloseHandle(hSnapShot);
        }
    }

    return all ? matches : null;
};

/**
 * Determines if a given process is running, returning true if it is.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @return {boolean} true if the process is running.
 */
gpii.windows.isProcessRunning = function (proc) {
    var togo = false;
    if (isNaN(proc)) {
        togo = gpii.windows.findProcessByName(proc) !== null;
    } else {
        // try {
        //     process.kill(proc, 0);
        //     togo = true;
        // } catch (e) {
        //     togo = false;
        // }
        togo = gpii.windows.findProcessByPid(proc) !== null;
    }
    return togo;
};


/**
 * Waits for a process to either start or terminate, returning a promise which will resolve when the existence of a
 * process is in the desired state.
 *
 * The promise will reject if the process has yet to become in the desired state after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param options The options.
 * @param options.start The desired state: true to wait for the process to start, false to wait for the termination.
 * @param options.timeout Approximate milliseconds to wait, or null for infinite.
 * @param options.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when the process is in the desired state, or will reject if after the
 *   timeout the process is still in the same state.
 */
gpii.windows.waitForProcessState = function (proc, options) {
    var defaultOptions = {
        pollDelay: 500,
        timeout: null,
        start: false
    };

    options = fluid.extend(true, defaultOptions, options);

    var waitOptions = {
        argument: proc,
        conditionValue: options.start,
        pollDelay: options.pollDelay,
        timeout: options.timeout,
        error: {
            isError: true,
            message: "Timed out waiting for process " + proc +
            " to " + (options.start ? "start" : "terminate") + " after " + options.timeout + "ms"
        }
    };

    return gpii.windows.waitForCondition(gpii.windows.isProcessRunning, waitOptions);
};

/**
 * Waits for a process to terminate, returning a promise which will resolve when there are no matching processes
 * running. If there are no processes running when the function is called, the promise will already be resolved.
 * The promise will reject if the process is still running after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param userOptions The options.
 * @param userOptions.timeout Approximate milliseconds to wait, or null for infinite.
 * @param userOptions.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when there are no matching processes running, or will reject if a matching
 *  process is still running after the timeout.
 */
gpii.windows.waitForProcessTermination = function (proc, userOptions) {
    var options = fluid.extend(true, {start: false}, userOptions);
    return gpii.windows.waitForProcessState(proc, options);
};

/**
 * Waits for a process to start, returning a promise which will resolve when there there is a matching process running.
 * If there are already processes running when the function is called, the promise will already be resolved.
 * The promise will reject if a matching process is still not running after the timeout.
 *
 * @param proc {string|number} The name of the executable, or the process ID.
 * @param userOptions The options.
 * @param userOptions.timeout Approximate milliseconds to wait, or null for infinite.
 * @param userOptions.pollDelay How long to wait, in milliseconds, between checking for the process.
 * @return {promise} The promise will resolve when there is a matching processes running, or will reject if a matching
 *  process is still not running after the timeout.
 */
gpii.windows.waitForProcessStart = function (proc, userOptions) {
    var options = fluid.extend(true, {start: true}, userOptions);
    return gpii.windows.waitForProcessState(proc, options);
};

/**
 * Terminates a process in a kind manner by sending WM_QUIT to the windows it owns. This should allow the process to
 * perform any clean up tasks.
 *
 * If options.gracefulOnly is false (default), and if the process has not shutdown after the timeout or the process
 * does not have any Windows, then the process will be terminated.
 *
 * The returned promise resolves when the process has ended, with a boolean indicating whether a clean shutdown was
 * possible.
 *
 * @param filename
 * @param options The options.
 * @param options.timeout How long to wait for the process to die, in milliseconds.
 * @param options.cleanOnly true to reject if the process can't be closed cleanly; false to force the termination.
 * @param options.exitCode {number} The exit code the application should return.
 * @return {promise}
 */
gpii.windows.closeProcessByName = function (filename, options) {
    var defaultOptions = {
        timeout: 15000,
        cleanOnly: false,
        exitCode: 0
    };

    options = fluid.extend(defaultOptions, options);

    var pids = gpii.windows.findProcessByName(filename, true);
    if (!pids) {
        // Process is not running.
        return fluid.toPromise(true);
    }

    var foundWindow = false;

    // Enumerate all the top-level windows on the desktop, to see which ones are owned by the process.
    gpii.windows.enumerateWindows(function (hwnd) {
        // Get the process ID that owns the Window.
        var ptr = ref.alloc(windows.types.DWORD);
        gpii.windows.user32.GetWindowThreadProcessId(hwnd, ptr);
        var windowPid = ptr.deref();

        if (pids.indexOf(windowPid) !== -1) {
            // Send WM_QUIT, which tells the thread to terminate.
            gpii.windows.user32.PostMessageW(hwnd, windows.API_constants.WM_QUIT, options.exitCode, 0);
            foundWindow = true;
        }
    });

    var promiseTogo = fluid.promise();

    if (foundWindow) {
        // Wait for the process to die.
        gpii.windows.waitForProcessTermination(filename, { timeout: options.timeout })
            .then(function () {
                promiseTogo.resolve(true);
            }, function (err) {
                // Taking too long to die.
                if (options.cleanOnly) {
                    promiseTogo.reject({
                        isError: true,
                        message: "Process " + filename + " will not close cleanly: " + err.message,
                        error: err
                    });
                } else {
                    // Force it to terminate
                    gpii.windows.killProcessByName(filename);

                    // This promise was rejected but the return promise should resolve as the process is terminated.
                    promiseTogo.resolve(false);
                }
            });
    } else {
        // The process does not have any windows so it can't be shutdown cleanly.
        if (options.cleanOnly) {
            promiseTogo.reject({
                isError: true,
                message: "Process " + filename + " will not close cleanly: No windows belong to the process"
            });
        } else {
            // Force it to terminate.
            gpii.windows.killProcessByName(filename);
            promiseTogo.resolve(false);
        }
    }

    return promiseTogo;
};

/**
 * Gets the path to the executable of a running process.
 *
 * Provide the processHandle if it's available when calling, otherwise provide the pid.
 *
 * @param pid {Number} [Optional] The process ID.
 * @param processHandle [Optional] The process handle.
 * @return {String} The path to the executable.
 */
gpii.windows.getProcessPath = function (pid, processHandle) {
    var hProcess;
    var togo = null;

    if (processHandle) {
        hProcess = processHandle;
    } else if (pid) {
        hProcess =
            gpii.windows.kernel32.OpenProcess(gpii.windows.API_constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, pid);
    } else {
        fluid.fail("Either pid or processHandle needs to be given.");
    }

    if (hProcess) {
        try {
            var size = ref.alloc(gpii.windows.types.DWORD);
            size.writeUInt32LE(gpii.windows.API_constants.MAX_PATH, 0);
            var path = new Buffer(gpii.windows.API_constants.MAX_PATH);

            var success = gpii.windows.kernel32.QueryFullProcessImageNameW(hProcess, 0, path, size);
            if (success) {
                togo = gpii.windows.fromWideChar(path);
            }
        } finally {
            if (hProcess !== processHandle) {
                gpii.windows.kernel32.CloseHandle(hProcess);
            }
        }
    }

    if (!togo) {
        // OpenProcess or QueryFullProcessImageName failed (usually due to permissions). Get the file name from the
        // process list instead.
        var all = gpii.windows.findProcessByName(null, true, true);
        var process = all.find(function (p) {
            return p.pid === pid;
        });
        if (process) {
            togo = process.exeFile;
        }
    }
    return togo;

};

/**
 * Gets the windows that each process owns.
 *
 * @param pids {Number[]} [Optional] Only return these processes.
 * @return {Object} Hash of processes and the array of owned windows.
 */
gpii.windows.getProcessWindows = function (pids) {
    var processWindows = {};

    windows.enumerateWindows(function (hwnd) {
        var pid = windows.getWindowProcess(hwnd);
        if (!pids || pids.indexOf(pid) > -1) {
            if (processWindows[pid]) {
                processWindows[pid].push(hwnd);
            } else {
                processWindows[pid] = [hwnd];
            }
        }
    });
    return processWindows;
};

/**
 * Gets an array of processes that can be restarted using the Restart Manager API.
 *
 * @param pids {Number} [Optional] A list of pids to check against (default is all processes).
 */
gpii.windows.getRestartableProcesses = function (pids) {
    pids = pids || windows.findProcessByName(null, true);

    return fluid.transform(pids, function (pid) {

        var hProcess = gpii.windows.kernel32.OpenProcess(
            windows.API_constants.PROCESS_VM_READ | windows.API_constants.PROCESS_QUERY_INFORMATION, 0, pid);

        var restartable;
        if (hProcess) {
            var chSize = ref.alloc(windows.types.DWORD);
            chSize.fill(0);
            restartable = !windows.kernel32.GetApplicationRestartSettings(hProcess, 0, chSize, 0);
        }

        var process = null;
        if (restartable) {
            // Get the create time of each process. The pid and process start time is used to uniquely identify a process
            // (considering pid re-use).
            var creation = new gpii.windows.FILETIME(),
                exit = new gpii.windows.FILETIME(),
                kernel = new gpii.windows.FILETIME(),
                user = new gpii.windows.FILETIME();

            var success = windows.kernel32.GetProcessTimes(
                hProcess, creation.ref(), exit.ref(), kernel.ref(), user.ref());
            process = success && {pid: pid, time: creation};
        }

        return process;

    }).filter(fluid.identity);
};

/**
 * Restart restartable processes.
 *
 * A process is deemed as restartable if it's explicitly stated it's restartable, by calling RegisterApplicationRestart
 * (https://msdn.microsoft.com/library/aa373347). This check is performed in getRestartableProcesses.
 *
 * @param pids {Number[]} [Optional] The processes to try to restart. Default is all.
 * @param options {Object} [Optional]
 * @param options.updatePids {Boolean} If true, remove elements from the pids argument that will be restarted.
 * @param options.shutdownOnly {Boolean} True to only shutdown and don't restart (applications may not expect this).
 * @param options.sessionId {Number} If not undefined, this will be set to the Restart Manager session ID upon return.
 * @return {Promise} A promise that will resolve when it's done.
 */
gpii.windows.restartProcesses = function (pids, options) {
    options = options || {};
    var updatePids = pids && options.updatePids;
    pids = pids || windows.findProcessByName(null, true);

    // Only interested in the processes that can be restarted, otherwise RmShutdown will pause for 30 seconds then kill
    // them abruptly.
    var restartableProcesses = gpii.windows.getRestartableProcesses(pids);

    // Put them into a RM_UNIQUE_PROCESS array.
    var processArray = new windows.RM_UNIQUE_PROCESSES(restartableProcesses.length);
    var index = 0;
    fluid.each(restartableProcesses, function (process) {
        processArray[index].dwProcessId = process.pid;
        processArray[index].ProcessStartTime = process.time;
        index++;

        if (updatePids) {
            var n = pids.indexOf(process.pid);
            if (n > -1) {
                pids.splice(n, 1);
            }
        }
    });

    var promise = fluid.promise();
    var ret;
    var rm = windows.restartManager;

    // RestartManager.h:
    var CCH_RM_SESSION_KEY = 16 * 2 + 1; // sizeof(GUID) * 2 + 1

    // Wrapper to reject if there's an error.
    var reject = function (func, ret) {
        return promise.reject({
            isError: true,
            message: func + " returned " + ret + ", win32 error:" + windows.kernel32.GetLastError()
        });
    };

    // Create the "restart session".
    var session = null;
    var sessionBuf = ref.alloc(gpii.windows.types.DWORD);
    var sessionKey = new Buffer(CCH_RM_SESSION_KEY * 2);
    sessionKey.fill(0);

    ret = rm.RmStartSession(sessionBuf, 0, sessionKey);
    if (ret) {
        return reject("RmStartSession", ret);
    }

    session = sessionBuf.deref();
    if (options.sessionId !== undefined) {
        options.sessionId = session;
    }

    // Close the session at the end.
    promise.then(function () {
        rm.RmEndSession(session);
    }, function () {
        rm.RmEndSession(session);
    });

    // Add the processes to restart.
    ret = rm.RmRegisterResources(session, 0, ref.NULL, processArray.length, processArray, 0, ref.NULL);
    if (ret) {
        return reject("RmRegisterResources", ret);
    }

    // Close the processes. This waits for them to shutdown nicely, so it takes a few seconds.
    var RmShutdownOnlyRegistered = 10;
    rm.RmShutdown.async(session, RmShutdownOnlyRegistered, ref.NULL, function (err, result) {
        if (result) {
            reject("RmShutdown", result);
            return gpii.windows.restartProcesses(pids,  options);
        } else {
            if (!options.shutdownOnly) {
                // Re-start the processes again.
                var ret = rm.RmRestart(session, 0, ref.NULL);
                if (ret) {
                    return reject("RmRestart", ret);
                }
            }
            promise.resolve();
        }
    });

    return promise;
};

/**
 * Close all GUI applications (gracefully), and restarts those that are able to be restarted.
 * A GUI application is a process that owns a Window.
 *
 * The purpose of this is to simulate a logout/in, when a change to the system (such as the language) requires all
 * applications to restart.
 *
 * These are the levels that indicate how aggressively applications are closed:
 *
 * low: Only the applications that have registered themselves as restartable (see restartProcesses()). These are then
 *     restarted.
 * medium: Also notify other windows that a shutdown/logout is imminent (sends WM_QUERYENDSESSION then WM_ENDSESSION).
 *     They have the option to close themselves. "Any data should be saved automatically without prompting the user"
 * high: For the windows that didn't respond to the "medium" level, send WM_QUIT. Most applications will close, or ask
 *     the user to save changes. (see closeProcessByName())
 *
 * @param level {String} Level of force to use (low, medium, or high).
 * @param options {Object} [Optional]
 * @param options.restart {boolean} True to attempt to restart the restartable applications.
 * @param options.pids {Number[]} Only affect these processes.
 * @param options.quitDelay {Number} How long (ms) to send WM_QUIT after sending WM_ENDSESSION (default: 3000).
 * @return {Promise} Resolves when the close requests have been made (but not acted upon).
 */
gpii.windows.closeApplications = function (level, options) {
    options = options || {};
    var levels = {
        low: 1,
        medium: 2,
        high: 3
    };
    var levelNum = levels[level] || levels.low;

    var promise = fluid.promise();

    // Get the processes and the windows they own.
    var processWindows = windows.getProcessWindows(options.pids);

    // Make sure this process doesn't get affected (that would be embarrassing).
    // TODO: Need to detect other GPII-related processes.
    delete processWindows[process.pid];

    // Restart applications that have it implemented.
    var pids = fluid.transform(fluid.keys(processWindows), function (key) { return parseInt(key); });
    if (levelNum >= levels.low) {
        // The restarting processes will be removed from the pids array.
        gpii.windows.restartProcesses(pids, {updatePids: true, shutdownOnly: !options.restart});
    }

    var hwnds = [];

    // Pretend the Windows session is about to end.
    if (levelNum >= levels.medium) {
        // Get the Windows of the processes that couldn't be restarted.
        fluid.each(pids, function (pid) {
            hwnds.push.apply(hwnds, processWindows[pid]);
        });

        // Send the WM_QUERYENDSESSION then WM_ENDSESSION messages to each window.
        windows.postMessage(
            hwnds, windows.API_constants.WM_QUERYENDSESSION, 0, windows.API_constants.ENDSESSION_CLOSEAPP);
        windows.postMessage(
            hwnds, windows.API_constants.WM_ENDSESSION, true, windows.API_constants.ENDSESSION_CLOSEAPP);
    }

    if (levelNum >= levels.high) {
        // Send WM_QUIT to any Window that's still running, after a delay to give them a chance to process the previous
        // messages.
        setTimeout(function () {
            windows.postMessage(hwnds, windows.API_constants.WM_QUIT, 0, 0);
            promise.resolve();
        }, options.quitDelay || 3000);
    } else {
        promise.resolve();
    }

    return promise;
};

/**
 * Convenience function for waiting for multiple processes pids.
 *
 * @param pids {[Number]} The process pids to wait for termination.
 * @param options {Object} The options.
 * @param options.timeout Aproximate milliseconds to wait for each process.
 * @param options.pollDealy How long to wait between processes check.
 * @return {promise} The promise will resolve when all the processes have been closed
 *  or when the timeout expires for any of them.
 */
gpii.windows.waitForProcessesTermination = function (pids, options) {
    var defaultOptions = {
        timeout: 15000,
        pollDelay: 500
    };

    options = fluid.extend(true, defaultOptions, options);

    var promise = fluid.promise();
    var procsClosed = [];

    for (var i = 0; i < pids.length; i++) {
        procsClosed.push(gpii.windows.waitForProcessTermination(pids[i], options));
    }

    fluid.promise.sequence(procsClosed)
        .then(
            function () {
                promise.resolve();
            },
            function () {
                promise.reject({
                    isError: true,
                    message: "gpii.windows.waitForProcessesTermination: Timeout, one of the processes didn't close"
                });
            }
        );

    return promise;
};

/**
 * Convenience function for trying to close an application by name, with the minimal necessary level of force.
 *
 * @param processToClose {String} The name of the App to close.
 * @param options {Object} Optional.
 * @param options.restart {boolean} True to attempt to restart the restartable applications.
 * @param options.quitDelay {Number} How long (ms) to send WM_QUIT after sending WM_ENDSESSION (default: 3000).
 * @param options.timeout {Number} How long (ms) to wait before trying to close the application with the superior
 *  force level.
 * @return {promise} The promise will resolve when the application process has been closed, or will reject when
 *  all the levels of force has failed to close the application.
 */
gpii.windows.closeAppWithMinForce = function (processToClose, options) {
    var defaultOptions =  {
        timeout: 5000,
        quitDelay: 3000,
        restart: false
    };

    options = fluid.extend(defaultOptions, options);

    var promise = fluid.promise();
    var procPids = gpii.windows.findProcessByName(processToClose, true);

    var tryCloseWithHighForce = function () {
        gpii.windows.closeApplications("high", {pids: procPids, restart: options.restart, quitDelay: options.quitDelay})
            .then(
                function () {
                    gpii.windows.waitForProcessesTermination(procPids, options)
                        .then(
                            function () {
                                promise.resolve();
                            },
                            function (err) {
                                promise.reject({
                                    isError: true,
                                    message: "CloseAppWithMinForce: Failed to close process with maximum level of force.",
                                    error: err
                                });
                            }
                        );
                },
                function (err) {
                    promise.reject({
                        isError: true,
                        message: "CloseAppWithMinForce: Failed to close process with maximum level of force.",
                        error: err
                    });
                }
            );
    };

    var tryCloseWithMediumForce = function () {
        gpii.windows.closeApplications("medium", {pids: procPids, restart: options.restart, quitDelay: options.quitDelay})
            .then(
                function () {
                    gpii.windows.waitForProcessesTermination(procPids, options)
                        .then(
                            function () {
                                promise.resolve();
                            },
                            function () {
                                tryCloseWithHighForce();
                            }
                        );
                },
                function () {
                    tryCloseWithHighForce();
                }
            );
    };
//    gpii.windows.closeApplications("low", {pids: procPids, restart: options.restart, quitDelay: options.quitDelay})
    gpii.windows.restartProcesses(procPids, {updatePids: true, shutdownOnly: !options.restart})
        .then(
            function () {
                gpii.windows.waitForProcessesTermination(procPids, options)
                    .then(
                        function () {
                            promise.resolve();
                        },
                        function () {
                            tryCloseWithMediumForce();
                        }
                    );
            },
            function () {
                tryCloseWithMediumForce();
            }
        );

    return promise;
};

/**
 * Executed a command that should open or close a process, optionally waits for the change in
 * the state of that process, after the state changes, closes another process.
 *
 * This function si convenient for cases when two applications are tied, for example when a client application
 * should be restarted after the underlying service has been stopped.
 *
 * @param command The command to be executed for closing/opening the application.
 * @param args {array} The arguments that are going to be passed to the command.
 * @param processToClose {String} The process for closing after the processToWait has exited.
 * @param options {Object} Optional.
 * @param options.commandTimeout {Number} How long to wait for command execution to have impact on the 'processToWait'
 *  application, in milliseconds.
 * @param options.timeout {Number} How long to wait for the 'processToClose' to die, in milliseconds.
 * @param options.polldelay{Number} Polling delay for all process state change checks in the function, in milliseconds.
 * @param options.restart {Bool} Restart the processToClose instead of just closing it.
 * @param options.retries {Number} The number of retries for executing the command trying to close/open the processToWait.
 * @param options.processToWait {String} The process that is going to be closed/oppened after the command execution.
 * @param options.processToWaitState {String} Specificies if command is supposed to "Open" or "Close" the application.
 * @return {promise} The will resolve when the 'processToWait' has been openned/closed and the 'processToClose'
 *  has been sucessfully closed.
 */
gpii.windows.execWaitAndClose = function (command, args, processToClose, options) {
    var defaultOptions = {
        timeout: 5000,
        commandTimeout: 5000,
        polldelay: 100,
        restart: false,
        retries: 1
    };

    options = fluid.extend(defaultOptions, options);

    var promise = fluid.promise();

    // Check if the 'processToWaitState' that is going to be executed is valid.
    var validCommands = ["Open", "Close"];

    if (validCommands.indexOf(options.processToWaitState) === -1) {
        promise.reject({
            isError: true,
            message: "gpii.windows.execWaitAndClose: Error invalid processToWaitState option '" + options.processToWaitState + "'."
        });
        return promise;
    }

    var keepTrying = function (rPromise, retries) {
        fluid.log("gpii.windows.execWaitAndClose: Retrying command '" + command + "' with args '" + args + "'");
        if (retries < 0) {
            if (options.processToWaitState === "Close") {
                fluid.log("gpii.windows.execWaitAndClose: Timeout for process closing failed after '" + retries + "' retries.");
                rPromise.reject({
                    isError: true,
                    message: "Exceeded the number of retries trying to close process '" + options.processToWait + "'."
                });
            } else if (options.processToWaitState === "Open") {
                fluid.log("gpii.windows.execWaitAndClose: Timeout for process openning failed after '" + retries + "' retries.");
                rPromise.reject({
                    isError: true,
                    message: "Exceeded the number of retries trying to open process '" + options.processToWait + "'."
                });
            }
        } else {
            var cmdRes = gpii.launch.spawn(command, args);

            var closeAppWithMinForce = function (p, process) {
                gpii.windows.closeAppWithMinForce(
                    process, {restart: options.restart, timeout: 1000} )
                        .then(
                            function () {
                                p.resolve();
                            },
                            function () {
                                p.reject({
                                    isError: true,
                                    message: "gpii.windows.execWaitAndClose: Unable to close application '" + process
                                });
                            }
                        );
            };

            var waitForProcessState = options.processToWaitState === "Open" ?
                gpii.windows.waitForProcessStart : gpii.windows.waitForProcessTermination;

            waitForProcessState(
                    options.processToWait, {timeout: options.commandTimeout, pollDelay: options.pollDelay})
                        .then(
                            function () {
                                closeAppWithMinForce(rPromise, processToClose);
                            },
                            function () {
                                keepTrying(rPromise, retries - 1);
                            }
                );

            cmdRes.on("error", function (error) {
                rPromise.reject({
                    isError: true,
                    message: "Error while executing command '" + command + "' with args '" + args + "'.",
                    error: error
                });
            });
        }
    };

    keepTrying(promise, options.retries);

    return promise;
};

fluid.defaults("gpii.windows.closeApplications", {
    gradeNames: "fluid.function",
    argumentMap: {
        "level": 0,
        "options": 1
    }
});

fluid.defaults("gpii.windows.killProcessByName", {
    gradeNames: "fluid.function",
    argumentMap: {
        filename: 0
    }
});

fluid.defaults("gpii.windows.closeProcessByName", {
    gradeNames: "fluid.function",
    argumentMap: {
        filename: 0,
        options: 1
    }
});

fluid.defaults("gpii.windows.execWaitAndClose", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1,
        processToClose: 2,
        options: 3
    }
});
