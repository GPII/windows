/*!
Windows SystemParametersInfo Settings Handler

Copyright 2012 Antranig Basman
Copyright 2012 Astea Solutions AD

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var FLAG_DATA_TYPE = "dwFlags";

var ref = require('ref');
var ffi = require("node-ffi");
var Struct = require('ref-struct');
var fluid = require("universal");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var util = require('../../WindowsUtilities/WindowsUtilities');

// Guide to node-ffi types and conversions:
// https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial

var user32 = new ffi.Library('user32', {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724947(v=vs.85).aspx
    // UINT, UINT, PVOID, UINT; return type: BOOL
    'SystemParametersInfoW': [
        'int32', [ 'uint32', "uint32", 'pointer', 'uint32' ]
    ]
});

var kernel32 = new ffi.Library('kernel32', {
    'GetLastError': [
        'int32', []
    ],
    'SetLastError': [
        'void', [ 'int32' ]
    ]
});


// http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
windows.HighContrast = new Struct({
    "cbSize": "uint32",
    "dwFlags": "uint32",
    "lpszDefaultScheme": 'pointer'
});
windows.highContrastPointer = ref.refType(windows.HighContrast);

// http://msdn.microsoft.com/en-us/library/windows/desktop/dd145037(v=vs.85).aspx
windows.LogFont = new Struct([
    ["int32",  "lfHeight"],
    ["int32",  "lfWidth"],
    ["int32",  "lfEscapement"],
    ["int32",  "lfOrientation"],
    ["int32",  "lfWeight"],
    ["uchar",  "lfItalic"],
    ["uchar",  "lfUnderline"],
    ["uchar",  "lfStrikeOut"],
    ["uchar",  "lfCharSet"],
    ["uchar",  "lfOutPrecision"],
    ["uchar",  "lfClipPrecision"],
    ["uchar",  "lfQuality"],
    ["uchar",  "lfPitchAndFamily"],
    ["pointer", "lfFaceName"]
]);
windows.LogFont.size = 92; // FIXME - This way we allocate memory for lfFaceName which is actually an array.
windows.logFontPointer = ref.refType(windows.LogFont);

// http://msdn.microsoft.com/en-us/library/windows/desktop/ff729175(v=vs.85).aspx
windows.NonClientMetrics = new Struct([
    ["uint32",   "cbSize"],
    ["int32",    "iBorderWidth"],
    ["int32",    "iScrollWidth"],
    ["int32",    "iScrollHeight"],
    ["int32",    "iCaptionWidth"],
    ["int32",    "iCaptionHeight"],
    [windows.LogFont,  "lfCaptionFont"],
    ["int32",    "iSmCaptionWidth"],
    ["int32",    "iSmCaptionHeight"],
    [windows.LogFont,  "lfSmCaptionFont"],
    ["int32",    "iMenuWidth"],
    ["int32",    "iMenuHeight"],
    [windows.LogFont,  "lfMenuFont"],
    [windows.LogFont,  "lfStatusFont"],
    [windows.LogFont,  "lfMessageFont"],
    ["int32", "iPaddedBorderWidth"]
]);
windows.nonClientMetricsPointer = ref.refType(windows.NonClientMetrics);
// TODO Define additional structures used in calls to SystemParametersInfo here.

/**
 * Contains actions that can be used as the first argument of the SystemParametersInfo function.
 */ 
windows.actionConstants = {
    "SPI_GETHIGHCONTRAST":     0x0042,
    "SPI_SETHIGHCONTRAST":     0x0043,
    "SPI_GETNONCLIENTMETRICS": 0x0029,
    "SPI_SETNONCLIENTMETRICS": 0x002A,
    "SPI_GETICONTITLELOGFONT": 0x001F,
    "SPI_SETICONTITLELOGFONT": 0x0022,
    "SPI_GETSTICKYKEYS":       0x003A,
    "SPI_SETSTICKYKEYS":       0x003B,
    "SPI_GETFILTERKEYS":       0x0032,
    "SPI_SETFILTERKEYS":       0x0033,
    "SPI_GETMOUSE":            0x0003,
    "SPI_SETMOUSE":            0x0004,
    "SPI_GETMOUSECLICKLOCK":   0x101E,
    "SPI_SETMOUSECLICKLOCK":   0x101F
    
    // TODO Define additional actions used in calls to SystemParametersInfo here.
};

/**
 * Contains flags used in the "dwFlags" field of various structures
 * that are used in calls to the SystemParametersInfo function. 
 */
windows.flagConstants = {
    // HIGHCONTRAST flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318112(v=vs.85).aspx
    "HCF_AVAILABLE":       0x00000002,
    "HCF_CONFIRMHOTKEY":   0x00000008,
    "HCF_HIGHCONTRASTON":  0x00000001,
    "HCF_HOTKEYACTIVE":    0x00000004,
    "HCF_HOTKEYAVAILABLE": 0x00000040,
    "HCF_HOTKEYSOUND":     0x00000010,
    "HCF_INDICATOR":       0x00000020,
    
    // STICKYKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd373652%28v=vs.85%29.aspx
    "SKF_AUDIBLEFEEDBACK": 0x00000040,
    "SKF_AVAILABLE":       0x00000002,
    "SKF_HOTKEYACTIVE":    0x00000004,
    
    // FILTERKEYS flags
    // http://msdn.microsoft.com/en-us/library/windows/desktop/dd318079%28v=vs.85%29.aspx
    "FKF_AVAILABLE":       0x00000002,
    "FKF_CLICKON":         0x00000040,
    "FKF_CONFIRMHOTKEY":   0x00000008,
    "FKF_FILTERKEYSON":    0x00000001,
    "FKF_HOTKEYACTIVE":    0x00000004,
    "FKF_HOTKEYSOUND":     0x00000010,
    "FKF_INDICATOR":       0x00000020 
    
    // TODO Define additional flags used across various structures here.
};

/**
 * Contains structures that are used in calls to the SystemParametersInfo function,
 * accessible by their names. Used to dynamically instantiate the appropriate structure. 
 */
windows.structures = {
    "HIGHCONTRAST": windows.HighContrast,
    "NONCLIENTMETRICS": windows.NonClientMetrics,
    "LOGFONT": windows.LogFont
    // TODO Add additional structures that we need to instantiate here.
};

/**
 * Contains information about the most commonly used Windows data types. The variables are stored
 * in buffers and are read and written with the corresponding functions.
 */
windows.types = {
    "BOOL": {
        size: 4,
        read: function (buffer) {
            return buffer.readInt32LE(0);
        },
        write: function (buffer, value) {
            buffer.writeInt32LE(value, 0);
        }
    },
    
    "INT": {
        size: 4,
        read: function (buffer) {
            return buffer.readInt32LE(0);
        },
        write: function (buffer, value) {
            buffer.writeInt32LE(value, 0);
        }
    },
    
    "DWORD": {
        size: 4,
        read: function (buffer) {
            return buffer.readUInt32LE(0);
        },
        write: function (buffer, value) {
            buffer.writeUInt32LE(value, 0);
        }
    },
    
    "UINT": {
        size: 4,
        read: function (buffer) {
            return buffer.readUInt32LE(0);
        },
        write: function (buffer, value) {
            buffer.writeUInt32LE(value, 0);
        }
    },
    
    "ULONG": {
        size: 4,
        read: function (buffer) {
            return buffer.readUInt32LE(0);
        },
        write: function (buffer, value) {
            buffer.writeUInt32LE(value, 0);
        }
    }
};

/**
 * Takes an array of flag names, applies binary OR among them and returns the result.
 * Used to supply the "dwFlags" argument of some structures.
 * 
 * @param {Array} flagNamesArray An array of flag names.
 *                These should be predefined in windows.flagConstants.
 */
windows.combineFlags = function (flagNamesArray) {
    var combinedFlags = 0;
    if (Object.prototype.toString.call(flagNamesArray) !== "[object Array]") { // when instanceof doesn't get the job done
        return 0;
    }
    for (var index in flagNamesArray) {
        combinedFlags = combinedFlags | windows.flagConstants[flagNamesArray[index]];
    }
    return combinedFlags;
};

/**
 * Creates an empty structure with a given name. It should be registered in the
 * <code>windows.structures</code> map with that name. If the structure has a <code>cbSize</code>
 * member, the function sets that member to the size of the structure using <code>ffi.sizeof</code>.
 * 
 * @param {String} structName The name of the structure to create. Should be registered in the
 *                 <code>windows.structures</code> map.
 * @return {Object} The newly created structure with its <code>cbSize</code> member initialized.
 */
windows.createEmptyStructure = function (structName) {
    var struct = new windows.structures[structName]();
    if (struct.cbSize !== undefined) {
        struct.cbSize = windows.structures[structName].size;
    }
    
    return struct;
};

/**
 * Makes a call to SystemParametersInfo when the <code>pvParam</code> parameter is a structure.
 * Returns the structure populated with the system-wide settings. This should be used for getting
 * values in a structure only.
 * 
 * @param {Integer} action Corresponds to the <code>uiAction</code> parameter of the
 *                  <code>SystemParametersInfo</code> function.
 * @param {Integer} uiParam Corresponds to the <code>uiParam</code> parameter of the
 *                  <code>SystemParametersInfo</code> function.
 * @param {String} structName The name of the structure where the settings are stored.
 * @return {Object} The populated structure as a JSON object.
 */
windows.getSettingsInStructure = function (action, uiParam, structName) {
    var pvParam = windows.createEmptyStructure(structName);
    
    var callSuccessful = user32.SystemParametersInfoW(action, uiParam, pvParam.ref(), 0);
    
    if (!callSuccessful) {  //http://wiki.gpii.net/index.php/Smart_House_TODO_list
        var errorCode = kernel32.GetLastError();
        console.log("Last error: " + errorCode);
        fluid.fail("Could not get/set settings in structure " + structName);
    }
    
    return pvParam;
};

/**
 * Gets the value of a setting stored in the <code>dwFlags</code> member of a given structure.
 * Fails if the call to <code>SystemParametersInfo</code> does not succeed.
 * 
 * @param {Object} settingsStruct The structure that contains the flag specified.
 * @param {String} flagName The name of the flag whose value we need.
 * @return {Boolean} True if the flag is set in the <code>dwFlags</code> member of the structure,
 *                   false otherwise.
 */
windows.getFlagValue = function (settingsStruct, flagName) {
    var flagValue = windows.flagConstants[flagName];
    if (flagValue === undefined) {
        fluid.fail("Structure does not contain a flag with name " + flagName);
    }
    return (settingsStruct.dwFlags & flagValue) === flagValue;
};

/**
 * Applies the settings stored in the payload, making a call to SystemParametersInfoW with the
 * set action.
 */
windows.applySettings = function (payload) {
    var action = windows.actionConstants[payload.options.setAction];
    var uiParam = windows.getUiParam(payload);
    var pvParam = windows.getPvParam(payload);
    
    var callSuccessful = user32.SystemParametersInfoW(
        action,
        uiParam,
        payload.options.pvParam.type === "struct" ? pvParam.ref() : pvParam,
        0
    );
    
    if (!callSuccessful) {
        var errorCode = kernel32.GetLastError();
        console.log("applySettings() failed. Error code: " + errorCode);
        fluid.fail("Could not apply the settings in the payload.");
    }
    return pvParam;
};

/**
 * Makes a call to SystemParametersInfoW with the get action to retrieve the current settings
 * applied on the system.
 */
windows.getCurrentSettings = function (payload) {
    var getAction = windows.actionConstants[payload.options.getAction];
    var uiParam = windows.getUiParam(payload);
    var type = payload.options.pvParam.type;
    var systemSettings;
    
    if (type === "struct") {        
        var structName = payload.options.pvParam.name;
        systemSettings = windows.getSettingsInStructure(getAction, uiParam, structName);
    
    } else {
        var size;
        
        if (type in windows.types) {
            size = windows.types[type].size;
            systemSettings = new Buffer(size);    
        } else if (type === "array") {
            size = windows.types[payload.options.pvParam.valueType].size;
            systemSettings = new Buffer(payload.options.pvParam.length * size);
        }
        
        var callSuccessful = user32.SystemParametersInfoW(getAction, uiParam, systemSettings, 0);
        
        if (!callSuccessful) {
            var errorCode = kernel32.GetLastError();
            console.log("getCurrentSettings() failed. Error code: " + errorCode);
            fluid.fail("Could not get the current system settings.");
        }
    }
    
    return systemSettings;
};

/**
 * Populates the results payload that is returned from the <code>SpiSettingsHandler</code>. These
 * results contain the old and new values for each setting in the input payload.
 * 
 * @param {Object} payload The input that is passed to the SPI Settings Handler
 * @param {Boolean} isNewValue True if the updated values of the settings are populated, false
 *                  otherwise.
 * @param {Boolean} isGetting True if called within spiSettingsHandler.get, false otherwise.
 * @param {Object} results The results object to be populated with the old and new settings values. 
 */
windows.populateResults = function (payload, isNewValue, isGetting, results) {
    var systemSettings = windows.getCurrentSettings(payload);
    var type = payload.options.pvParam.type;
    var offset = 0; // used when reading from an array
    var size;
        
    if (type === "array") {
        type = windows.types[payload.options.pvParam.valueType];
    } else if (type in windows.types) {
        type = windows.types[type];
    } else if (type !== "struct") {
        throw "Unknown type " + type + ".";
    }
    size = type.size;
    
    for (var currentSetting in payload.settings) {
        if (!isNewValue || isGetting) {
            results[currentSetting] = {};
        }
        
        var valueToSet;
        if (type === "struct") {
            valueToSet = systemSettings[currentSetting];
        } else {
            valueToSet = type.read(systemSettings.slice(offset, offset + size));
        }
        
        /*if (typeof payload.settings[currentSetting] === "string") {
            valueToSet = windows.fromWideChar(valueToSet).toString();
        }*/
        
        if (isGetting) {
            results[currentSetting] = valueToSet;
        } else {
            results[currentSetting][isNewValue ? "newValue" : "oldValue"] = valueToSet;
        }
        
        offset += size;
    }
    
};

/**
 * Returns the value for the uiParam parameter of the SystemParametersInfo function from the
 * payload.
 */
windows.getUiParam = function (payload) {
    var uiParam = payload.options.uiParam;
    
    if (!isNaN(Number(uiParam))) {
        return Number(uiParam);
    }
    
    if (uiParam in {'true': '', 'false': ''}) {
        return Number(uiParam === "true");
    }
    
    if (uiParam === 'struct_size') {
        return windows.structures[payload.options.pvParam.name].size;
    }
    
    console.log('Unknown uiParam value: ' + uiParam + ' of type ' + typeof uiParam + '.');
    return 0;
};

/**
 * If a structure is not already defined, creates it by using the structure template in the payload.
 * If such is not provided, throws an exception.
 */
windows.defineStruct = function (payload) {
    if (payload.options.pvParam.type === "struct" && !windows.structures[payload.options.pvParam.name]) {
        if (!payload.options.pvParam.template) {
            throw 'Cannot create structure ' + payload.options.pvParam.name + ' - payload.options.pvParam.template not found!';
        }
        
        windows.structures[payload.options.pvParam.name] = new Struct(payload.options.pvParam.template);
    }
};

/**
 * Returns the value for the pvParam parameter of the SystemParametersInfo function from the
 * payload.
 */
windows.getPvParam = function (payload) {    
    var pvParam;
    var type = payload.options.pvParam.type;
    
    if (type === "struct") {
        pvParam = windows.getSettingsInStructure(windows.actionConstants[payload.options.getAction], windows.getUiParam(payload), payload.options.pvParam.name);
        
        var setField = function (struct, field, value) {
            var valueType = typeof value;
            if (valueType === 'number' || valueType === 'boolean') {
                struct[field] = value;
            } else if (valueType === 'string') {
                struct[field] = windows.stringToWideChar(value);
            } else if (field === 'dwFlags') {
                struct[field] = windows.combineFlags(value);
            } else if (valueType === 'object' && value.type === 'struct') {
                for (var property in value.fields) {
                    setField(struct[field], property, value.fields[property]);
                }
            }
        };
        
        for (var property in payload.settings) {
            setField(pvParam, property, payload.settings[property]);
        }
        
    } else if (type === "array") {
        var valueType = windows.types[payload.options.pvParam.valueType];
        var size = valueType.size;
        pvParam = new Buffer(payload.options.pvParam.length * size);
        
        var offset = 0;
        for (var value in payload.settings) {
            valueType.write(pvParam.slice(offset, offset + size), payload.settings[value]);
            offset += size;
        }
        
    } else if (type in windows.types) {
        type = windows.types[type];
        pvParam = new Buffer(type.size);
        for (var fieldName in payload.settings); // get the name of the property in payload.settings
        type.write(pvParam, Number(payload.settings[fieldName]));
    
    } else if (type === "NULL") {
        pvParam = ref.NULL;
    }
    
    return pvParam;
};

gpii.windows.spiSettingsHandler = {};

/**
 * Entry point function of the component. Takes a payload as an input and sets the corresponding
 * settings using the SystemParametersInfoW Windows API function. Returns an object containing
 * the old and new values for each of the settings.
 */
gpii.windows.spiSettingsHandler.set = function (payload) {
    // TODO Add support for settings that are not stored in structures when such are needed.
    
    windows.defineStruct(payload);
    
    var results = {};
    windows.populateResults(payload, false, false, results);
    
    windows.applySettings(payload);
    
    windows.populateResults(payload, true, false, results);
    
    console.log(results);
    
    return results;
};

gpii.windows.spiSettingsHandler.get = function (payload) {
    windows.defineStruct(payload);
    var results = {};
    windows.populateResults(payload, false, true, results);
    
    console.log(results);
    return results;
};

if (process.argv.length === 2) {
    console.log(__dirname)
    var testSpi = require("../test/testSpiSettingsHandler");
    testSpi.test();
    
} else if (process.argv.length === 3) {
    var filename = __dirname + "/" + process.argv[2];
    var jsonFile = require(filename);
    var returnCode = windows.spiSettingsHandler.get(jsonFile);
}
