/* Manages the GPII user process.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var Promise = require("bluebird"),
    service = require("./service.js"),
    ipc = require("./gpii-ipc.js"),
    windows = require("./windows.js"),
    winapi = require("./winapi.js");

var gpiiProcess = service.module("gpiiProcess");

gpiiProcess.childProcesses = {};

/**
 * The active console session has changed.
 */
gpiiProcess.sessionChange = function (eventType) {
    service.logDebug("session change", eventType);

    switch (eventType) {
    case "session-logon":
        // User just logged on.
        gpiiProcess.startChildProcesses();
        break;
    }
};

/**
 * Starts the configured processes.
 */
gpiiProcess.startChildProcesses = function () {
    var processes = Object.keys(service.config.processes);
    // Start each child process sequentially, ignoring failures.
    var startNext = function () {
        var key = processes.shift();
        if (key) {
            var proc = Object.assign({key: key}, service.config.processes[key]);
            gpiiProcess.startChildProcess(proc).then(startNext, startNext);
        }
    };
    startNext();
};

/**
 * Starts a process.
 *
 * @param procConfig {Object} The process configuration.
 * @param procConfig.command {String} The command.
 * @param procConfig.key {String} Identifier.
 * @param procConfig.autoRestart {boolean} [Optional] true to re-start the process if terminates.
 * @param procConfig.ipc {String} [Optional] IPC channel name.
 * @return {Promise} Resolves (with the pid) when the process has started.
 */
gpiiProcess.startChildProcess = function (procConfig) {
    var childProcess = gpiiProcess.childProcesses[procConfig.key];
    return new Promise(function (resolve, reject) {
        service.log("Starting " + procConfig.key + ": " + procConfig.command);

        if (childProcess) {
            if (gpiiProcess.isProcessRunning(childProcess.pid, childProcess.creationTime)) {
                service.logWarn("Process " + procConfig.key + " is already running");
                reject();
                return;
            }
        } else {
            childProcess = {
                procConfig: procConfig
            };
            gpiiProcess.childProcesses[procConfig.key] = childProcess;
        }
        childProcess.pid = 0;
        childProcess.pipe = null;
        childProcess.lastStart = process.hrtime();
        childProcess.shutdown = false;

        if (procConfig.ipc) {
            ipc.startProcess(procConfig.command).then(function (p) {
                childProcess.pid = p.pid;
                childProcess.pipe = p.pipe;
                childProcess.creationTime = gpiiProcess.getProcessCreationTime(childProcess.pid);

                if (procConfig.autoRestart) {
                    gpiiProcess.autoRestartProcess(procConfig.key);
                }
                resolve(childProcess.pid);
            }, reject);
        } else {
            try {
                childProcess.pid = ipc.execute(procConfig.command);
                childProcess.creationTime = gpiiProcess.getProcessCreationTime(childProcess.pid);

                if (procConfig.autoRestart) {
                    gpiiProcess.autoRestartProcess(procConfig.key);
                }
                resolve(childProcess.pid);
            } catch (e) {
                reject(e);
            }
        }
    });
};

/**
 * Stops all child processes. This is performed when the service has been told to stop.
 */
gpiiProcess.stopChildProcesses = function () {
    service.log("Stopping processes");
    var processKeys = Object.keys(gpiiProcess.childProcesses);
    processKeys.forEach(function (processKey) {
        gpiiProcess.stopChildProcess(processKey);
    });
};

/**
 * Stops a child process, without restarting it.
 * @param processKey {String} Identifies the child process.
 */
gpiiProcess.stopChildProcess = function (processKey) {
    var childProcess = gpiiProcess.childProcesses[processKey];
    if (childProcess) {
        service.log("Stopping " + processKey + ": " + childProcess.procConfig.command);
        // Don't restart it.
        childProcess.shutdown = true;

        if (gpiiProcess.isProcessRunning(childProcess.pid,  childProcess.creationTime)) {
            try {
                process.kill(childProcess.pid);
            } catch (e) {
                // Ignored.
            }
        } else {
            service.logDebug("Process '" + processKey + "' is not running");
        }
    }
};

/**
 * Auto-restarts a child process when it terminates.
 *
 * @param processKey {String} Identifies the child process.
 */
gpiiProcess.autoRestartProcess = function (processKey) {
    var childProcess = gpiiProcess.childProcesses[processKey];
    gpiiProcess.monitorProcess(childProcess.pid).then(function () {
        service.log("Child process '" + processKey + "' died");
        gpiiProcess.event("process-stop", processKey);

        if (!childProcess.shutdown) {
            var restart = true;
            // Check if it's failing to start - if it's been running for less than 20 seconds.
            var timespan = process.hrtime(childProcess.lastStart);
            var seconds = timespan[0];
            if (seconds > 20) {
                childProcess.failureCount = 0;
            } else {
                service.logWarn("Process '" + processKey + "' failed at start.");
                childProcess.failureCount = (childProcess.failureCount || 0) + 1;
                if (childProcess.failureCount > 5) {
                    // Crashed at the start too many times.
                    service.logError("Unable to start process '" + processKey + "'");
                    restart = false;
                }
            }

            if (restart) {
                // Delay restart it.
                var delay = gpiiProcess.throttleRate(childProcess.failureCount);
                service.logDebug("Restarting process '" + processKey + "' in " + Math.round(delay / 1000) + " seconds.");
                setTimeout(gpiiProcess.startChildProcess, delay, childProcess.procConfig);
            }
        }
    });
};

/**
 * Gets the number of milliseconds to delay a process restart.
 *
 * @param failureCount {Number} The number of times the process has failed to start.
 * @return {Number} Returns 10 seconds for every failure count.
 */
gpiiProcess.throttleRate = function (failureCount) {
    return failureCount * 10000;
};

/**
 * Determine if a process is running.
 *
 * To deal with PID re-use, provide creationTime (from a previous call to getProcessCreationTime) to also determine if
 * the running process ID still refers to the original one at the time of the getProcessCreationTime call, and hasn't
 * been re-used.
 *
 * @param pid {number} The process ID.
 * @param creationTime {String} [Optional] Numeric string representing the time the process started.
 * @return {boolean} true if the process is running, and has the same creation time (if provided).
 */
gpiiProcess.isProcessRunning = function (pid, creationTime) {
    var running = false;

    if (pid > 0) {
        try {
            process.kill(pid, 0);
            running = true;
        } catch (e) {
            // It's not running.
        }

        var newCreationTime = gpiiProcess.getProcessCreationTime(pid);
        if (running) {
            if (creationTime && newCreationTime) {
                // The pid is running, return true if it's the same process.
                running = newCreationTime === creationTime;
            } else {
                running = !!newCreationTime;
            }
        } else {
            if (newCreationTime) {
                // The process isn't running, but the pid is still valid.
                // This could mean CloseHandle hasn't been called (by this, or any other process).
                service.logDebug("Possible process handle leak on pid " + pid);
            }
        }
    }

    return running;
};

/**
 * Gets the time that the given process was started. This is used when determining if a pid still refers to the same
 * process, due to the high level of pid re-use that Windows provides.
 *
 * The return value is intended to be compared to another call to this function, so the actual value (microseconds
 * between 1601-01-01 and when the process started) isn't important.
 *
 * @param pid {number} The process ID.
 * @return {String} A numeric string, representing the time the process started - null if there's no such process.
 */
gpiiProcess.getProcessCreationTime = function (pid) {
    var creationTime = new winapi.FILETIME(),
        exitTime = new winapi.FILETIME(),
        kernelTime = new winapi.FILETIME(),
        userTime = new winapi.FILETIME();

    var success = false;
    var processHandle = null;

    try {

        if (pid > 0) {
            processHandle = winapi.kernel32.OpenProcess(winapi.constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, pid);
        }

        if (processHandle === winapi.NULL) {
            service.logDebug(winapi.errorText("OpenProcess", "NULL"));
        } else if (processHandle) {
            success = winapi.kernel32.GetProcessTimes(
                processHandle, creationTime.ref(), exitTime.ref(), kernelTime.ref(), userTime.ref());
            if (!success) {
                service.logDebug(winapi.errorText("GetProcessTimes", success));
            }
        }
    } finally {
        if (processHandle) {
            winapi.kernel32.CloseHandle(processHandle);
        }
    }

    return success
        ? creationTime.ref().readUInt64LE()
        : null;
};

// handle: { handle, pid, resolve, reject }
gpiiProcess.monitoredProcesses = {};
// The last process to be monitored.
gpiiProcess.lastProcess = null;

/**
 * Resolves when the given process terminates.
 *
 * Using WaitForSingleObject is normally enough, but because calling that (using FFI's async method) creates a thread,
 * and there will be several processes to wait upon, WaitForMultipleObjects is used instead.
 *
 * An event (https://msdn.microsoft.com/library/ms686915) will also be added to the things to wait for, so when another
 * process is added to the monitoring list WaitForMultipleObjects can be restarted. (A nicer way would be to alert the
 * thread, but the thread is handled by ffi+libuv).
 *
 * @param pid {number} The process ID.
 */
gpiiProcess.monitorProcess = function (pid) {

    return new Promise(function (resolve, reject) {
        // Get the process handle.
        var processHandle = winapi.kernel32.OpenProcess(winapi.constants.SYNCHRONIZE, 0, pid);
        if (processHandle === winapi.NULL) {
            reject(windows.win32Error("OpenProcess"));
        }

        gpiiProcess.lastProcess = {
            handle: processHandle,
            pid: pid,
            resolve: resolve,
            reject: reject
        };

        // Add this process to the monitored list.
        gpiiProcess.monitoredProcesses[processHandle] = gpiiProcess.lastProcess;

        // (Re)start the waiting.
        var event = gpiiProcess.monitoredProcesses.event;
        if (event) {
            // Cause the current call to WaitForMultipleObjects to unblock, so the new process can also be monitored.
            winapi.kernel32.SetEvent(event.handle);
        } else {
            // Create the event.
            var eventHandle = winapi.kernel32.CreateEventW(winapi.NULL, false, false, winapi.NULL);
            gpiiProcess.monitoredProcesses.event = {
                handle: eventHandle,
                isEvent: true
            };

            gpiiProcess.startWait();
        }
    });
};

/**
 * Stops a monitored process from being monitored. The promises for the process will resolve with "removed".
 *
 * @param process {Number|Object}  The process ID, or the object in gpiiProcess.monitoredProcesses.
 * @param removeOnly {boolean} true to only remove it from the list of monitored processes.
 */
gpiiProcess.unmonitorProcess = function (process, removeOnly) {
    var resolves = [];
    var pid = parseInt(process);
    if (pid) {
        for (var key in gpiiProcess.monitoredProcesses) {
            var proc = !isNaN(key) && gpiiProcess.monitoredProcesses[key];
            if (proc && proc.pid === pid) {
                gpiiProcess.unmonitorProcess(proc, removeOnly);
            }
        }
    } else {
        winapi.kernel32.CloseHandle(process.handle);
        resolves.push(process.resolve);
        delete gpiiProcess.monitoredProcesses[process.handle];

        if (!removeOnly) {
            if (gpiiProcess.monitoredProcesses.event) {
                // Cause the current call to WaitForMultipleObjects to unblock to update the list.
                winapi.kernel32.SetEvent(gpiiProcess.monitoredProcesses.event.handle);
            }

            resolves.forEach(function (resolve) {
                resolve("removed");
            });
        }
    }
};

/**
 * Performs the actual monitoring of the processes added by monitorProcess().
 * Explained in gpiiProcess.monitorProcess().
 */
gpiiProcess.startWait = function () {
    var handles = Object.keys(gpiiProcess.monitoredProcesses).map(function (key) {
        return gpiiProcess.monitoredProcesses[key].handle;
    });

    if (handles.length <= 1) {
        // Other than the event, there's nothing to wait for. Release the event and don't start the wait.
        winapi.kernel32.CloseHandle(gpiiProcess.monitoredProcesses.event.handle);
        delete gpiiProcess.monitoredProcesses.event;
    } else {
        // Wait for one or more of the handles (processes or the event) to do something.
        windows.waitForMultipleObjects(handles).then(function (handle) {
            var proc = gpiiProcess.monitoredProcesses[handle] || gpiiProcess.monitoredProcesses.event;
            if (proc.isEvent) {
                // The event was triggered to re-start waiting.
            } else {
                // Remove it from the list, and resolve.
                gpiiProcess.unmonitorProcess(proc, true);
                proc.resolve(proc.pid);
            }
            // Start waiting again.
            gpiiProcess.startWait();

        }, function (reason) {
            // The wait failed - it could be due to the most recent one so reject+remove that one and try again.
            var last = gpiiProcess.lastProcess &&
                gpiiProcess.monitoredProcesses[gpiiProcess.lastProcess.handle];
            if (last) {
                if (gpiiProcess.lastProcess.reject) {
                    gpiiProcess.unmonitorProcess(gpiiProcess.monitoredProcesses[last.handle], true);
                    gpiiProcess.lastProcess.reject(reason);
                }
            } else {
                // Reject + remove all of them
                Object.keys(gpiiProcess.monitoredProcesses).forEach(function (proc) {
                    if (!proc.isEvent) {
                        gpiiProcess.unmonitorProcess(proc, true);
                        if (proc.reject) {
                            proc.reject(reason);
                        }
                    }
                });
            }
            gpiiProcess.lastProcess = null;
            // Try the wait again (or release the event).
            gpiiProcess.startWait();
        });
    }
};

// Listen for session change.
service.on("svc-sessionchange", gpiiProcess.sessionChange);
// Listen for service stop.
service.on("stop", gpiiProcess.stopChildProcesses);

module.exports = gpiiProcess;
