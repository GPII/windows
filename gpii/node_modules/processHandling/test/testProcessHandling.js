/*
 * Windows Kill Process Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");

require("../processHandling.js");

fluid.registerNamespace("gpii.tests.windows.processHandling");

var waitExe = "gpii-process-handling-test.exe";
var waitExePath = null;

jqUnit.module("gpii.tests.windows.processHandling", {
    setup: function () {
        // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
        // This command is a glorified "sleep" that is also able to be terminated "nicely".
        waitExePath = path.join(process.env.TEMP, waitExe);
        shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), waitExePath);
    },
    teardown: function () {
        if (waitExePath !== null) {
            //shelljs.rm(waitExePath);
        }
    }
});


jqUnit.asyncTest("Testing closeProcessByName", function () {

    jqUnit.expect(3);

    var exitCode = 5;

    var exeName = "test-window.exe";
    var exePath = path.join(__dirname, exeName);
    var command =  exePath + " -window";

    gpii.windows.waitForProcessStart(exeName)
        .then(function () {
            jqUnit.assert("Process started");

            gpii.windows.closeProcessByName(exeName, {force: false, timeout: 1000, exitCode: exitCode})
                .then(function (clean) {
                    jqUnit.assertTrue("Should have closed cleanly", clean);
                    jqUnit.start();
                }, function (e) {
                    fluid.log(e.message);
                    jqUnit.fail("Process should have closed.");
                    gpii.windows.killProcessByName(exeName);
                });
        });

    fluid.log("Executing " + command);
    shelljs.exec(command, {
        async: true
    }, function (code) {
        fluid.log("Exit code:", code);
        jqUnit.assertEquals("Exit code", exitCode, code);
    });
});


jqUnit.asyncTest("Testing closeProcessByName (on a stubborn process)", function () {

    jqUnit.expect(3);

    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("Process started");

            // The process doesn't have any windows, so this should fail to terminate it.
            gpii.windows.closeProcessByName(waitExe, {force: false})
                .then(function () {
                    jqUnit.fail("Process should not have closed.");
                }, function (e) {
                    jqUnit.assert("Process not closed");
                    fluid.log(e.message);
                    // Retry with force
                    gpii.windows.closeProcessByName(waitExe, {force: true})
                        .then(function () {
                            jqUnit.assert("Process terminated");
                            jqUnit.start();
                        });
                });
        });
    var command =  waitExePath + " closeProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    shelljs.exec(command, {
        async: true
    });

});

jqUnit.test("Testing findProcessByName", function () {
    // Find a process that isn't running.
    var pid = gpii.windows.findProcessByName("a non-matching process.exe");
    jqUnit.assertEquals("Process should not have been found running", null, pid);

    // Find a process that is running.
    pid = gpii.windows.findProcessByName("node.exe");
    jqUnit.assertNotEquals("Process should have been found running", null, pid);

    // Find multiple processes. There's always more than one svchost.exe running on Windows.
    var pids = gpii.windows.findProcessByName("svchost.exe", true);
    jqUnit.assertTrue("Should have found several matching process.", pids.length > 1);
});

jqUnit.asyncTest("Testing timeout waiting for processes start", function () {
    jqUnit.expect(1);

    var exe = "a non-matching process.exe";
    gpii.windows.waitForProcessStart(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not be running");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing timeout waiting for processes termination", function () {
    jqUnit.expect(1);

    var exe = "node.exe";
    gpii.windows.waitForProcessTermination(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not have terminated");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing waiting for processes start and end", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // Timeout waiting for the process start/end after 10 seconds.
    var options = { timeout: 10000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(waitExe, options)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Wait for it to die
            gpii.windows.waitForProcessTermination(waitExe, options)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Failed to detect process termination.");
                });

            // Tell the process to stop now.
            shelljs.exec("waitfor /SI waitForProcessTerminationTest");
        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });

    // Create the process, with a 5 second timeout
    shelljs.exec(waitExePath + " waitForProcessTerminationTest /T 5 > nul", {
        async: true
    });
});

jqUnit.asyncTest("Testing Killing Processes", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // On the call below, async is true because if it is false shelljs will
    // wait around until it is manually killed before continuing with the
    // rest of the tests.
    var command =  waitExePath + " killProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    shelljs.exec(command, {
        async: true
    }, function (code, stdout, stderr) {
        fluid.log("Exit code:", code);
        jqUnit.assertEquals("Process should have terminated with code SIGKILL", 9, code);
        fluid.log("Program output:", stdout);
        fluid.log("Program stderr:", stderr);
        jqUnit.start();
    });

    // Kill the process when it starts
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("The process has started");
            gpii.windows.killProcessByName(waitExe);
        });
});
