/*
 * test-window.c: Simple application that creates a window, used to test closeProcessByName.
 *
 * How to build:
 *  csc test-window.cs
 *
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */


namespace TestWindow
{
    using System;
    using System.IO;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    public class TestWindow : Form
    {
        const int WM_QUIT = 0x12;

        static int ExitCode = 5;

        [STAThread]
        static int Main(string[] args)
        {
            if (args.FirstOrDefault() == "-window")
            {
                TestWindow window = new TestWindow
                {
                    Text = "GPII Test Window",
                    WindowState = FormWindowState.Minimized,
                    ShowInTaskbar = false,
                    FormBorderStyle = FormBorderStyle.FixedToolWindow
                };
                Application.Run(window);
                Console.WriteLine("test-window: Ended");
            }
            else if (args.FirstOrDefault() == "-windowState")
            {
                WriteStartup(args[1]);
            }
            else
            {
                Console.WriteLine("A simple application that creates a window that lasts 60 seconds.");
                Console.WriteLine("  -window    Create a window.");
            }

            return TestWindow.ExitCode;
        }

        protected override void WndProc(ref Message m)
        {
            // Record the special "close explorer" message.
            if (m.Msg == 0x5b4)
            {
                Console.WriteLine("test-window: tasktray close");
            }

            base.WndProc(ref m);
        }
        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);
            // Close after 60 seconds
            Timer timer = new Timer();
            timer.Interval = 60000;
            timer.Tick += (object s, EventArgs t) => {
                TestWindow.ExitCode = 1;
                Console.WriteLine("test-window: Timeout");
                this.Close();
            };
            timer.Start();

            Console.WriteLine("test-window: Window created. hwnd=" + this.Handle);
        }

        private static void WriteStartup(string file)
        {
            STARTUPINFO startupInfo;
            GetStartupInfo(out startupInfo);
            if ((startupInfo.dwFlags & STARTF_USESHOWWINDOW) == STARTF_USESHOWWINDOW) {
                File.WriteAllText(file, startupInfo.wShowWindow.ToString());
            } else {
                File.WriteAllText(file, "none");
            }
        }

        const int STARTF_USESHOWWINDOW = 0x1;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct STARTUPINFO
        {
            public uint cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public ushort wShowWindow;
            public ushort cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [DllImport("kernel32.dll", SetLastError = true, EntryPoint = "GetStartupInfoA")]
        public static extern void GetStartupInfo(out STARTUPINFO lpStartupInfo);
    }
}
