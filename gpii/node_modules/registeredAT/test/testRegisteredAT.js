/*
 * Built-in AT Unit Tests
 *
 * Copyright 2015, 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");

require("../registeredAT.js");
require("../../processHandling/processHandling.js");

fluid.registerNamespace("gpii.tests.windows.registeredAT");

var teardowns = [];

jqUnit.module("gpii.tests.windows.registeredAT", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

gpii.tests.windows.registeredAT.atInfoTest = {
    input: {
        appName: "magnifierpane",
        values: ["ATExe", "StartExe", "Description"]
    },
    expectedResult: {
        "ATExe": "Magnify.exe",
        "StartExe": "%SystemRoot%\\System32\\Magnify.exe",
        "Description": "Screen Magnifier"
    }
};

gpii.tests.windows.registeredAT.atEnableTest = {
    input: {
        appName: "gpii-atEnableTest-" + Math.random(),
        regRoot: "HKEY_CURRENT_USER",
        regPath: "Software\\Microsoft\\Windows NT\\CurrentVersion\\AccessibilityTemp"
    },
    expectedResults: {
        enable: 3,
        disable: 2
    }
};

gpii.tests.windows.registeredAT.atStartStopTest = {
    testData: {
        appName: "gpii-atStartStopTest-" + Math.random(),
        ATExe: "gpii-registered-at-test.exe",
        StartExe: path.join(process.env.TEMP, "gpii-registered-at-test.exe"),
        StartParams: "atTest /T 10 > nul"
    }
};

gpii.tests.windows.registeredAT.atPendingTest = {
    input: {
        appName: "gpii-atPendingTest-" + Math.random(),
        regRoot: "HKEY_CURRENT_USER",
        regPath: "Software\\Microsoft\\Windows NT\\CurrentVersion\\AccessibilityTemp",
        enable: 3,
        disable: 2
    }
};

jqUnit.asyncTest("Testing enableRegisteredAT", function () {
    jqUnit.expect(2);

    var testData = gpii.tests.windows.registeredAT.atEnableTest;

    var removeValue = function () {
        // Remove the temporary value
        gpii.windows.writeRegistryKey(testData.input.regRoot, testData.input.regPath, testData.input.appName,
            undefined, "REG_DWORD");
    };

    teardowns.push(removeValue);
    removeValue();

    var options = {
        configOnly: true,
        utilman: "echo hello"
    };

    var testAction = function (input, expected) {
        return function () {
            return gpii.windows.enableRegisteredAT(testData.input.appName, input, options).then(function () {
                var result = gpii.windows.readRegistryKey(testData.input.regRoot, testData.input.regPath,
                    testData.input.appName, "REG_DWORD");
                jqUnit.assertEquals("Checking registry for action value", expected, result.value);
            });
        };
    };

    fluid.promise.sequence([
        testAction(true, testData.expectedResults.enable),
        testAction(false, testData.expectedResults.disable),
        function () {
            jqUnit.start();
        }
    ]);
});

jqUnit.test("Testing getATInformation", function () {
    var testData = gpii.tests.windows.registeredAT.atInfoTest;
    var at = gpii.windows.getATInformation(testData.input.appName, testData.input.values);
    jqUnit.assertDeepEq("Checking result of getATInformation", testData.expectedResult, at);
});

jqUnit.asyncTest("Testing AT start and stop", function () {
    jqUnit.expect(3);

    var testData = gpii.tests.windows.registeredAT.atStartStopTest.testData;

    // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
    shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), testData.StartExe);
    // Remove it at the end
    teardowns.push(function () {
        gpii.windows.killProcessByName(testData.ATExe);
        gpii.windows.waitForProcessTermination(testData.ATExe).then(function () {
            shelljs.rm(testData.StartExe);
        });
    });

    var running = gpii.processReporter.find(testData.ATExe);
    jqUnit.assertFalse("The process should not already be running.", running);

    gpii.windows.startRegisteredAT(testData.appName, {atInfo: testData});

    // Timeout waiting for the process start/end after 5 seconds.
    var waitOptions = { timeout: 5000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(testData.ATExe, waitOptions)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Tell the process to stop now.
            gpii.windows.stopRegisteredAT(testData.appName, {atInfo: testData});

            // Wait for it to die
            gpii.windows.waitForProcessTermination(testData.ATExe, waitOptions)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Process should have terminated.");
                });

        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });
});

jqUnit.asyncTest("Testing enableRegisteredAT.set/get functions", function () {
    jqUnit.expect(3);

    var testData = gpii.tests.windows.registeredAT.atStartStopTest.testData;

    // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
    shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), testData.StartExe);
    // Remove it at the end
    teardowns.push(function () {
        gpii.windows.killProcessByName(testData.ATExe);
        gpii.windows.waitForProcessTermination(testData.ATExe).then(function () {
            shelljs.rm(testData.StartExe);
        });
    });

    var isRunning = gpii.windows.isProcessRunning(testData.ATExe);
    jqUnit.assertFalse("The process should not already be running.", isRunning);

    gpii.windows.startRegisteredAT(testData.appName, {atInfo: testData});

    // Timeout waiting for the process start/end after 5 seconds.
    var waitOptions = { timeout: 5000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(testData.ATExe, waitOptions)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Tell the process to stop now.
            gpii.windows.stopRegisteredAT(testData.appName, {atInfo: testData});

            // Wait for it to die
            gpii.windows.waitForProcessTermination(testData.ATExe, waitOptions)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Process should have terminated.");
                });

        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });
});

jqUnit.asyncTest("Testing pending AT", function () {
    jqUnit.expect(3);
    var testData = gpii.tests.windows.registeredAT.atPendingTest;

    // Check for no pending actions.
    gpii.windows.whilePendingAT({timeout: 0})
        .then(function (value) {
            jqUnit.assertNotEquals("No pending AT actions found.", "timeout", value);
        });

    var removeValue = function () {
        // Remove the temporary value
        gpii.windows.writeRegistryKey(testData.input.regRoot, testData.input.regPath, testData.input.appName,
            undefined, "REG_DWORD");
    };

    teardowns.push(removeValue);

    var actionCheck = function (action) {
        return function () {
            gpii.windows.writeRegistryKey(testData.input.regRoot, testData.input.regPath, testData.input.appName,
                action, "REG_DWORD");
            return gpii.windows.whilePendingAT({timeout: 0})
                .then(function (value) {
                    jqUnit.assertEquals("A pending AT action should be found.", "timeout", value);
                    removeValue();
                });
        };
    };

    fluid.promise.sequence([
        actionCheck(testData.input.enable),
        actionCheck(testData.input.disable),
        function () {
            jqUnit.start();
        }
    ]);
});

// Test starting and stopping Narrator.
jqUnit.asyncTest("Testing real AT", function () {

    jqUnit.expect(4);

    var timeout = null;
    var timer = setTimeout(function () {
        if (timeout) {
            jqUnit.fail("Timeout: " + timeout);
        }
    }, 10000);

    timeout = "enableRegisteredAT(true)";
    var p = gpii.windows.enableRegisteredAT("Narrator", true);
    jqUnit.assertTrue("enableRegisteredAT must return a promise", fluid.isPromise(p));

    p.then(function () {
        // Wait for narrator to start
        gpii.windows.waitForProcessStart("Narrator.exe", {timeout: 10000}).then(function () {
            var running = gpii.windows.isProcessRunning("Narrator.exe");

            jqUnit.assertTrue("Narrator must be running", running);

            timeout = "enableRegisteredAT(false)";
            var p = gpii.windows.enableRegisteredAT("Narrator", false);
            jqUnit.assertTrue("enableRegisteredAT must return a promise", fluid.isPromise(p));

            p.then(function () {
                var running = gpii.windows.isProcessRunning("Narrator.exe");

                jqUnit.assertFalse("Narrator must no longer be running", running);

                clearTimeout(timer);
                jqUnit.start();

            }, jqUnit.fail);
        }, function () {
            jqUnit.fail("narrator did not start");
        });
    }, jqUnit.fail);
});
