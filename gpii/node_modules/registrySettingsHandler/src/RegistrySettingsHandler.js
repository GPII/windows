/*
 * Windows Registry Settings Handler
 *
 * Copyright 2012, 2014 Raising the Floor - International
 * Copyright 2012 Antranig Basman
 * Copyright 2012 Astea Solutions AD
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var ffi = require("ffi"),
    ref = require("ref"),
    fluid = require("gpii-universal");

require("../../WindowsUtilities/WindowsUtilities.js");

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");
fluid.registerNamespace("gpii.windows.registrySettingsHandler");

var NULL = ref.NULL;

// Guide to node_ffi types and conversions:
// https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial

var advapi32 = new ffi.Library("advapi32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, REGSAM, PHKEY
    // Note abuse of type of argument 1 - node_ffi doesn't allow us to forge pointers from integers directly,
    // as required by base keys
    RegOpenKeyExW: [
        "int32", ["uint32", "pointer", "uint32", "uint32", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724837(v=vs.85).aspx
    // HKEY
    RegCloseKey: [
        "long", ["uint32"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724911(v=vs.85).aspx
    // HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD
    RegQueryValueExW: [
        "int32", ["uint32", "pointer", "pointer", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724844(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD
    // Similar abuse to RegOpenKeyExW
    RegCreateKeyExW: [
        "long", ["uint32", "pointer", "uint32", "pointer", "uint32", "uint32", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, DWORD, const BYTE*, DWORD
    RegSetValueExW: [
        "long", ["uint32", "pointer", "uint32", "uint32", "pointer", "uint32"]
    ],
    // https://msdn.microsoft.com/library/ms724847
    // HKEY, LPCWSTR
    // Similar abuse to RegOpenKeyExW - for convenience, only accepts base keys
    RegDeleteKeyExW: [
        "long", ["uint32", "pointer", "uint32", "ulong"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724851(v=vs.85).aspx
    // HKEY, LPCWSTR
    RegDeleteValueW: [
        "long", ["uint32", "pointer"]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724865(v=vs.85).aspx
    // HKEY, DWORD, LPTSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD
    // Similar abuse to RegOpenKeyExW - for convenience, only accepts base keys
    RegEnumValueW: [
        "int32", ["uint32", "uint32", "pointer", "pointer", "pointer", "pointer", "pointer", "pointer"]
    ]
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724847(v=vs.85).aspx
    // This API is disused since it was introduced only on Windows Server 2003 (XP support required)
    // HKEY, LPCWSTR, REGSAM, DWORD
    //RegDeleteKeyExW: [
    //    "long", ["uint32", "pointer", "uint32", "uint32"]
    //]
});

windows.registryTypes = {};

windows.registryTypes.REG_SZ = {
    code: 1,
    readConvert: function (pointer) {
        return windows.fromWideChar(pointer);
    },
    writeConvert: function (value) {
        return windows.toWideChar(value);
    }
};

windows.registryTypes.REG_DWORD = {
    code: 4,
    readConvert: function (pointer) {
        return pointer.readUInt32LE(0);
    },
    writeConvert: function (value) {
        var pointer = new Buffer(4);
        pointer.writeUInt32LE(Number(value), 0);
        return {
            pointer: pointer,
            length: 4
        };
    }
};

windows.registryTypes.REG_BINARY = {
    code: 3,
    readConvert: function (pointer, count) {
        return gpii.pointerToHex(pointer, count);
    },
    writeConvert: function (value) {
        return gpii.hexToPointer(value);
    }
};

var c = windows.API_constants;

windows.getBaseKey = function (baseKey) {
    var key = c[baseKey];
    if (key === undefined) {
        fluid.fail("Unknown registry base key " + baseKey);
    }
    return key;
};

var cr = windows.checkReturnCode;

/**
 * Parses a registry key path, allowing to specify if the 32 or 64-bit view should be used instead of the one correct
 * for the processes. The view is specified by prefixing the real path with "32:" or "64:" (eg, "64:Software\GPII").
 * Currently, this is only used when retrieving the MachineGuid.
 *
 * The return object contains the real path, and a value (KEY_WOW64_64KEY, KEY_WOW64_32KEY, or 0) to bitwise "or" with
 * the samDesired parameter of RegCreateKeyEx,
 * RegOpenKeyEx, or RegDeleteKeyEx.
 *
 * @param path {String} The path
 * @return {Object} Object containing the real path, and access mask.
 */
windows.parseRegistryPath = function (path) {
    var togo = {
        desiredAccess: 0,
        realPath: path
    };

    // To explicitly use either the 32 or 64bit view, prepend the path with "32:" or "64:".
    if (path[2] === ":") {
        var bits = path.substr(0, 2);
        if (bits === "64") {
            togo.desiredAccess |= c.KEY_WOW64_64KEY;
        } else if (bits === "32") {
            togo.desiredAccess |= c.KEY_WOW64_32KEY;
        }

        togo.realPath = path.substr(3);
    }

    return togo;
};

windows.openRegistryKey = function (baseKey, path, keyHolder) {
    var regPath = windows.parseRegistryPath(path);
    var pathW = windows.ensureAlignment(windows.toWideChar(regPath.realPath).pointer);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegOpenKeyExW(base, pathW, 0, regPath.desiredAccess | c.KEY_QUERY_VALUE, keyHolder);
    if (code === windows.API_constants.returnCodes.FILE_NOT_FOUND) {
        return {
            statusCode: 404
        };
    }
    cr(code);
};

windows.closeRegistryKey = function (keyHolder) {
    var code4 = advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
    cr(code4);
};

windows.readRegistryKey = function (baseKey, path, subKey, type) {
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };
    var keyHolder = new Buffer(4);
    var openError = windows.openRegistryKey(baseKey, path, keyHolder);
    if (openError) {
        return openError;
    }

    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);
        var dataLength = new Buffer(4);
        var code2 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, NULL, dataLength);
        if (code2 === windows.API_constants.returnCodes.FILE_NOT_FOUND) {
            togo.statusCode = 404;
            return togo;
        }
        cr(code2);
        togo.bytes = dataLength.readInt32LE(0);

        // Add an extra 2 bytes to ensure the return is always null terminated (numeric values will ignore it).
        var valueHolder = new Buffer(togo.bytes + 2);
        valueHolder.fill(0);
        var code3 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, valueHolder, dataLength);
        cr(code3);

        togo.value = converter.readConvert(valueHolder, togo.bytes);
    } finally {
        windows.closeRegistryKey(keyHolder);
    }

    return togo;
};

windows.writeRegistryKey = function (baseKey, path, subKey, value, type) {
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };
    var regPath = windows.parseRegistryPath(path);
    var pathW = windows.ensureAlignment(windows.toWideChar(regPath.realPath).pointer);
    var keyHolder = new Buffer(4);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegCreateKeyExW(base, pathW, 0, NULL, 0, regPath.desiredAccess | c.KEY_SET_VALUE, NULL,
        keyHolder, NULL);
    cr(code);

    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);
        var code2;
        if (value === undefined) {
            code2 = advapi32.RegDeleteValueW(keyHolder.readUInt32LE(0), subKeyW);
        } else {
            var converted = converter.writeConvert(value);
            code2 = advapi32.RegSetValueExW(keyHolder.readUInt32LE(0), subKeyW, 0, converter.code, converted.pointer, converted.length);
        }
        if (value === undefined && code2 === windows.API_constants.returnCodes.FILE_NOT_FOUND) { // Do not fail if delete was requested for nonexistent key
            return togo;
        }
        // TODO: consider plausible errors which might result from this process
        cr(code2);
    } finally {
        advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
    }
    return togo;
};

// Note that this function cannot delete keys recursively. RegDeleteKeyExW is not available
// as a result of requirement for Windows XP level API support. This functionality can be
// implemented manually on top of this existing API if required.
// NB: This utility is currently used only to clean up state from within test cases
windows.deleteRegistryKey = function (baseKey, path) {
    var regPath = windows.parseRegistryPath(path);
    var pathW = windows.ensureAlignment(windows.toWideChar(regPath.realPath).pointer);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegDeleteKeyExW(base, pathW, regPath.desiredAccess, 0);
    // Do not fail if delete was requested for nonexistent key
    if (code !== windows.API_constants.returnCodes.FILE_NOT_FOUND) {
        cr(code);
    }
};

/**
 * Enumerates the values in a key.
 *
 * @param {String} baseKey The registry base key.
 * @param {String} path The key path.
 * @return {*} An object containing the name, data, type, and size of each value.
 */
windows.enumRegistryValues = function (baseKey, path) {
    var togo = {};
    var keyHolder = new Buffer(4);
    var openError = windows.openRegistryKey(baseKey, path, keyHolder);
    if (openError) {
        return openError;
    }

    try {
        var maxLength = 0xffff;
        var nameLength = new Buffer(4);
        var typeHolder = new Buffer(4);
        var nameHolder = new Buffer(maxLength);
        var dataSizeHolder = new Buffer(maxLength);

        for (var index = 0; ; index++) {
            // Get the name, type, and data length of the next value.
            nameLength.writeUInt32LE(Number(maxLength), 0);
            var code2 = advapi32.RegEnumValueW(keyHolder.readUInt32LE(0), index, nameHolder, nameLength, NULL, typeHolder, NULL, dataSizeHolder);
            if (code2 === windows.API_constants.returnCodes.FILE_NOT_FOUND) {
                return togo;
            } else if (code2 === windows.API_constants.returnCodes.ERROR_NO_MORE_ITEMS) {
                break;
            } else {
                cr(code2);
            }

            var value = {
                name: windows.fromWideChar(nameHolder),
                bytes: dataSizeHolder.readInt32LE(0),
                type: null,
                data: null
            };

            togo[value.name] = value;

            // Add an extra 2 bytes to ensure the return is always null terminated (numeric values will ignore it).
            var dataHolder = new Buffer(value.bytes + 2);
            dataHolder.fill(0);
            var code3 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), nameHolder, NULL, typeHolder, dataHolder, dataSizeHolder);
            cr(code3);

            // Get the type converter
            var typeCode = typeHolder.readUInt32LE(0);
            if (typeCode === 2) {
                // Cater for REG_EXPAND_SZ (RegGetValue should really have been used if expansion is required)
                typeCode = windows.registryTypes.REG_SZ.code;
            }
            var converter = null;
            for (var regType in windows.registryTypes) {
                if (windows.registryTypes.hasOwnProperty(regType) && windows.registryTypes[regType].code === typeCode) {
                    converter = windows.registryTypes[regType];
                    value.type = regType;
                    break;
                }
            }
            if (converter) {
                value.data = converter.readConvert(dataHolder, dataSizeHolder.readUInt32LE(0));
            }
        }
    } finally {
        windows.closeRegistryKey(keyHolder);
    }

    return togo;
};

windows.registrySettingsHandler.setImpl = function (payload) {
    var baseKey = payload.options.hKey;
    var path = payload.options.path;
    var dataTypes = payload.options.dataTypes;

    var results = fluid.transform(payload.settings, function (value, key) {
        if (dataTypes[key] === undefined) {
            fluid.fail("No registry dataType defined in options block for the setting " + key);
        }
        var dataType = dataTypes[key];
        var oldValue = windows.readRegistryKey(baseKey, path, key, dataType);
        var writeStatus = windows.writeRegistryKey(baseKey, path, key, value, dataType);
        var newValue = windows.readRegistryKey(baseKey, path, key, dataType);
        return {
            oldValue: oldValue.value,
            statusCode: writeStatus.statusCode,
            newValue: newValue.value
        };
    });

    fluid.log("Registry settings handler SET returning results ", results);
    return results;
};

windows.registrySettingsHandler.getImpl = function (payload) {
    var baseKey = payload.options.hKey;
    var path = payload.options.path;
    var dataTypes = payload.options.dataTypes;
    if (dataTypes === undefined) {
        fluid.fail("No registry dataTypes block defined in options. Full payload: " +
            JSON.stringify(payload, null, 4));
    }
    var results = fluid.transform(payload.settings, function (value, key) {
        if (dataTypes[key] === undefined) {
            fluid.fail("No registry dataType defined in options block for the setting " + key);
        }
        var currentValue = windows.readRegistryKey(baseKey, path, key, dataTypes[key]);
        return currentValue.value;
    });
    fluid.log("Registry settings handler GET returning results ", results);
    return results;
};

windows.registrySettingsHandler.get = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(windows.registrySettingsHandler.getImpl, payload);
};

windows.registrySettingsHandler.set = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(windows.registrySettingsHandler.setImpl, payload);
};
