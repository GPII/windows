/*
 * Windows Kill Process Unit Tests
 *
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");
var shelljs = require("shelljs");
var path = require("path");
var child_process = require("child_process");

require("../processHandling.js");

fluid.registerNamespace("gpii.tests.windows.processHandling");

var waitExe = "gpii-process-handling-test.exe";
var waitExePath = null;

jqUnit.module("gpii.tests.windows.processHandling", {
    setup: function () {
        // Take a copy of the built-in "waitfor" command, to ensure a unique process name.
        // This command is a glorified "sleep" that is also able to be terminated "nicely".
        waitExePath = path.join(process.env.TEMP, waitExe);
        shelljs.cp(path.join(process.env.SystemRoot, "/System32/waitfor.exe"), waitExePath);
    },
    teardown: function () {
        if (waitExePath !== null) {
            gpii.windows.killProcessByName(waitExe);
            shelljs.rm(waitExePath);
        }
    }
});

jqUnit.test("Testing findProcessByName", function () {
    // Find a process that isn't running.
    var pid = gpii.windows.findProcessByName("a non-matching process.exe");
    jqUnit.assertEquals("Process should not have been found running", null, pid);

    // Find a process that is running.
    pid = gpii.windows.findProcessByName("node.exe");
    jqUnit.assertNotEquals("Process should have been found running", null, pid);

    // Find a process that is running, full details
    var details = gpii.windows.findProcessByName("node.exe", false, true);
    jqUnit.assertNotEquals("Process should have been found running (fullInfo)", null, details);
    jqUnit.assertTrue("pid should be a number", typeof(details.pid) === "number");
    jqUnit.assertTrue("ppid should be a number", typeof(details.ppid) === "number");
    jqUnit.assertEquals("exeFile should be node.exe", "node.exe", details.exeFile.toLowerCase());

    // Find multiple processes. There's always more than one svchost.exe running on Windows.
    var pids = gpii.windows.findProcessByName("svchost.exe", true);
    jqUnit.assertTrue("Should have found several matching process.", pids.length > 1);
});

jqUnit.test("Testing isProcessRunning", function () {
    // Check a PID that isn't running.
    var running = gpii.windows.isProcessRunning(-1);
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check a PID that is running.
    running = gpii.windows.isProcessRunning(process.pid);
    jqUnit.assertTrue("Process should have been found running", running);

    // Check an exe file that isn't running.
    running = gpii.windows.isProcessRunning("a non-matching process.exe");
    jqUnit.assertFalse("Process should not have been found running", running);

    // Check an exe file that is running.
    running = gpii.windows.isProcessRunning("node.exe");
    jqUnit.assertTrue("Process should have been found running", running);

    // Check multiple processes. There's always more than one svchost.exe running on Windows.
    running = gpii.windows.isProcessRunning("svchost.exe", true);
    jqUnit.assertTrue("Process should have been found running (multiple processes)", running);
});

jqUnit.asyncTest("Testing timeout waiting for processes start", function () {
    jqUnit.expect(1);

    var exe = "a non-matching process.exe";
    gpii.windows.waitForProcessStart(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not be running");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing timeout waiting for processes termination", function () {
    jqUnit.expect(1);

    var exe = "node.exe";
    gpii.windows.waitForProcessTermination(exe, { timeout: 100 })
        .then(function () {
            jqUnit.fail("The process '" + exe + "' should not have terminated");
        }, function () {
            jqUnit.assert("Should have timed out");
            jqUnit.start();
        });
});

jqUnit.asyncTest("Testing waiting for processes start and end", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // Timeout waiting for the process start/end after 10 seconds.
    var options = { timeout: 10000 };

    // Wait for it to start.
    gpii.windows.waitForProcessStart(waitExe, options)
        .then(function () {
            jqUnit.assert("We just started the new process.");

            // Wait for it to die
            gpii.windows.waitForProcessTermination(waitExe, options)
                .then(function () {
                    jqUnit.assert("Child process terminated.");
                    jqUnit.start();
                }, function () {
                    jqUnit.fail("Failed to detect process termination.");
                });

            // Tell the process to stop now.
            child_process.execSync("waitfor /SI waitForProcessTerminationTest");
        }, function () {
            jqUnit.fail("Failed to detect process start.");
        });

    // Create the process, with a 5 second timeout
    child_process.exec(waitExePath + " waitForProcessTerminationTest /T 5 > nul");
});

jqUnit.asyncTest("Testing Killing Processes", function () {
    jqUnit.expect(3);

    var pid = gpii.windows.findProcessByName(waitExe);
    jqUnit.assertEquals("The process should not already be running.", null, pid);

    // On the call below, async is true because if it is false shelljs will
    // wait around until it is manually killed before continuing with the
    // rest of the tests.
    var command =  waitExePath + " killProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command, function (error, stdout, stderr) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Process should have terminated with code SIGKILL", 9, error.code);
        fluid.log("Program output:", stdout);
        fluid.log("Program stderr:", stderr);
        jqUnit.start();
    });

    // Kill the process when it starts
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("The process has started");
            gpii.windows.killProcessByName(waitExe);
        });
});

jqUnit.asyncTest("Testing closeProcessByName", function () {
    jqUnit.expect(3);
    var exitCode = 5;

    // Start a process that creates a window.
    var exeName = "test-window.exe";
    var exePath = path.join(__dirname, exeName);
    var command =  exePath + " -window";

    fluid.log("Executing " + command);
    var child = child_process.exec(command, function (error) {
        fluid.log("Exit code:", error.code);
        jqUnit.assertEquals("Exit code", exitCode, error.code);
    });

    child.stdout.on("data", function (data) {
        // Wait for the window to be created
        if (data.match("Window created")) {
            jqUnit.assert("Window is created");

            gpii.windows.closeProcessByName(exeName, {cleanOnly: true, timeout: 1000, exitCode: exitCode})
                .then(function (clean) {
                    jqUnit.assertTrue("Should have closed cleanly", clean);
                    jqUnit.start();
                }, function (e) {
                    fluid.log(e.message);
                    jqUnit.fail("Process should have closed.");
                    gpii.windows.killProcessByName(exeName);
                });
        }
    });
});

jqUnit.asyncTest("Testing closeProcessByName (window-less process)", function () {
    jqUnit.expect(3);

    // Start a process that does not have a window.
    gpii.windows.waitForProcessStart(waitExe)
        .then(function () {
            jqUnit.assert("Process started");

            // The process doesn't have any windows, so this should fail to terminate it.
            gpii.windows.closeProcessByName(waitExe, {cleanOnly: true})
                .then(function () {
                    jqUnit.fail("Process should not have closed.");
                }, function (e) {
                    jqUnit.assert("Process not closed");
                    fluid.log(e.message);
                    // Retry with force
                    gpii.windows.closeProcessByName(waitExe, {cleanOnly: false})
                        .then(function () {
                            jqUnit.assert("Process terminated");
                            jqUnit.start();
                        });
                });
        });

    var command =  waitExePath + " closeProcessByNameTest /T 30";
    fluid.log("Executing " + command);
    child_process.exec(command);
});

jqUnit.asyncTest("Testing getProcessPath", function () {
    jqUnit.expect(3);

    var exeName = waitExe;
    var exePath = waitExePath;
    var args = [ "getProcessPathTest", "/T", "30"];

    fluid.log("Executing " + exePath);
    var child = child_process.spawn(exePath, args);

    gpii.windows.waitForProcessStart(exeName)
        .then(function () {
            jqUnit.assert("Process started");

            // Test with the PID.
            var result1 = gpii.windows.getProcessPath(child.pid);
            jqUnit.assertEquals("The exe path should be correct (pid)", exePath, result1);

            // Test with the process handle.
            var hProcess = gpii.windows.kernel32.OpenProcess(
                gpii.windows.API_constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, child.pid);

            try {
                var result2 = gpii.windows.getProcessPath(null, hProcess);
                jqUnit.assertEquals("The exe path should be correct (processHandle)", exePath, result2);
            } finally {
                gpii.windows.kernel32.CloseHandle(hProcess);
            }

            child.kill();
        });
    child.on("close", jqUnit.start);
});

jqUnit.test("Testing getServiceState", function () {
    // Local Session Manager will always be running.
    var state = gpii.windows.getServiceState("LSM");
    jqUnit.assertEquals("LSM service should be running", "running", state);

    // There's a chance it might be running, but who sends faxes anymore?
    state = gpii.windows.getServiceState("Fax");
    jqUnit.assertEquals("Fax service should be stopped", "stopped", state);

    state = gpii.windows.getServiceState("gpii-unknown");
    jqUnit.assertEquals("gpii-unknown service should be unknown", "unknown", state);
});
