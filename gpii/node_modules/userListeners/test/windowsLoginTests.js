/*
 * Tests for the windows login user listener.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    os = require("os"),
    path = require("path"),
    fs = require("fs"),
    child_process = require("child_process");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.userListener");

require("../index.js");

var teardowns = [];

jqUnit.module("gpii.tests.userListener.windowsLogin", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

fluid.defaults("gpii.tests.userListener.windowsLogin", {
    gradeNames: ["fluid.component", "gpii.windows.userListeners.windowsLogin"],
    listeners: {
        "onTokenArrive.callFlowManager": "fluid.identity",
        "onTokenRemove.callFlowManager": "fluid.identity"
    },
    distributeOptions: {
        service: {
            record: "gpii.test.userListeners.windowsLoginService",
            target: "{/ gpii.userListeners.windows}.options.gradeNames"
        }
    }
});

// Give the user listeners an "onServiceReady" event.
fluid.defaults("gpii.test.userListeners.windowsLoginService", {
    gradeNames: ["fluid.component"],
    components: {
        service: {
            type: "fluid.component",
            options: {
                events: {
                    "onServiceReady": null
                }
            }
        }
    }
});

jqUnit.asyncTest("testing getting the user's SID", function () {

    jqUnit.expect(5);

    // User SIDs begin with this.
    var sidPrefix = "S-1-5-21-";
    var sid = gpii.windows.getUserSid();

    jqUnit.assertEquals("getUserSid should return a string", "string", typeof(sid));
    jqUnit.assertTrue("return from getUserSid should look like an SID", sid.startsWith(sidPrefix));

    var sid2 = gpii.windows.getUserSid();
    var sid3 = gpii.windows.getUserSid();
    jqUnit.assertEquals("getUserSid should always return the same value", sid, sid2);
    jqUnit.assertEquals("getUserSid should always return the same value (again)", sid, sid3);

    // Compare it to the value from the "whoami" command.
    child_process.exec("%SystemRoot%\\System32\\whoami.exe /user", function (err, stdout, stderr) {
        if (err) {
            jqUnit.fail(err);
        }
        fluid.log("whoami:", stdout, stderr);
        jqUnit.assertTrue("SID should match the whoami command output", stdout.trim().endsWith(sid));
        jqUnit.start();
    });
});

jqUnit.test("testing hexToGuid", function () {

    jqUnit.expect(2);

    var expect = "01234567-89ab-cdef-0123-456789abcdef";

    var guid1 = gpii.windows.userListeners.hexToGuid("0123456789abcdef0123456789abcdef");
    jqUnit.assertEquals("hex string should produce the expected GUID (32 chars)", expect, guid1);

    var guid2 =
        gpii.windows.userListeners.hexToGuid("0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef");
    jqUnit.assertEquals("hex string should produce the expected GUID (over 32 chars)", expect, guid2);

    jqUnit.expectFrameworkDiagnostic("hexToGuid should fails with a short string (16 chars)", function () {
        gpii.windows.userListeners.hexToGuid("0123456789abcdef");
    }, "hexToGuid wants a longer string");
});

jqUnit.test("Testing getUserId", function () {

    // Windows Account SID
    var userIdResult = gpii.windows.userListeners.getUserId("userid");
    var expectedSid = gpii.windows.getUserSid();
    jqUnit.assertEquals("getUserId(userid) should return the user's SID", expectedSid, userIdResult);

    // Windows username
    var usernameResult = gpii.windows.userListeners.getUserId("username");
    jqUnit.assertEquals("getUserId(username) should return the user's username", os.userInfo().username, usernameResult);

    // File content
    var testFile = path.join(os.tmpdir(), "gpii-username-test" + Math.random());
    teardowns.push(function () {
        fs.unlinkSync(testFile);
    });

    var expectFileResult = "test-userid" + Math.random();
    fs.writeFileSync(testFile, expectFileResult);

    var fileResult = gpii.windows.userListeners.getUserId("file:" + testFile);
    jqUnit.assertEquals("getUserId(file) should return the correct value", expectFileResult, fileResult);

    var testEnvFile = path.join("%TEMP%", path.basename(testFile));
    var fileEnvResult = gpii.windows.userListeners.getUserId("file:" + testEnvFile);
    jqUnit.assertEquals("getUserId(file) should return the correct value", expectFileResult, fileEnvResult);

    // Case-insensitive test
    var expectFileResult2 = "TEST-userid2" + Math.random();
    fs.writeFileSync(testFile, expectFileResult2);

    var fileResult2 = gpii.windows.userListeners.getUserId("file:" + testFile);
    jqUnit.assertEquals("getUserId(file) should return the correct value, in lower case",
        expectFileResult2.toLowerCase(), fileResult2);

    // File content (no file)
    var noFileResult = gpii.windows.userListeners.getUserId("file:c:\\not\\exists");
    jqUnit.assertEquals("getUserId(no file) should return the correct value", null, noFileResult);

    // Registry value
    var baseKey = "HKEY_CURRENT_USER";
    var subKey = "Software\\gpii-temp";
    var valueName = "username-test";
    var userValue = "test-userid" + Math.random();
    gpii.windows.writeRegistryKey(baseKey, subKey, valueName, userValue, "REG_SZ");
    teardowns.push(function () {
        if (subKey.endsWith("gpii-temp")) {
            gpii.windows.deleteRegistryKey(baseKey, subKey);
        }
    });

    fluid.each(["reg:", "regkey:"], function (prefix) {
        var expectedValue = prefix === "reg:"
            ? userValue
            : ("gpiikey:" + userValue);

        var regResult = gpii.windows.userListeners.getUserId(prefix + baseKey + "\\" + subKey + "\\" + valueName);
        jqUnit.assertEquals("getUserId(file) should return the correct value", expectedValue, regResult);

        // Abbreviated base key
        var regResult2 = gpii.windows.userListeners.getUserId(prefix + "HKCU\\" + subKey + "\\" + valueName);
        jqUnit.assertEquals("getUserId(file) should return the correct value", expectedValue, regResult2);

        // Non existing registry key
        var regResult3 = gpii.windows.userListeners.getUserId(prefix + "HKCU\\gpii\\does\\not\\exist");
        jqUnit.assertEquals("getUserId(file) should return the correct value", null, regResult3);
    });
});

jqUnit.test("testing blocked user name matching", function () {
    var tests = [
        {
            blockedUsers: [],
            usernames: {
                "empty1": false,
                "empty2": false
            }
        },
        {
            blockedUsers: [ "one", "*two", "three*", "*four*" ],
            usernames: {
                "one": true,
                "two": true,
                "three": true,
                "four": true,

                "a_one": false,
                "a_two": true,
                "a_three": false,
                "a_four": true,

                "one_b": false,
                "two_b": false,
                "three_b": true,
                "four_b": true,

                "a_one_b": false,
                "a_two_b": false,
                "a_three_b": false,
                "a_four_b": true,

                "xyz": false
            }
        },
        {
            blockedUsers: [ "one*two", "*three*four", "five*six*", "*seven*eight*" ],
            usernames: {
                "one_x_two": true,
                "three_x_four": true,
                "five_x_six": true,
                "seven_x_eight": true,

                "a_one_x_two": false,
                "a_three_x_four": true,
                "a_five_x_six": false,
                "a_seven_x_eight": true,

                "one_x_two_b": false,
                "three_x_four_b": false,
                "five_x_six_b": true,
                "seven_x_eight_b": true,

                "a_one_x_two_b": false,
                "a_three_x_four_b": false,
                "a_five_x_six_b": false,
                "a_seven_x_eight_b": true
            }
        },
        {
            blockedUsers: [ "on?", "t?o", "?hree", "f?ur", "?iv?", "si?*", "s?v*" ],
            usernames: {
                "one": true,
                "two": true,
                "three": true,
                "four": true,
                "five": true,
                "six": true,
                "seven": true,
                "eight": false
            }
        }
    ];

    fluid.each(tests, function (test) {
        fluid.each(test.usernames, function (expected, username) {
            var result = gpii.windows.userListeners.checkBlockedUser(test.blockedUsers, username);
            jqUnit.assertEquals("blockedUser " + username, expected, result);
        });
    });
});

jqUnit.asyncTest("testing blocked local accounts", function () {
    // Create an instance with the current user being a blocked user
    var windowsLogin = gpii.tests.userListener.windowsLogin({
        config: {
            blockedUsers: [os.userInfo().username]
        }
    });

    jqUnit.expect(2);
    windowsLogin.getGpiiKey = function () {
        return fluid.promise().resolve("getGpiiKey");
    };
    var blockedPromise = gpii.windows.userListeners.startWindowsLogin(windowsLogin);

    jqUnit.assertTrue("startWindowsLogin should return a promise", fluid.isPromise(blockedPromise));

    blockedPromise.then(function () {
        jqUnit.fail("startWindowsLogin should not resolve");
    }, function (reason) {
        jqUnit.assertEquals("startWindowsLogin should reject with 'blocked'", "blocked", reason);
        jqUnit.start();
    });
});

jqUnit.asyncTest("testing getGpiiKey", function () {
    var windowsLogin = gpii.tests.userListener.windowsLogin({
        config: {
            userIdSource: "userid"
        }
    });

    jqUnit.expect(2);

    var sid = gpii.windows.getUserSid();
    var expectedKey = "01234567-89ab-cdef-0123-456789abcdef";

    var sign = function (payload) {
        jqUnit.assertEquals("signing function should be called with the current SID", sid, payload);
        return fluid.toPromise("0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef");
    };

    gpii.windows.userListeners.getGpiiKey(windowsLogin, sign).then(function (key) {
        jqUnit.assertEquals("getGpiiKey should resolve with the expected key", expectedKey, key);
        jqUnit.start();
    });
});

jqUnit.asyncTest("testing getGpiiKey (got a gpiiKey)", function () {
    var gpiiKey = "test-key" + Math.random();

    var baseKey = "HKEY_CURRENT_USER";
    var subKey = "Software\\gpii-temp";
    var valueName = "username-test";
    var userValue = gpiiKey;
    gpii.windows.writeRegistryKey(baseKey, subKey, valueName, userValue, "REG_SZ");
    teardowns.push(function () {
        if (subKey.endsWith("gpii-temp")) {
            gpii.windows.deleteRegistryKey(baseKey, subKey);
        }
    });

    var windowsLogin = gpii.tests.userListener.windowsLogin({
        config: {
            userIdSource: path.join("regkey:" + baseKey, subKey, valueName)
        }
    });

    var sign = function () {
        jqUnit.fail("signing function should not be called for a gpiiKey");
        return fluid.promise().reject();
    };

    gpii.windows.userListeners.getGpiiKey(windowsLogin, sign).then(function (key) {
        jqUnit.assertEquals("getGpiiKey should resolve with the expected key", gpiiKey, key);
        jqUnit.start();
    }, fluid.fail);
});

jqUnit.asyncTest("testing getGpiiKey, with blocked user id", function () {
    var testFile = path.join(os.tmpdir(), "gpii-username-test" + Math.random());
    teardowns.push(function () {
        fs.unlinkSync(testFile);
    });
    fs.writeFileSync(testFile, "blocked-user");


    var windowsLogin = gpii.tests.userListener.windowsLogin({
        config: {
            userIdSource: "file:" + testFile,
            blockedUsers: [ "blocked-*" ]
        }
    });

    jqUnit.expect(0);

    var sign = function () {
        jqUnit.fail("sign function should not be called for a blocked user id");
    };

    gpii.windows.userListeners.getGpiiKey(windowsLogin, sign).then(function () {
        jqUnit.fail("getGpiiKey should not resolve");
    }, jqUnit.start());
});
