/*
 * Debug logging.
 * Writes some information about the process/system that could aid in debugging problems found during the Hardware
 * Sensitivity Tests.
 *
 * Copyright 2017 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("universal");
var ref = require("ref");
var fs = require("fs");

require("../WindowsUtilities/WindowsUtilities.js");
require("../processHandling/processHandling.js");
require("../registrySettingsHandler");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.windows.debugLog");

/**
 * The logging level for the debug log entries.
 * @type {number}
 */
gpii.windows.debugLog.logLevel = fluid.logLevel.IMPORTANT;

/**
 * Logs some information for debugging:
 * - Version
 * - Environment variables
 * - Whether or not the process is running as Administrator
 * - The CPU architecture
 * - Running processes
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 */
gpii.windows.debugLog.logDebugInfo = function (options) {
    options = options || {};

    var logLevel = fluid.isLogLevel(options.logLevel) ? options.logLevel : gpii.windows.debugLog.logLevel;
    if (fluid.passLogLevel(logLevel)) {
        var funcs = ["logVersion", "logEnvironment", "logAdministrator", "logArchitecture", "logRunningProcesses"];

        var origLogSize = fluid.logObjectRenderChars;
        fluid.logObjectRenderChars = 0xffff;

        for (var n = 0, len = funcs.length; n < len; n++) {
            gpii.windows.debugLog[funcs[n]](options);
        }

        fluid.logObjectRenderChars = origLogSize;
    }
};

/**
 * Logs the given message.
 *
 * @param message {String} The log entry.
 * @param options {Object} Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 */
gpii.windows.debugLog.logMessage = function (message, options) {
    options = options || {};
    var logLevel = fluid.isLogLevel(options.logLevel) ? options.logLevel : gpii.windows.debugLog.logLevel;
    fluid.log(logLevel, message);
};

/**
 * Logs the GPII version, from package.json.
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logVersion = function (options) {
    options = options || {};

    var root = fluid.module.resolvePath("%gpii-windows");

    // Read the version from package.json
    var content = fs.readFileSync(root + "/package.json");
    var pkg = JSON.parse(content);
    var output = "GPII Version " + pkg.version;

    gpii.windows.debugLog.logMessage(output, options);

    return output;
};
/**
 * Logs the environment variables.
 *
 * @param options {Object} Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logEnvironment = function (options) {
    options = options || {};

    var output = "";
    fluid.each(process.env, function (value, name) {
        output += name + "=" + value + "\n";
    });

    gpii.windows.debugLog.logMessage("Environment variables\n" + output, options);

    return output;
};

/**
 * Logs whether or not the process is being run as an administrator, and whether UAC is on.
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logAdministrator = function (options) {
    options = options || {};

    // Note: it is possible to be running as a non-admin even though UAC is off, if the user is a non-admin user.
    var isAdmin = gpii.windows.isUserAdmin();
    var uacEnabled = gpii.windows.readRegistryKey("HKEY_LOCAL_MACHINE",
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "EnableLUA", "REG_DWORD");
    var output = "Running as admin: " + (isAdmin ? "YES" : "NO") + ", UAC is " + (uacEnabled ? "ON" : "OFF");

    gpii.windows.debugLog.logMessage(output, options);

    return output;
};

/**
 * Logs the CPU architecture the process is running on.
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logArchitecture = function (options) {
    options = options || {};

    var output = "Architecture: " + process.arch;
    if (gpii.windows.isWow64()) {
        output += " (on 64-bit OS)";
    }

    gpii.windows.debugLog.logMessage(output, options);

    return output;
};

/**
 * Logs the currently running processes.
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logRunningProcesses = function (options) {
    options = options || {};

    var procs = gpii.windows.getRunningProcesses();

    var outputLines = fluid.transform(procs, function (proc) {
        // Get the full path of the executable
        var exePath = proc.exeFile;
        var hProcess = gpii.windows.kernel32.OpenProcess(gpii.windows.API_constants.PROCESS_QUERY_LIMITED_INFORMATION, 0, proc.pid);
        if (hProcess) {
            var size = ref.alloc(gpii.windows.types.DWORD);
            size.writeUInt32LE(gpii.windows.API_constants.MAX_PATH, 0);
            var path = new Buffer(gpii.windows.API_constants.MAX_PATH);

            var success = gpii.windows.kernel32.QueryFullProcessImageNameW(hProcess, 0, path, size);
            if (success) {
                exePath = gpii.windows.fromWideChar(path);
            }
            gpii.windows.kernel32.CloseHandle(hProcess);
        }

        return exePath;
    });

    var output = outputLines.join("\n");

    gpii.windows.debugLog.logMessage(output, options);

    return output;
};

/**
 * Logs the version of GPII
 *
 * @param options {Object} [Optional] Options
 * @param options.logLevel {String} The log level to use, instead of windows.debugLog.logLevel (See fluid.logLevelsSpec)
 * @return {String} Returns a string containing the debug information.
 */
gpii.windows.debugLog.logArchitecture = function (options) {
    options = options || {};

    var output = "Architecture: " + process.arch;
    if (gpii.windows.isWow64()) {
        output += " (on 64-bit OS)";
    }

    gpii.windows.debugLog.logMessage(output, options);

    return output;
};

gpii.windows.debugLog.logDebugInfo();
