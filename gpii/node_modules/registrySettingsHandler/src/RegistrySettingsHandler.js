/*!
Windows Registry Settings Handler

Copyright 2012 Raising the Floor - International
Copyright 2012 Antranig Basman
Copyright 2012 Astea Solutions AD

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict"; 

var ffi = require("node-ffi");
var ref = require("ref");
var fluid = require("universal");
var $ = fluid.jQueryStandalone;

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");
var util = require('../../WindowsUtilities/WindowsUtilities');

var NULL = ref.NULL;

var user32 = new ffi.Library('user32', {
    'MessageBoxW': [
        'int32', [ 'int32', "pointer", 'pointer', 'int32' ]
    ]
});

// Guide to node_ffi types and conversions:
// https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial

var advapi32 = new ffi.Library("advapi32", {
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, REGSAM, PHKEY
    // Note abuse of type of argument 1 - node_ffi doesn't allow us to forge pointers from integers directly,
    // as required by base keys 
    RegOpenKeyExW: [
        "int32", ["uint32", "pointer", "uint32", "uint32", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724837(v=vs.85).aspx
    // HKEY
    RegCloseKey: [
        "long", ["uint32"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724911(v=vs.85).aspx
    // HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD
    RegQueryValueExW: [
        "int32", ["uint32", "pointer", "pointer", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724844(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD
    // Similar abuse to RegOpenKeyExW
    RegCreateKeyExW: [
        "long", ["uint32", "pointer", "uint32", "pointer", "uint32", "uint32", "pointer", "pointer", "pointer"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx
    // HKEY, LPCWSTR, DWORD, DWORD, const BYTE*, DWORD
    RegSetValueExW: [
        "long", ["uint32", "pointer", "uint32", "uint32", "pointer", "uint32"]
    ],
    // http://msdn.microsoft.com/en-us/library/windows/desktop/ms724847(v=vs.85).aspx
    // HKEY, LPCWSTR, REGSAM, DWORD
    RegDeleteKeyExW: [
        "long", ["uint32", "pointer", "uint32", "uint32"]
    ]
});

windows.registryTypes = {};

windows.registryTypes.REG_SZ = {
    code: 1,
    readConvert: function (pointer) {
        return windows.fromWideChar(pointer);
    },
    writeConvert: function (value) {
        return windows.toWideChar(value);
    }
};

windows.registryTypes.REG_DWORD = {
    code: 4, 
    readConvert: function (pointer) {
        return pointer.readUInt32LE(0);
    },
    writeConvert: function (value) {
        var pointer = new Buffer(4);
        pointer.writeUInt32LE(value, 0);
        return {
            pointer: pointer,
            length: 4
        };
    }
};

windows.registryTypes.REG_BINARY = {
    code: 3,
    readConvert: function (pointer, count) {
        return gpii.pointerToHex(pointer, count);
    },
    writeConvert: function (value) {
        return gpii.hexToPointer(value);
    }
};

var c = windows.API_constants; 

windows.getBaseKey = function (baseKey) {
    var key = c[baseKey];
    if (key === undefined) {
        fluid.fail("Unknown registry base key " + baseKey);
    }
    return key;
};

var cr = windows.checkReturnCode;

windows.readRegistryKey = function (baseKey, path, subKey, type) {
    //console.log("\nread", baseKey, path, subKey, type, ":")
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };
  
    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var keyHolder = new Buffer(4);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegOpenKeyExW(base, pathW, 0, c.KEY_QUERY_VALUE, keyHolder);
    if (code === 2) { // FILE_NOT_FOUND
        togo.statusCode = 404;
        return togo;
    }
    cr(code);
    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);        
        var dataLength = new Buffer(4);
        var code2 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, NULL, dataLength);
        if (code2 === 2) { // FILE_NOT_FOUND
            togo.statusCode = 404;
            return togo;
        }
        cr(code2);
        togo.bytes = dataLength.readInt32LE(0);
        
        var valueHolder = new Buffer(togo.bytes);
        var code3 = advapi32.RegQueryValueExW(keyHolder.readUInt32LE(0), subKeyW, NULL, NULL, valueHolder, dataLength);
        cr(code3);
        
        togo.value = converter.readConvert(valueHolder, togo.bytes);
    } finally {
        var code4 = advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
        cr(code4);
    }

    return togo;
};

windows.writeRegistryKey = function (baseKey, path, subKey, value, type) {
    //console.log("\nwrite", baseKey, path, subKey, type, ":")
    var converter = windows.registryTypes[type];
    if (!converter) {
        fluid.fail("Unsupported registry type " + type);
    }
    var togo = {
        statusCode: 200
    };
    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var keyHolder = new Buffer(4);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegCreateKeyExW(base, pathW, 0, NULL, 0, c.KEY_SET_VALUE, NULL, keyHolder, NULL);
    cr(code);

    try {
        var subKeyW = windows.ensureAlignment(windows.toWideChar(subKey).pointer);
        var converted = converter.writeConvert(value);
        var code2 = advapi32.RegSetValueExW(keyHolder.readUInt32LE(0), subKeyW, 0, converter.code, converted.pointer, converted.length);
        // TODO: consider plausible errors which might result from this process
        cr(code2);
    } finally {
        advapi32.RegCloseKey(keyHolder.readUInt32LE(0));
    }
    return togo;
};

windows.deleteRegistryKey = function (baseKey, path) {
    var pathW = windows.ensureAlignment(windows.toWideChar(path).pointer);
    var base = windows.getBaseKey(baseKey);
    var code = advapi32.RegDeleteKeyExW(base, pathW, 0, 0);
    cr(code);
};

windows.registrySettingsHandlerOne = function (payload) {
    var baseKey = payload.options.hKey;
    var path = payload.options.path;
    var results = fluid.transform(payload.settings, function (value, key) {
        var oldValue = windows.readRegistryKey(baseKey, path, key, value.dataType);
        var writeStatus = windows.writeRegistryKey(baseKey, path, key, value.value, value.dataType);
        var newValue = windows.readRegistryKey(baseKey, path, key, value.dataType);
        return {
            oldValue: oldValue,
            statusCode: writeStatus.statusCode,
            newValue: newValue
        };
    });
    console.log("Settings handler returning results ", results);
    return results;
};

gpii.invokeSettingsHandler = function (payload, handler) {
    // TODO: use model transformation
    return fluid.transform(payload, function (oneSolution) {
        return fluid.transform(oneSolution, function (element) {
              // TODO: more efficient algorithm
            var directLoad = fluid.filterKeys(fluid.copy(element), ["settings", "options"]);
            var others = fluid.censorKeys(fluid.copy(element), ["settings", "options"]);
            var results = {
                settings: handler(directLoad)
            };
            return $.extend(results, others);
        });
    });
};

windows.registrySettingsHandler = function (payload) {
    return gpii.invokeSettingsHandler(payload, windows.registrySettingsHandlerOne);
};

function expect(expected, actual) {
    if (actual !== expected) {
        console.log("FAIL: retrieved value " + actual + " where " + expected + " was required");
    }
}

function testSelf() {
    // A self-test driver that reads and writes some values from the live registry
    // Don't worry, this is perfectly safe!

    var value = windows.readRegistryKey("HKEY_LOCAL_MACHINE", "HARDWARE\\DEVICEMAP\\SERIALCOMM", "\\Device\\Serial0", "REG_SZ"); 
    console.log("Retrieved value " + value.value);
    
    var value2 = windows.readRegistryKey("HKEY_LOCAL_MACHINE", "HARDWARE\\DEVICEMAP\\VIDEO", "MaxObjectNumber", "REG_DWORD"); 
    console.log("Retrieved value " + value2.value);
    
    var value3 = windows.readRegistryKey("HKEY_LOCAL_MACHINE", "HARDWARE\\DEVICEMAP\\VIDEO", "ObjectNumberList", "REG_BINARY"); 
    console.log("Retrieved value " + value3.value);
    
    var dwordValue = 100;
    windows.writeRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "Magnification", dwordValue, "REG_DWORD");
    var value4 = windows.readRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "Magnification", "REG_DWORD");
    console.log("Retrieved value " + value4.value);
    expect(dwordValue, value4.value);
    
    var unicodeString = "I am Agent Гюнтер";
    windows.writeRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "MagnificationAnnotation", unicodeString, "REG_SZ");
    var value5 = windows.readRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "MagnificationAnnotation", "REG_SZ");
    console.log("Retrieved value " + value5.value); // note that this may well display in the console incorrectly
    expect(unicodeString, value5.value);
    
    windows.writeRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "MagnificationBinary", "0a, b0, cAfebAbe", "REG_BINARY");
    var value6 = windows.readRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier", "MagnificationBinary", "REG_BINARY");
    console.log("Retrieved value " + value6.value);
    expect("0a b0 ca fe ba be", value6.value);
    
    // clean up after ourselves
    windows.deleteRegistryKey("HKEY_CURRENT_USER", "Software\\GPIIMagnifier");
}

if (process.argv[1].indexOf("egistrySettingsHandler") !== -1) {
    if (process.argv.length === 2) {
        testSelf();
    } else {
        var filename = __dirname + "/" + process.argv[2];
        // Note that this is now possible!
        // http://blog.gvm-it.eu/post/8175813806/node-js-0-5-2-load-json-files-with-require
        var testFile = require(filename);
        console.log("Executing payload: ", testFile);
        var results = windows.registrySettingsHandlerOne(testFile);
        console.log("Returned results: ", results);
        windows.deleteRegistryKey(testFile.options.hKey, testFile.options.path);
    }
}
    
//var OK_or_Cancel = user32.MessageBoxW(
//   0, windows.toWideChar(value), windows.toWideChar(path + "|" + subKey), 1
//);