/*
 * Tests for ribbon.js
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

require("../../WindowsUtilities/WindowsUtilities.js");

var fluid = require("gpii-universal"),
    path = require("path"),
    fs = require("fs"),
    rimraf = require("rimraf");

var jqUnit = fluid.require("node-jqunit");
var gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.officeRibbon");

require("../index.js");

var teardowns = [];
jqUnit.module("gpii.tests.officeRibbon", {
    teardown: function () {
        while (teardowns.length) {
            teardowns.pop()();
        }
    }
});

// Check it fails gracefully if the office automation instance can't be loaded
jqUnit.asyncTest("Testing ribbon reloading (successful failure)", function () {

    jqUnit.expect(2);

    var promise = gpii.windows.office.reloadRibbon("NoSuchApplication");
    jqUnit.assertTrue("reloadRibbon must return a promise", fluid.isPromise(promise));

    promise.then(function (value) {
        jqUnit.assertFalse("Failing to access Office should resolve with false", value);
        jqUnit.start();
    }, jqUnit.fail);
});

// Perform a (sort of) successful run.
jqUnit.asyncTest("Testing ribbon reloading - no windows open", function () {

    jqUnit.expect(2);
    var officeObject = {
        Windows: {
            Count: 0
        }
    };

    var promise = gpii.windows.office.reloadRibbon("TestApplication", null, officeObject);
    jqUnit.assertTrue("reloadRibbon must return a promise", fluid.isPromise(promise));

    promise.then(function (value) {
        jqUnit.assertTrue("reloadRibbon should resolve with true", value);
        jqUnit.start();
    }, jqUnit.fail);
});

// Testing the output of each target.*.xml file combined with each source.*.xml file.
// The expected data (expect.<target>+<source>.xml) is pre-generated using merge.xslt.
jqUnit.asyncTest("Testing updating XML", function () {

    var outputDir = path.join(__dirname, "data/out");
    try {
        fs.mkdirSync(outputDir);
    } catch (e) {
        // ignored
    }

    teardowns.push(function () {
        rimraf.sync(outputDir);
    });

    var tests = {
        targets: [],
        sources: []
    };

    var nameRegex = /^(source|target)\.(.*)\.xml$/i;
    var files = fs.readdirSync(path.join(__dirname, "data"));

    fluid.each(files, function (file) {
        var m = nameRegex.exec(file);
        if (m) {
            tests[m[1] + "s"].push({
                name: m[2],
                path: path.join(__dirname, "data", file)
            });
        }
    });

    var work = [];
    fluid.each(tests.targets, function (target) {
        fluid.each(tests.sources, function (source) {
            work.push(function () {
                var outputName = target.name + "+" + source.name + ".xml";
                fluid.log(outputName, target, source);
                var saveAs = path.join(outputDir, outputName);
                var expectPath = path.join(__dirname, "data", "expect." + outputName);

                var promise = fluid.promise();

                gpii.windows.office.applyRibbon(source.path, target.path, saveAs).then(function () {
                    var actual, expected;
                    // Load the documents, and compare the object.
                    fluid.promise.sequence([
                        gpii.windows.office.loadXML(saveAs).then(function (obj) {
                            actual = obj;
                        }),
                        gpii.windows.office.loadXML(expectPath).then(function (obj) {
                            expected = obj;
                        })
                    ]).then(function () {
                        // Remove the comments before comparing.
                        delete actual.$c;
                        delete expected.$c;

                        jqUnit.assertDeepEq("expected and actual documents match - " + outputName, expected, actual);

                        promise.resolve();
                    }, promise.reject);
                }, promise.reject);

                return promise;
            });
        });
    });

    fluid.promise.sequence(work).then(jqUnit.start, fluid.fail);
});
