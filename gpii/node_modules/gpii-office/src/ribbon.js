/* Reload the ribbon on Office Applications.
 *
 * Copyright 2019 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var fluid = require("gpii-universal"),
    path = require("path"),
    fs = require("fs"),
    xm = require("xml-mapping"),
    edge = process.versions.electron ? require("electron-edge-js") : require("edge-js");

var gpii = fluid.registerNamespace("gpii");
fluid.registerNamespace("gpii.windows.office");
fluid.registerNamespace("gpii.settingsHandlers.remoteFileSettingsHandler.office");

gpii.windows.office.reloadRibbonNative = edge.func({
    source: path.join(__dirname, "ribbonReload.cs"),
    typeName: "GPIIOffice.RibbonReload",
    references: ["System.Runtime.dll"]
});

fluid.defaults("gpii.windows.office.remoteFileDownload", {
    gradeNames: "gpii.settingsHandlers.remoteFileDownload",
    listeners: {
        "applyFile.updateXML": {
            priority: "after:write",
            funcName: "gpii.windows.office.applyRibbon",
            args: [
                "{that}.path",
                "{that}.stashPath",
                "{that}.path",
                "{that}.gpiiSettingsDir"
            ]
        }
    }
});

/**
 * Invoke the getter for the remoteFileSettingsHandler.
 *
 * @param {Object} payload The payload
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.office.get = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(function (p, solutionID) {
        return gpii.settingsHandlers.remoteFileSettingsHandler.getImpl(p, solutionID, gpii.windows.office.remoteFileDownload);
    }, payload);
};

/**
 * Invoke the setter for the remoteFileSettingsHandler.
 *
 * @param {Object} payload The payload
 * @return {Promise} Resolves with the response.
 */
gpii.settingsHandlers.remoteFileSettingsHandler.office.set = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(function (p, solutionID) {
        return gpii.settingsHandlers.remoteFileSettingsHandler.setImpl(p, solutionID, gpii.windows.office.remoteFileDownload);
    }, payload);
};

gpii.windows.office.loadXML = function (file) {
    var promise = fluid.promise();
    if (fs.existsSync(file)) {
        fs.readFile(file, "utf8", function (err, data) {
            if (err) {
                promise.reject(err);
            } else {
                promise.resolve(xm.tojson(data));
            }
        });
    } else {
        promise.resolve(null);
    }
    return promise;
};

/**
 * Inserts the tab elements from `sourceFile` into `targetFile` XML documents, saving it to `destinationFile`.
 *
 * `destinationFile` will contain `targetFile` with the additional tab elements from `sourceFile`.
 *
 * If a tab from sourceFile doesn't exist in targetFile, it is added. If it does exist, then set the visible
 * attribute of the target tab to the value of the source tab.
 *
 * @param {String} sourceFile The file containing the new data.
 * @param {String} targetFile The file containing the existing data
 * @param {String} destinationFile The file to save the result to.
 * @return {Promise} Resolves when complete.
 */
gpii.windows.office.applyRibbon = function (sourceFile, targetFile, destinationFile) {

    // Load the XML documents.
    var sourceDocument, targetDocument;
    var sourcePromise = gpii.windows.office.loadXML(sourceFile).then(function (obj) {
        sourceDocument = obj;
    });
    var targetPromise = gpii.windows.office.loadXML(targetFile).then(function (obj) {
        targetDocument = obj;
    });

    var previousSettings = {};
    var promise = fluid.promise();

    // Copy the tabs from source into target.
    fluid.promise.sequence([sourcePromise, targetPromise]).then(function () {
        var tabsPath = "mso$customUI.mso$ribbon.mso$tabs.mso$tab";
        var targetTabsObject = fluid.get(targetDocument, tabsPath);
        var sourceTabsObject = fluid.get(sourceDocument, tabsPath);

        if (targetTabsObject) {
            var targetTabs = fluid.makeArray(targetTabsObject);
            var sourceTabs = fluid.makeArray(sourceTabsObject);

            // Copy each source tab into the target tab collection.
            fluid.each(sourceTabs, function (tab) {
                // Get a tab in the target with the same ID.
                var index = targetTabs.findIndex(function (t) {
                    return (t.id === tab.id);
                });

                var wasVisible;
                if (index === -1) {
                    // No tab in the target - add it to the collection.
                    targetTabs.push(tab);
                    wasVisible = false;
                } else {
                    // Target tab exists - toggle the visibility to match, don't change the target content.
                    wasVisible = targetTabs[index].visible;
                    targetTabs[index].visible = tab.visible;
                }

                previousSettings[tab.id] = {
                    visible: wasVisible
                };
            });

            fluid.set(targetDocument, tabsPath, targetTabs);
        } else if (targetDocument) {
            // No target tab collection found - add the source collection.
            fluid.set(targetDocument, tabsPath, sourceTabsObject);
            // Make sure the namespace is on the root element
            if (targetDocument.mso$customUI && sourceDocument.mso$customUI && !targetDocument.mso$customUI.xmlns$mso) {
                targetDocument.mso$customUI.xmlns$mso = sourceDocument.mso$customUI.xmlns$mso;
            }
        } else {
            // No target document - copy the source
            targetDocument = sourceDocument;
        }

        var content = xm.toxml(targetDocument);
        fs.writeFile(destinationFile, content, function (err) {
            if (err) {
                promise.reject(err);
            } else {
                promise.resolve();
            }
        });
    });

    return promise;
};

/**
 * Reloads the ribbon for a given Office Application.
 * @param {String} applicationName Name of the application, such as "Word" or "Excel"
 * @param {String} targetPath Path of the customUI file.
 * @param {Object} applicationObject Something that looks like an office automation COM object (for testing)
 * @return {Promise} Resolves when complete, with a boolean indicating if it succeeded.
 */
gpii.windows.office.reloadRibbon = function (applicationName, targetPath, applicationObject) {
    var promise = fluid.promise();

    fluid.log("Reloading ribbon for " + applicationName);

    if (targetPath && !fs.existsSync(targetPath)) {
        // When performing a live update, a non-existing file doesn't remove new the items added by the last update.
        // Set it to a special file to make it reset.
        fs.copyFileSync(path.join(__dirname, "reset.xml"), targetPath);
        var cleanup = function () {
            fs.unlinkSync(targetPath);
        };
        promise.then(cleanup, cleanup);
    }

    gpii.windows.office.reloadRibbonNative({
        applicationName: applicationName, applicationObject: applicationObject
    }, function (err, result) {
        if (err) {
            fluid.log("ReloadRibbon:", err);
            promise.reject(err);
        } else {
            promise.resolve(result);
        }
    });

    return promise;
};


fluid.defaults("gpii.windows.office.reloadRibbon", {
    gradeNames: "fluid.function",
    argumentMap: {
        application: 0,
        path: 1
    }
});
